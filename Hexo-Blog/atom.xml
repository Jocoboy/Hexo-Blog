<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jocoboy&#39;s Blog</title>
  
  
  <link href="https://jocoboy.github.io/Hexo-Blog/Hexo-Blog/atom.xml" rel="self"/>
  
  <link href="https://jocoboy.github.io/Hexo-Blog/"/>
  <updated>2025-08-01T09:27:22.779Z</updated>
  <id>https://jocoboy.github.io/Hexo-Blog/</id>
  
  <author>
    <name>Jocoboy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI大模型本地部署</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2025/07/17/ai-model-on-premise/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2025/07/17/ai-model-on-premise/</id>
    <published>2025-07-17T05:52:26.000Z</published>
    <updated>2025-08-01T09:27:22.779Z</updated>
    
    <content type="html"><![CDATA[<p>使用大模型部署和管理工具Ollama在本地部署AI大模型，并使用基于大语言模型和RAG的知识库问答系统MaxKB为大模型添加UI界面。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本地部署AI模型可以确保数据隐私和安全，降低长期成本，并提供更高的性能和控制权。本地部署AI模型的方案有很多，例如使用桌面应用程序LMstudio、使用大模型命令行部署和管理工具Ollama等。</p><p>本地大模型部署完成后，通常还需要添加UI界面，可以使用MaxKB、OpenWebUI等。二者侧重点不同，MaxKB侧重于为大模型添加关联知识库，OpenWebUI侧重于大模型的使用和管理。</p><h2 id="Ollama"><a href="#Ollama" class="headerlink" title="Ollama"></a>Ollama</h2><p>Ollama是一个命令行大模型部署和管理工具，可以用它将类似deepseek-r1这样的AI大模型部署到本地。Ollama支持运行Llama 3、Phi 3、Mistral、Gemma和其他模型，并允许定制和创建自己的模型。</p><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>Ollama支持MacOS、Linux、Windows等多种操作系统，在<a class="link"   href="https://ollama.com/" >Ollama官网<i class="fas fa-external-link-alt"></i></a>下载安装Ollama后，输入地址<code>http://localhost:11434/</code>可查看Ollama是否成功运行。</p><p>可以使用<code>ollama run [model-name]</code>命令下载并运行AI模型，下载完成后可以使用命令行进行对话，对话响应速度和显卡性能有关，输入<code>&gt;&gt;&gt; /bye</code>可以结束当前对话。使用<code>ollama list</code>命令可查看当前已下载的AI模型。</p><h3 id="Rest-API方式交互"><a href="#Rest-API方式交互" class="headerlink" title="Rest API方式交互"></a>Rest API方式交互</h3><p>除了命令行交互的方式，Ollama同样支持REST API的方式管理和运行大模型。</p><p>例如<code>POST /api/generate</code>使用提供的模型为给定提示生成响应，对应curl命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:11434/api/generate -d &#x27;&#123;</span><br><span class="line">  &quot;model&quot;: &quot;deepseek-r1&quot;,</span><br><span class="line">  &quot;prompt&quot;: &quot;Why is the sky blue?&quot;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="MaxKB"><a href="#MaxKB" class="headerlink" title="MaxKB"></a>MaxKB</h2><p>MaxKB是一个基于大语言模型和RAG的知识库问答系统。</p><h3 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h3><p>检索增强生成RAG(Retrieval-Augmented Generation)是一种结合了信息检索技术与语言生成模型的人工智能技术。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>由于大模型都是基于预训练的数据集训练出来的，如果你的问题超出了这个数据集的范围，那么它生成的内容很可能是不够准确的，也称为大模型的幻觉。</p><p>为了解决这个问题，通常需要将检索模型和生成模型结合在一起，通过从外部数据源添加一些上下文和背景知识，确保大模型有足够的信息来生成更加准确和可靠的答案。</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><img   src="/Hexo-Blog/2025/07/17/ai-model-on-premise/rag_workflow.png"  class="" title="RAG工作流程"><p>首先用户提出问题后，这个问题会被作为一个查询条件，从你的向量化知识库中进行检索，找到最相关的信息或文档，然后这些信息和文档会随着问题一起输入到大模型中，最后大模型会根据这些信息来生成答案，确保生成的答案更加准确和可靠。</p><h3 id="安装和部署"><a href="#安装和部署" class="headerlink" title="安装和部署"></a>安装和部署</h3><p>由于MaxKB只支持Linux系统(Unbuntu和CentOS等)上使用，在Windows上使用需要借助Docker。</p><p>可以使用以下命令下载MaxKB镜像到本地，创建并启动一个MaxKB容器。</p><p><code>docker run -d --name=maxkb -p 8088:8080 -v ~/.maxkb:/var/lib/postgresql/data 1panel/maxkb</code></p><p>启动后输入网址<code>http://localhost:8088</code>即可访问，默认账号为<code>admin</code>，密码为<code>MaxKB@123..</code>。</p><p>登录后点击模型设置，选择Ollama并点击添加模型，填写模型相关信息后会自动下载大模型，其中API URL填写<code>http://host.docker.internal:11434</code>。添加完成后点击应用，点击设置填写相关应用信息即可完成创建。</p><blockquote><p>注：host.docker.internal是Docker提供的一个特殊DNS名称，指向宿主机(Host)的内部IP地址。当容器需要访问宿主机上运行的服务(如数据库、API或其他应用)时，可以使用这个地址。</p></blockquote><h2 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h2><p>为了将AI大模型应用分享给其他人，需要使用ngrok。ngrok是一款强大的内网穿透工具，可帮助用户将本地服务暴露到公网，实现在外网访问本地服务。</p><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>在<a class="link"   href="https://ngrok.com/" >ngrok官网<i class="fas fa-external-link-alt"></i></a>下载安装ngrok，下载完成后登录ngrok个人账号，复制AUTHTOKEN，并执行<code>ngrok config add-authtoken $YOUR_AUTHTOKEN</code>命令即可完成配置。</p><p>配置完成后即可使用ngrok映射大模型应用，输入<code>ngrok http 8088</code>将会回显一个Forwarding地址，这个地址就是ngrok为我们映射的公网地址，将其替换<code>http://localhost:8088</code>即可。</p><p>注：对于所有HTTP请求，ngrok默认会返回一个html的警告页面，可在上述命令中添加参数<code>--request-header-add ngrok-skip-browser-warning:true</code>跳过此警告。</p><p>除此之外，还可以通过修改<code>%HOMEPATH%\AppData\Local\ngrok</code>目录下的ngrok.yml配置文件来实现。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">agent:</span></span><br><span class="line">    <span class="attr">authtoken:</span> <span class="string">&#x27;your-authtoken&#x27;</span></span><br><span class="line"><span class="attr">tunnels:</span></span><br><span class="line">  <span class="attr">example:</span></span><br><span class="line">    <span class="attr">proto:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">addr:</span> <span class="number">8088</span></span><br><span class="line">    <span class="attr">request_header:</span></span><br><span class="line">      <span class="attr">add:</span> [<span class="string">&quot;ngrok-skip-browser-warning: true&quot;</span>]</span><br></pre></td></tr></table></figure><p>修改完成后使用命令<code>ngrok start --all</code>即可启动服务。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://github.com/ollama/ollama/blob/main/docs/api.md" >Ollama API文档参考<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://maxkb.cn/docs/v2/installation/offline_installtion/" >MaxKB官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://ngrok.com/docs" >ngrok官方文档<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用大模型部署和管理工具Ollama在本地部署AI大模型，并使用基于大语言模型和RAG的知识库问答系统MaxKB为大模型添加UI界面。&lt;/p&gt;</summary>
    
    
    
    <category term="Artificial-Intelligence" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Artificial-Intelligence/"/>
    
    
    <category term="Ollama" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Ollama/"/>
    
    <category term="MaxKB" scheme="https://jocoboy.github.io/Hexo-Blog/tags/MaxKB/"/>
    
    <category term="RAG" scheme="https://jocoboy.github.io/Hexo-Blog/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>常用UML图特点及应用场景</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2025/06/12/uml-diagrams/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2025/06/12/uml-diagrams/</id>
    <published>2025-06-12T08:18:18.000Z</published>
    <updated>2025-08-01T09:27:22.794Z</updated>
    
    <content type="html"><![CDATA[<p>常用UML图类型介绍，以及不同UML图的特点及用法。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UML(Unified Modeling Language)统一建模语言，又称标准建模语言。是用来对软件密集系统进行可视化建模的一种语言。UML的定义包括UML语义和UML表示法两个元素。</p><p>UML是在开发阶段，说明、可视化、构建和书写一个面向对象软件密集系统的制品的开放方法。最佳的应用是工程实践，对大规模，复杂系统进行建模方面，特别是在软件架构层次，已经被验证有效。统一建模语言(UML)是一种模型化语言。模型大多以图表的方式表现出来。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。这些虽简单却非常重要，在UML规则中相互联系和扩展。</p><h2 id="UML的特点及应用场景"><a href="#UML的特点及应用场景" class="headerlink" title="UML的特点及应用场景"></a>UML的特点及应用场景</h2><p>UML具有以下特点：</p><ul><li><p>UML统一了各种方法对不同类型的系统、不同开发阶段以及不同内部概念的不同观点，从而有效的消除了各种建模语言之间不必要的差异。它实际上是一种通用的建模语言，可以为许多面向对象建模方法的用户广泛使用。</p></li><li><p>UML建模能力比其它面向对象建模方法更强。它不仅适合于一般系统的开发，而且对并行、分布式系统的建模尤为适宜。</p></li><li><p>UML是一种建模语言，而不是一个开发过程。</p></li></ul><p>UML的目标是以面向对象图的方式来描述任何类型的系统，具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML是一个通用的标准建模语言，可以对任何具有静态结构和动态行为的系统进行建模，而且适用于系统开发的不同阶段，从需求规格描述直至系统完成后的测试和维护。</p><h2 id="UML图类型"><a href="#UML图类型" class="headerlink" title="UML图类型"></a>UML图类型</h2><h3 id="结构行为图"><a href="#结构行为图" class="headerlink" title="结构行为图"></a>结构行为图</h3><h4 id="用例图-use-case-diagram"><a href="#用例图-use-case-diagram" class="headerlink" title="用例图(use case diagram)"></a>用例图(use case diagram)</h4><p>用例图捕捉了模拟系统中的动态行为，并且描述了用户、需求以及系统功能单元之间的关系，展示了一个外部用户能够观察到的系统功能模型图。用例图由主角，用例和它们之间的关系组成。</p><p>用例图的目的是捕捉到一个系统的动态方面，获取系统的外观图。用例图通常用来收集系统的要求，包括内部和外部的影响。这些要求大多是设计要求。所以，分析一个系统时要收集其功能用例和确定参与者。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>下面是一个用例图示例，代表订单管理系统。图中使用了三个用例(订单、特殊订单和正常订单)和一个参与者(顾客)。另外很重要的一点是确定系统边界，用例位于系统边界内，行为者位于系统边界外。关联线显示了用例和行为者之间的关系。</p><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/use_case_diagram.png"  class="" title="用例图示例"><h4 id="对象模型图-object-model-diagram"><a href="#对象模型图-object-model-diagram" class="headerlink" title="对象模型图(object model diagram)"></a>对象模型图(object model diagram)</h4><p>对象模型图(OMDS)指定了系统中类的结构和静态关系。对象模型图包含类图和对象图。如UML中所规定，它们显示了系统中的类、对象、接口和属性，以及它们之间的静态关系。</p><h5 id="类图-class-diagram"><a href="#类图-class-diagram" class="headerlink" title="类图(class diagram)"></a>类图(class diagram)</h5><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图不仅用于可视化描述和记录系统的不同方面，也为构建可执行代码的软件应用程序。<br>类图描述一类的属性和操作，也对系统的约束。被广泛应用于类图的建模的面向对象的系统中，因为它们是唯一的，可以直接映射到面向对象语言的UML图。</p><p>在UML类图中，常见的有以下几种关系: 泛化(Generalization), 实现(Realization)，关联(Association)，聚合(Aggregation)，组合(Composition)，依赖(Dependency)。<br>各种关系的强弱顺序： 泛化 &#x3D; 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><ul><li>泛化是一种继承关系，表示一般与特殊的关系，它指定了子类如何继承父类的所有特征和行为。<strong>泛化使用带空心三角箭头的实线表示</strong>。</li><li>实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。<strong>实现使用带空心三角箭头的虚线表示</strong>。</li><li>关联是一种拥有的关系，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。<strong>双向的关联使用一根实线或者带双向箭头的实线表示，单向的关联使用一根带单向箭头的实线表示</strong>。</li><li>聚合是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<strong>聚合使用带空心菱形箭头的实线表示</strong>。</li><li>组合是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<strong>组合使用带实心菱形箭头的实线表示</strong>。</li><li>依赖是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖。<strong>依赖使用带箭头的虚线表示</strong>。</li></ul><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/class_diagram_complex.png"  class="" title="复杂类图示例"><h5 id="对象图-object-diagram"><a href="#对象图-object-diagram" class="headerlink" title="对象图(object diagram)"></a>对象图(object diagram)</h5><p>对象图和类图一样反映系统的静态过程，但它是从实际的或原型化的情景来表达的。对象图显示某时刻对象和对象之间的关系，可看成一个类图的特殊用例，实例和类可在其中显示。<br>对象图是类图的实例，几乎使用与类图完全相同的标识。由于对象存在生命周期，因此对象图只能在系统某一时间段存在。</p><h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><p>假设一个订单管理系统的类图如下。</p><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/class_diagram_simple.png"  class="" title="简单类图示例"><p>其某一时刻对应的对象图如下。</p><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/object_diagram.png"  class="" title="对象图示例"><h4 id="组件图-component-diagram"><a href="#组件图-component-diagram" class="headerlink" title="组件图(component diagram)"></a>组件图(component diagram)</h4><p>组件图又称为组件图，由组件、接口和组件之间联系构成，他描述的是在软件系统中遵从并实现一组接口的物理的、可替换的软件模块。<br>组件图是用来表示系统中组件与组件之间，类或接口与组件之间的关系图。其中，组件之间的关系表现为依赖关系，定义的类或接口与类之间的关系表现为依赖关系或实现关系。<br>组件图的组成元素: 组件、接口、关系、端口、连接器。</p><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/component_diagram.png"  class="" title="组件图示例"><h4 id="部署图-deployment-diagram"><a href="#部署图-deployment-diagram" class="headerlink" title="部署图(deployment diagram)"></a>部署图(deployment diagram)</h4><p>部署图由节点以及节点之间的关系组成，描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。部署图通常用来帮助理解分布式系统，一个系统模型只有一个部署图。</p><p>部署图与组件图密切相关，部署图是用来描述软件组件部署的硬件组件；而组件图是用来描述组件和显示了它们是如何在硬件中部署。</p><h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/deployment_diagram.png"  class="" title="部署图示例"><h3 id="动态行为图"><a href="#动态行为图" class="headerlink" title="动态行为图"></a>动态行为图</h3><h4 id="交互图-interaction-diagram"><a href="#交互图-interaction-diagram" class="headerlink" title="交互图(interaction diagram)"></a>交互图(interaction diagram)</h4><h5 id="序列图-sequence-diagram"><a href="#序列图-sequence-diagram" class="headerlink" title="序列图(sequence diagram)"></a>序列图(sequence diagram)</h5><p>序列图又称时序图，是交互图的一种。它通过描写叙述对象之间发送消息的时间顺序，显示多个对象之间的动态协作。它能够表示用例的行为顺序，当运行一个用例行为时，序列图中的每条消息响应了一个类操作或状态机中引起转换的触发事件。<br>序列图展示对象之间的交互，这些交互是指在场景或用例的时间流中发生的，序列图属于动态建模。序列图的重点在消息序列上，也就是说，描写叙述消息是怎样在对象间发送和接收的，表示对象之间传送消息的时间顺序。<br>序列图的组成元素：对象、生命线、激活、消息。</p><h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/sequence_diagram.png"  class="" title="序列图示例"><h5 id="协作图-collaboration-diagram"><a href="#协作图-collaboration-diagram" class="headerlink" title="协作图(collaboration diagram)"></a>协作图(collaboration diagram)</h5><p>协作图，与序列图类似，显示对象、它们的消息以及它们在特定场景或用例中的关系。序列图强调消息流，可以指示发送或接收的消息的时间顺序，而协作图强调对象之间的关系。</p><p>协作图显示了通过关联角色传递的消息。消息通常是类操作的实例，它们被编号以表示顺序，也可以用子编号(例如，la.，1b.，1.1.2,1.1.3,2.3a.1.，2.3a.2.，等等)以表示同时发生的任务或实现更大任务的子任务。</p><h6 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h6><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/collaboration_diagram.png"  class="" title="协作图示例"><h4 id="状态图-statechart-diagram"><a href="#状态图-statechart-diagram" class="headerlink" title="状态图(statechart diagram)"></a>状态图(statechart diagram)</h4><p>状态图是对类图的补充。状态图描述了一个实体基于事件反映的动态行为，显示了该实体是如何根据当前所处的状态对不同的事件作出反应的。<br>一个状态图应该连接到所有具有清晰的可标志状态和复杂行为的类。状态图可以确定类的行为以及该行为如何根据当前的状态而变化，也可以展示哪些事件将会改变类的对象的状态。<br>状态图可以捕获对象、子系统和系统的生命周期，可以告知一个对象可以拥有的状态，并且事件(如消息的接收，时间的流逝、错误、条件为真等)会怎样随着时间的推移来影响这些状态。状态图主要是为了模拟响应系统。</p><p>一个状态图本质上就是一个状态机，或者是状态机的特殊情况，它基本上是一个状态机中元素的一个投影，这也就意味着状态图包括状态机的所有特征。<br>在UML中，状态图由表示状态的节点和表示状态之间转换的带箭头的直线组成。状态的转换由事件触发，状态和状态之间由转换箭头连接。每一个状态图都有一个初始状态（实心圆），用来表示状态机的开始。还有一个中止状态（半实心圆），用来表示状态机的终止。<br>状态图主要由元素状态、转换、初始状态、中止状态和判定等组成。</p><h5 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/statechart_diagram.png"  class="" title="状态图示例"><h4 id="活动图-activity-diagram"><a href="#活动图-activity-diagram" class="headerlink" title="活动图(activity diagram)"></a>活动图(activity diagram)</h4><p>活动图是一种特殊的状态图，它对于系统的功能建模特别重要，强调对象间的控制流程。与状态图不同，当行为不是由事件驱动时，活动图更为合适。</p><p>一个类(用例&#x2F;操作)可以有一个活动图或一个状态图，但不能同时拥有两者。然而，一个类、对象或用例可能有一个以上的活动图，其中一个图被指定为主要行为。</p><h5 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/activity_diagram.png"  class="" title="活动图示例"><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://www.w3cschool.cn/uml_tutorial/uml_tutorial-c1gf28pd.html" >UML概述中文版<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://www.tutorialspoint.com/uml/uml_overview.htm" >UML概述英文版<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用UML图类型介绍，以及不同UML图的特点及用法。&lt;/p&gt;</summary>
    
    
    
    <category term="Architecture" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Architecture/"/>
    
    
    <category term="UML" scheme="https://jocoboy.github.io/Hexo-Blog/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>.NET实现断点续传(上传/下载)</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2025/03/25/resumable-upload-and-download/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2025/03/25/resumable-upload-and-download/</id>
    <published>2025-03-25T09:28:11.000Z</published>
    <updated>2025-08-01T09:27:22.793Z</updated>
    
    <content type="html"><![CDATA[<p>基于.NET实现大文件的断点续传功能，包含上传与下载。其中上传部分包括分片上传与断点续传功能，并借助WinForm实现上传进度反馈、并行上传、分片大小动态调整等辅助功能。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>断点续传基于分片上传和分片下载，包含断点续传上传与断点续传下载两部分，下面基于.NET分别对其进行功能实现。</p><h2 id="断点续传上传"><a href="#断点续传上传" class="headerlink" title="断点续传上传"></a>断点续传上传</h2><p>在文件上传场景中，分片上传和断点续传是处理大文件上传的重要技术。</p><p>除了基本的断点续传功能，大文件上传还应提供以下辅助功能：</p><ul><li>分片大小调整：根据网络状况动态调整分片大小</li><li>并行上传：可以并行上传多个分片以提高速度</li><li>完整性校验：合并文件后校验哈希值确保文件完整</li><li>清理机制：定期清理未完成上传的临时分片</li><li>进度反馈：提供上传进度信息给用户</li></ul><p>下面我们来简单实现上述功能。</p><h3 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h3><p>分片上传流程如下：</p><ul><li>客户端首次上传前生成文件唯一ID(通常使用文件内容哈希，此处为了演示重新上传是从0开始的，使用的是Guid)</li><li>客户端将文件分割为固定大小的块，每块单独上传到服务器</li><li>服务器接收并临时保存每个分片</li><li>当所有分片上传完成后，服务器合并分片为完整文件</li></ul><h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>UploadChunk接口实现了分片的临时存储(存储的临时文件名为fileId_chunkNumber)，以及分片的最终合并。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">AllowAnonymous</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> form = <span class="keyword">await</span> Request.ReadFormAsync(cancellationToken);</span><br><span class="line">    <span class="keyword">var</span> fileId = form[<span class="string">&quot;fileId&quot;</span>].ToString();</span><br><span class="line">    <span class="keyword">var</span> chunkNumber = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkNumber&quot;</span>].ToString());</span><br><span class="line">    <span class="keyword">var</span> totalChunks = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;totalChunks&quot;</span>].ToString());</span><br><span class="line">    <span class="keyword">var</span> fileName = form[<span class="string">&quot;fileName&quot;</span>].ToString();</span><br><span class="line">    <span class="keyword">var</span> chunk = form.Files[<span class="string">&quot;chunk&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保上传目录存在</span></span><br><span class="line">    Directory.CreateDirectory(_uploadPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时保存分片</span></span><br><span class="line">    <span class="keyword">var</span> chunkPath = Path.Combine(_uploadPath, <span class="string">$&quot;<span class="subst">&#123;fileId&#125;</span>_<span class="subst">&#123;chunkNumber&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> FileStream(chunkPath, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> chunk.CopyToAsync(stream, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是最后一个分片，合并文件</span></span><br><span class="line">    <span class="keyword">if</span> (chunkNumber == totalChunks - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> MergeChunksAsync(fileId, totalChunks, fileName, cancellationToken);</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Message = <span class="string">&quot;Upload complete&quot;</span>, FileName = fileName &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Message = <span class="string">&quot;Chunk uploaded&quot;</span>, ChunkNumber = chunkNumber &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">MergeChunksAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> finalPath = Path.Combine(_uploadPath, fileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> finalStream = <span class="keyword">new</span> FileStream(finalPath, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; totalChunks; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> chunkPath = Path.Combine(_uploadPath, <span class="string">$&quot;<span class="subst">&#123;fileId&#125;</span>_<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> chunkStream = System.IO.File.OpenRead(chunkPath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> chunkStream.CopyToAsync(finalStream, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            System.IO.File.Delete(chunkPath); <span class="comment">// 合并后删除分片</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ChunkedUploadService类，用来处理本地的文件流，并调用服务端的分片上传接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChunkedUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> UploadChunkApiUri = <span class="string">&quot;/api/Upload/UploadChunk&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChunkedUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serviceUri = serviceUri;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadInChunksAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">        <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">        <span class="keyword">var</span> fileId = Guid.NewGuid().ToString(); <span class="comment">// 唯一文件标识</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">            <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead]; <span class="comment">// 只取实际读取的字节</span></span><br><span class="line">            Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkNumber, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, <span class="built_in">byte</span>[] chunkData, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(fileId), <span class="string">&quot;fileId&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(chunkNumber.ToString()), <span class="string">&quot;chunkNumber&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(totalChunks.ToString()), <span class="string">&quot;totalChunks&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(fileName), <span class="string">&quot;fileName&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> ByteArrayContent(chunkData), <span class="string">&quot;chunk&quot;</span>, <span class="string">&quot;chunk.dat&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;UploadChunkApiUri&#125;</span>&quot;</span>, content, cancellationToken);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在客户端的UI线程中使用异步方式调用ChunkedUploadService类中的分片上传方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> filePath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;srcDir&#125;</span>\\<span class="subst">&#123;srcFile&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> uploader = <span class="keyword">new</span> ChunkedUploadService(serviceUri);</span><br><span class="line"><span class="keyword">await</span> uploader.UploadInChunksAsync(filePath, CancellationToken.None);</span><br></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传流程如下：</p><ul><li>客户端首次上传前生成文件唯一ID</li><li>上传前根据文件文件唯一ID查询服务器已接收的分片，继续上传时只上传缺失的分片</li><li>当所有分片上传完成后合并分片</li></ul><h4 id="服务端实现-1"><a href="#服务端实现-1" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>GetUploadStatus接口根据文件标识fileId查询已上传的分片编号，UploadChunk接口的功能同上。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadController</span>: <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWebHostEnvironment _env;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uploadPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadController</span>(<span class="params">IWebHostEnvironment env</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _env = env;</span><br><span class="line">        _uploadPath = Path.Combine(_env.WebRootPath, <span class="string">&quot;uploads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetUploadStatus</span>(<span class="params"><span class="built_in">string</span> fileId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uploadedChunks = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Directory.Exists(_uploadPath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> chunkFiles = Directory.GetFiles(_uploadPath, <span class="string">$&quot;<span class="subst">&#123;fileId&#125;</span>_*&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> chunkFile <span class="keyword">in</span> chunkFiles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">int</span>.TryParse(Path.GetFileName(chunkFile).Split(<span class="string">&#x27;_&#x27;</span>).Last(), <span class="keyword">out</span> <span class="keyword">var</span> chunkNumber))</span><br><span class="line">                &#123;</span><br><span class="line">                    uploadedChunks.Add(chunkNumber);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(uploadedChunks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同分片上传</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">MergeChunksAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同分片上传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端实现-1"><a href="#客户端实现-1" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ResumableUploadService类，调用服务端的文件分片上传状态接口，对于已上传的分片跳过处理，然后调用服务端的分片上传接口继续上传，以实现断点续传功能。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> UploadChunkApiUri = <span class="string">&quot;/api/Upload/UploadChunk&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> GetUploadStatusApiUri = <span class="string">&quot;/api/Upload/GetUploadStatus&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResumableUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serviceUri = serviceUri;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadWithResumeAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">        <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">        <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">        <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uploadedChunks.Contains(chunkNumber))  <span class="keyword">continue</span>; <span class="comment">// 跳过已上传的分片</span></span><br><span class="line"></span><br><span class="line">            fileStream.Seek(chunkNumber * ChunkSize, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">            <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead];</span><br><span class="line">            Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileHash</span>(<span class="params">Stream stream, HashAlgorithmType hashAlgorithmType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hashAlgorithmType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Md5:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = MD5.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Sha256:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = SHA256.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">async</span> Task&lt;List&lt;<span class="built_in">int</span>&gt;&gt; GetUploadedChunksAsync(<span class="built_in">string</span> fileId, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.GetAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;GetUploadStatusApiUri&#125;</span>?fileId=<span class="subst">&#123;fileId&#125;</span>&quot;</span>);</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> json = <span class="keyword">await</span> response.Content.ReadAsStringAsync(cancellationToken);</span><br><span class="line">            <span class="keyword">return</span> JsonSerializer.Deserialize&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(json);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkNumber, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, <span class="built_in">byte</span>[] chunkData, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 同分片上传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在客户端的UI线程中使用异步方式调用ResumableUploadService类中的断点续传方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> filePath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;srcDir&#125;</span>\\<span class="subst">&#123;srcFile&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> uploader = <span class="keyword">new</span> ResumableUploadService(serviceUri);</span><br><span class="line"><span class="keyword">await</span> uploader.UploadWithResumeAsync(filePath, CancellationToken.None);</span><br></pre></td></tr></table></figure><h3 id="上传进度反馈与上传取消"><a href="#上传进度反馈与上传取消" class="headerlink" title="上传进度反馈与上传取消"></a>上传进度反馈与上传取消</h3><p>通常情况下，大文件上传时需要给用户提供上传进度信息以及取消上传的功能，下面使用WinForm简单实现上述功能。</p><h4 id="服务端实现-2"><a href="#服务端实现-2" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>服务端代码延用<a href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a>，不再展示。</p><h4 id="客户端实现-2"><a href="#客户端实现-2" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端的ResumableUploadService中的主要变化是添加了三个委托事件，分别用来更新上传百分比、状态消息、上传与取消按钮禁用状态。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; ProgressChanged; <span class="comment">// 上传百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; StatusChanged; <span class="comment">// 状态消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">bool</span>&gt; UploadCompleted; <span class="comment">// 完成状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadWithResumeAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">            <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++)</span><br><span class="line">            &#123;</span><br><span class="line">                cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (uploadedChunks.Contains(chunkNumber))</span><br><span class="line">                &#123;</span><br><span class="line">                    ProgressChanged?.Invoke((<span class="built_in">int</span>)((<span class="built_in">double</span>)chunkNumber / totalChunks * <span class="number">100</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fileStream.Seek(chunkNumber * ChunkSize, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">                <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead];</span><br><span class="line">                Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;正在上传分片 <span class="subst">&#123;chunkNumber + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;totalChunks&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)(chunkNumber + <span class="number">1</span>) / totalChunks * <span class="number">100</span>);</span><br><span class="line">                ProgressChanged?.Invoke(progress);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主窗体MainForm中分别绑定三个委托事件到相应的UI线程上，使用Invoke跨线程更新UI，实现上传过程中实时更新上传进度及状态信息。</p><p>Control.InvokeRequired属性指示调用方在对控件进行方法调用时是否必须调用Invoke方法，因为调用方位于创建控件所在的线程以外的线程中。Windows窗体中的控件绑定到特定线程，并且不是线程安全的。因此，如果要从其他线程调用控件的方法，则必须使用控件的调用方法之一来封送对正确线程的调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ResumableUploadService _uploader;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cts;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _uploader = <span class="keyword">new</span> ResumableUploadService(_serviceUri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _uploader.ProgressChanged += UpdateProgress;</span><br><span class="line">        _uploader.StatusChanged += UpdateStatus;</span><br><span class="line">        _uploader.UploadCompleted += UploadCompleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateProgress</span>(<span class="params"><span class="built_in">int</span> percent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (progressBar.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">int</span>&gt;(UpdateProgress), percent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        progressBar.Value = percent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateStatus</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lblStatus.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            lblStatus.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">string</span>&gt;(UpdateStatus), message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lblStatus.Text = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UploadCompleted</span>(<span class="params"><span class="built_in">bool</span> success</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (btnUpload.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            btnUpload.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">bool</span>&gt;(UploadCompleted), success);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        btnUpload.Enabled = <span class="literal">true</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">btnUpload_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(textBox.Text) || !File.Exists(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;请选择有效的文件&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnUpload.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">true</span>;</span><br><span class="line">        progressBar.Value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        <span class="keyword">await</span> _uploader.UploadWithResumeAsync(textBox.Text,_cts.Token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnBrowse_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> openFileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">        <span class="keyword">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            textBox.Text = openFileDialog.FileName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFormClosing</span>(<span class="params">FormClosingEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">        <span class="keyword">base</span>.OnFormClosing(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行上传"><a href="#并行上传" class="headerlink" title="并行上传"></a>并行上传</h3><p>并行上传是提升大文件传输效率的有效手段，并行上传可将总时间缩短为单线程上传时间&#x2F;N(N为并行度)。并行上传适合在不稳定的网络环境(如高延迟)中使用，可充分利用间歇性网络带宽。</p><p>并行上传时多个分片同时上报上传进度，进度条呈现更平滑，更适合需要实时进度反馈的场景。</p><h4 id="服务端实现-3"><a href="#服务端实现-3" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>服务端代码延用<a href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a>，不再展示。</p><h4 id="客户端实现-3"><a href="#客户端实现-3" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端基于ResumableUploadService，创建了一个并行上传服务类ParallelUploadService，使用<code>Parallel.ForEachAsync</code>实现并行上传，并设置了最大并行度(默认为4)。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParallelUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri, <span class="built_in">int</span> maxParallelism = <span class="number">4</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ParallelUploadFileAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">            <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> chunksToUpload = Enumerable.Range(<span class="number">0</span>, totalChunks).Where(chunk =&gt; !uploadedChunks.Contains(chunk)).ToList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> progressLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">            <span class="keyword">var</span> uploadedCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> totalToUpload = chunksToUpload.Count;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;准备上传 <span class="subst">&#123;totalToUpload&#125;</span> 个分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> parallelOptions = <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cancellationToken</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> Parallel.ForEachAsync(chunksToUpload, parallelOptions, <span class="keyword">async</span> (chunkNumber, cancellationToken) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                fileStream.Seek(chunkNumber * ChunkSize, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">                <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead];</span><br><span class="line">                Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;正在上传分片 <span class="subst">&#123;chunkNumber + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;totalChunks&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用锁保证进度更新的原子性</span></span><br><span class="line">                <span class="keyword">lock</span> (progressLock)</span><br><span class="line">                &#123;</span><br><span class="line">                    uploadedCount++;</span><br><span class="line">                    <span class="keyword">var</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)uploadedCount / totalToUpload * <span class="number">100</span>);</span><br><span class="line">                    ProgressChanged?.Invoke(progress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主窗体MainForm中对于ParallelUploadService服务类的调用方式与ResumableUploadService类似，不再展示。</p><h3 id="动态调整分片大小"><a href="#动态调整分片大小" class="headerlink" title="动态调整分片大小"></a>动态调整分片大小</h3><p>根据网络状态动态调整分片大小，可以优化分片上传效率。</p><h4 id="服务端实现-4"><a href="#服务端实现-4" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>由于分片的大小是动态计算得出的，存储的临时文件名由fileId_chunkNumber变更为{fileId}&#x2F;chunk_{offsetValue}。</p><p>服务端的分片存储结构如下：</p><blockquote><p>uploads&#x2F;<br>├── {fileId}&#x2F;          &#x2F;&#x2F; 每个文件一个独立目录<br>│   ├── chunk_{offsetValue1}        &#x2F;&#x2F; 分片文件按偏移量命名<br>│   ├── chunk_{offsetValue2}<br>│   └── …<br>└── completed&#x2F;       &#x2F;&#x2F; 最终合并的文件</p></blockquote><p>由于上传是并行的，服务端在检查分片上传完整性时，必须以所有分片大小总和等于文件大小为标志，而不能以其中某一分片的偏移量+分片大小等于文件大小为标志。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadController</span>: <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWebHostEnvironment _env;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uploadPath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;UploadController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadController</span>(<span class="params">IWebHostEnvironment env, ILogger&lt;UploadController&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _env = env;</span><br><span class="line">        _uploadPath = Path.Combine(_env.WebRootPath, <span class="string">&quot;uploads&quot;</span>);</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Ping</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(DateTime.UtcNow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetUploadStatus</span>(<span class="params"><span class="built_in">string</span> fileId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uploadDir = Path.Combine(_uploadPath, fileId);</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(uploadDir))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; UploadedChunks = Array.Empty&lt;UploadedChunk&gt;() &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> chunks = Directory.GetFiles(uploadDir, <span class="string">&quot;chunk_*&quot;</span>)</span><br><span class="line">            .Select(f =&gt; <span class="keyword">new</span> FileInfo(f))</span><br><span class="line">            .Select(f =&gt; <span class="keyword">new</span> UploadedChunk</span><br><span class="line">            &#123;</span><br><span class="line">                Offset = <span class="built_in">long</span>.Parse(f.Name.Split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">1</span>]),</span><br><span class="line">                Size = (<span class="built_in">int</span>)f.Length</span><br><span class="line">            &#125;)</span><br><span class="line">            .OrderBy(c =&gt; c.Offset)</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; UploadedChunks = chunks &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> form = <span class="keyword">await</span> Request.ReadFormAsync(cancellationToken);</span><br><span class="line">        <span class="keyword">var</span> fileId = form[<span class="string">&quot;fileId&quot;</span>].ToString();</span><br><span class="line">        <span class="keyword">var</span> chunkIndex = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkIndex&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> chunkOffset = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkOffset&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> chunkSize = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkSize&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> fileSize = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;fileSize&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> fileName = form[<span class="string">&quot;fileName&quot;</span>].ToString();</span><br><span class="line">        <span class="keyword">var</span> chunk = form.Files[<span class="string">&quot;chunk&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 验证分片</span></span><br><span class="line">            <span class="keyword">if</span> (chunk == <span class="literal">null</span> || chunk.Length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;无效的分片数据&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建上传目录</span></span><br><span class="line">            <span class="keyword">var</span> uploadDir = Path.Combine(_uploadPath, fileId);</span><br><span class="line">            Directory.CreateDirectory(uploadDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存分片</span></span><br><span class="line">            <span class="keyword">var</span> chunkPath = Path.Combine(uploadDir, <span class="string">$&quot;chunk_<span class="subst">&#123;chunkOffset&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> FileStream(chunkPath, FileMode.Create))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> chunk.CopyToAsync(stream, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _logger.LogInformation(<span class="string">$&quot;已接收分片 <span class="subst">&#123;chunkIndex&#125;</span> (偏移: <span class="subst">&#123;chunkOffset&#125;</span>, 大小: <span class="subst">&#123;chunk.Length&#125;</span>, 剩余大小: <span class="subst">&#123;fileSize - chunkOffset&#125;</span>)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否完成</span></span><br><span class="line">            <span class="keyword">if</span> (IsUploadComplete(fileId, fileSize))</span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogInformation(<span class="string">$&quot;文件 <span class="subst">&#123;fileName&#125;</span> 所有分片已上传&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Completed = <span class="literal">true</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Completed = <span class="literal">false</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(OperationCanceledException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 客户端主动取消上传，最后一个分片可能未完整上传，需要进行删除，否则客户端断点续传时，在对分片信息的更新过程中会发生错误</span></span><br><span class="line">            System.IO.File.Delete(Path.Combine(Path.Combine(_uploadPath, fileId), <span class="string">$&quot;chunk_<span class="subst">&#123;chunkOffset&#125;</span>&quot;</span>));</span><br><span class="line">            <span class="keyword">var</span> errorMsg = <span class="string">$&quot;分片上传失败:<span class="subst">&#123;ex.Message&#125;</span>, 分片 chunk_<span class="subst">&#123;chunkOffset&#125;</span> 已删除！&quot;</span>;</span><br><span class="line">            _logger.LogError(errorMsg);</span><br><span class="line">            <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> errorMsg = <span class="string">$&quot;分片上传失败:<span class="subst">&#123;ex.Message&#125;</span>&quot;</span>;</span><br><span class="line">            _logger.LogError(errorMsg);</span><br><span class="line">            <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">MergeChunksAsync</span>(<span class="params">MergeFile mergeFile, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uploadDir = Path.Combine(_uploadPath, mergeFile.FileId);</span><br><span class="line">        <span class="keyword">var</span> finalDir = Path.Combine(_uploadPath, <span class="string">&quot;completed&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> finalPath = Path.Combine(finalDir, mergeFile.FileName);</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(finalDir))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(finalDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有分片并按偏移量排序</span></span><br><span class="line">        <span class="keyword">var</span> chunkFiles = Directory.GetFiles(uploadDir, <span class="string">&quot;chunk_*&quot;</span>)</span><br><span class="line">            .Select(f =&gt; <span class="keyword">new</span></span><br><span class="line">            &#123;</span><br><span class="line">                Path = f,</span><br><span class="line">                Offset = <span class="built_in">long</span>.Parse(Path.GetFileName(f).Split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">            &#125;)</span><br><span class="line">            .OrderBy(x =&gt; x.Offset)</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并文件</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> finalStream = <span class="keyword">new</span> FileStream(finalPath, FileMode.Create))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> chunk <span class="keyword">in</span> chunkFiles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> chunkStream = System.IO.File.OpenRead(chunk.Path))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> chunkStream.CopyToAsync(finalStream, cancellationToken);</span><br><span class="line">                &#125;</span><br><span class="line">                System.IO.File.Delete(chunk.Path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理临时目录</span></span><br><span class="line">        Directory.Delete(uploadDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> stream = System.IO.File.OpenRead(finalPath);</span><br><span class="line">        <span class="keyword">var</span> mergeFileId = GetFileHash(stream, HashAlgorithmType.Sha256);</span><br><span class="line">        <span class="keyword">if</span> (!mergeFile.FileId.Equals(mergeFileId))</span><br><span class="line">        &#123;</span><br><span class="line">            stream.Close();</span><br><span class="line">            System.IO.File.Delete(finalPath);</span><br><span class="line">            <span class="keyword">var</span> errorMsg = <span class="string">$&quot;合并后的文件内容哈希不正确，文件可能已损坏，合并前内容哈希为<span class="subst">&#123;mergeFile.FileId&#125;</span>, 合并后内容哈希为<span class="subst">&#123;mergeFileId&#125;</span>, 合并后的文件已被删除，请重新上传！&quot;</span>;</span><br><span class="line">            _logger.LogError(errorMsg);</span><br><span class="line">            <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;文件合并完成: <span class="subst">&#123;finalPath&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> private methods</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileHash</span>(<span class="params">Stream stream, HashAlgorithmType hashAlgorithmType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hashAlgorithmType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Md5:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = MD5.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Sha256:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = SHA256.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsUploadComplete</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">long</span> fileSize</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> status = GetUploadStatus(fileId) <span class="keyword">as</span> OkObjectResult;</span><br><span class="line">        <span class="keyword">var</span> data = status?.Value <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">        <span class="keyword">var</span> chunks = data?.UploadedChunks <span class="keyword">as</span> IEnumerable&lt;UploadedChunk&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (chunks == <span class="literal">null</span> || !chunks.Any())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件总大小(最后一个分片的结束位置)</span></span><br><span class="line">        <span class="comment">// 请勿使用chunks.Max(c =&gt; c.Offset + c.Size), 该值在单线程环境中可以代表所有分片都已上传完毕, 但在多线程环境中是错误的</span></span><br><span class="line">        <span class="built_in">long</span> currentTotalSize = chunks.Sum(c =&gt; c.Size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否覆盖了所有字节</span></span><br><span class="line">        <span class="keyword">return</span> currentTotalSize &gt;= fileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> public class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadedChunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Offset &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MergeFile</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FileId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FileName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用服务端上传时的日志记录如下，可以看到分片的上传是乱序的：</p><img   src="/Hexo-Blog/2025/03/25/resumable-upload-and-download/adaptive_resumable_upload_console.png"  class="" title="服务端日志记录输出"><h4 id="客户端实现-4"><a href="#客户端实现-4" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端实现了AdaptiveResumableUploadService服务类，在并行上传与断点续传的基础上，添加了实时更新网络指标(上行速度&#x2F;网络延迟)并动态计算当前分片大小的功能，并使用了异步锁SemaphoreSlim确保分片信息更新时的原子性。</p><p>注：请勿使用同步锁lock，否则会报错<code>Object synchronization method was called from an unsynchronized block of code</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdaptiveResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> UploadChunkApiUri = <span class="string">&quot;/api/Upload/UploadChunk&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> GetUploadStatusApiUri = <span class="string">&quot;/api/Upload/GetUploadStatus&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> MergeChunksApiUri = <span class="string">&quot;/api/Upload/MergeChunks&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PingApiUri = <span class="string">&quot;/api/Ping&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _minChunkSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxChunkSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _initialChunkSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络状况监测</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _averageUploadSpeedMbps = <span class="number">1.0</span>; <span class="comment">// 初始假设1Mbps</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _averageLatencyMs = <span class="number">100</span>; <span class="comment">// 初始延迟100ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _networkLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; ProgressChanged; <span class="comment">// 上传百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; StatusChanged; <span class="comment">// 状态消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">bool</span>&gt; UploadCompleted; <span class="comment">// 完成状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveResumableUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> maxParallelism =  <span class="number">4</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> minChunkSize = <span class="number">256</span> * <span class="number">1024</span>,    // <span class="number">256</span>KB</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> maxChunkSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>, // <span class="number">10</span>MB</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> initialChunkSize = <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span></span>) <span class="comment">// 1MB</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _serviceUri = serviceUri;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        _httpClient.Timeout = Timeout.InfiniteTimeSpan;</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">        _minChunkSize = minChunkSize;</span><br><span class="line">        _maxChunkSize = maxChunkSize;</span><br><span class="line">        _initialChunkSize = initialChunkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主上传方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadFileAdaptiveAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">            <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备上传任务</span></span><br><span class="line">            <span class="keyword">var</span> currentChunkSize = _initialChunkSize;</span><br><span class="line">            <span class="keyword">var</span> fileSize = fileInfo.Length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> progressLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">            <span class="built_in">long</span> totalUploaded = uploadedChunks.Values.Sum();</span><br><span class="line">            <span class="built_in">long</span> totalToUpload = fileSize - totalUploaded;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;需要上传 <span class="subst">&#123;totalToUpload&#125;</span> 字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> parallelOptions = <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cancellationToken</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> Parallel.ForEachAsync(GenerateChunks(fileSize, currentChunkSize, uploadedChunks), parallelOptions, <span class="keyword">async</span> (chunk, cancellationToken) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">bool</span> success = <span class="keyword">await</span> UploadChunkAsync(fileId, chunk.Index, chunk.Offset, chunk.Size, fileSize, fileInfo.Name, fileStream, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (success)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 使用锁保证进度更新的原子性</span></span><br><span class="line">                    <span class="keyword">lock</span> (progressLock)</span><br><span class="line">                    &#123;</span><br><span class="line">                        totalUploaded += chunk.Size;</span><br><span class="line">                        <span class="built_in">int</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)totalUploaded / fileSize * <span class="number">100</span>);</span><br><span class="line">                        ProgressChanged?.Invoke(progress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            ProgressChanged?.Invoke(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">await</span> MergeChunksAsync(fileId, fileInfo.Name, cancellationToken);</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">async</span> Task&lt;ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt;&gt; GetUploadedChunksAsync(<span class="built_in">string</span> fileId, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.GetAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;GetUploadStatusApiUri&#125;</span>?fileId=<span class="subst">&#123;fileId&#125;</span>&quot;</span>, cancellationToken);</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> response.Content.ReadFromJsonAsync&lt;UploadStatusResponse&gt;(cancellationToken);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt;(result.UploadedChunks.ToDictionary(x =&gt; x.Offset, x =&gt; x.Size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传单个分片</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkIndex, <span class="built_in">long</span> chunkOffset, <span class="built_in">int</span> chunkSize, <span class="built_in">long</span> fileSize,  <span class="built_in">string</span> fileName, Stream fileStream, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> stopwatch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 测量请求延迟</span></span><br><span class="line">            <span class="keyword">var</span> latencyStopwatch = Stopwatch.StartNew();</span><br><span class="line">            <span class="keyword">var</span> pingResponse = <span class="keyword">await</span> _httpClient.GetAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;PingApiUri&#125;</span>&quot;</span>, cancellationToken);</span><br><span class="line">            latencyStopwatch.Stop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备分片数据</span></span><br><span class="line">            <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[chunkSize];</span><br><span class="line">            fileStream.Seek(chunkOffset, SeekOrigin.Begin);</span><br><span class="line">            <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, chunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">            &#123;</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(fileId), <span class="string">&quot;fileId&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(chunkIndex.ToString()), <span class="string">&quot;chunkIndex&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(chunkOffset.ToString()), <span class="string">&quot;chunkOffset&quot;</span> &#125;,                   </span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(bytesRead.ToString()), <span class="string">&quot;chunkSize&quot;</span>&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(fileSize.ToString()), <span class="string">&quot;fileSize&quot;</span>&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(fileName), <span class="string">&quot;fileName&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> ByteArrayContent(chunkData, <span class="number">0</span>, bytesRead), <span class="string">&quot;chunk&quot;</span>, <span class="string">&quot;chunk.dat&quot;</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            <span class="keyword">var</span> uploadStopwatch = Stopwatch.StartNew();</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;UploadChunkApiUri&#125;</span>&quot;</span>, content, cancellationToken);</span><br><span class="line">            uploadStopwatch.Stop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!response.IsSuccessStatusCode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> error = <span class="keyword">await</span> response.Content.ReadAsStringAsync(cancellationToken);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HttpRequestException(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新网络指标</span></span><br><span class="line">            UpdateNetworkMetrics(bytesRead, uploadStopwatch.Elapsed, latencyStopwatch.Elapsed);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            stopwatch.Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传完所有分片后合并分片</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">MergeChunksAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">string</span> fileName, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> stringContent = <span class="keyword">new</span> StringContent(JsonSerializer.Serialize(<span class="keyword">new</span> &#123; FileId = fileId, FileName = fileName &#125;), Encoding.UTF8, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;MergeChunksApiUri&#125;</span>&quot;</span>, stringContent, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!response.IsSuccessStatusCode)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> error = <span class="keyword">await</span> response.Content.ReadAsStringAsync(cancellationToken);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpRequestException(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileHash</span>(<span class="params">Stream stream, HashAlgorithmType hashAlgorithmType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hashAlgorithmType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Md5:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = MD5.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Sha256:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = SHA256.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 更新网络指标并动态计算当前分片大小</span></span><br><span class="line">    <span class="comment">// 动态计算当前分片大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">CalculateDynamicChunkSize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_networkLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 基于当前上传速度和延迟计算理想分片大小</span></span><br><span class="line">            <span class="built_in">double</span> targetUploadTimeSec = <span class="number">2.0</span>; <span class="comment">// 目标每个分片上传时间</span></span><br><span class="line">            <span class="built_in">double</span> speedFactor = _averageUploadSpeedMbps* <span class="number">125000</span>; <span class="comment">// Mbps -&gt; bytes/sec</span></span><br><span class="line">            <span class="built_in">double</span> latencyFactor = Math.Max(<span class="number">1</span>, _averageLatencyMs / <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> idealSize = (<span class="built_in">int</span>)(speedFactor * targetUploadTimeSec / latencyFactor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制在最小和最大值之间</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">int</span>)Math.Clamp(idealSize, _minChunkSize, _maxChunkSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新网络指标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateNetworkMetrics</span>(<span class="params"><span class="built_in">long</span> chunkSize, TimeSpan uploadTime, TimeSpan latency</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_networkLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算速度 (Mbps)</span></span><br><span class="line">            <span class="built_in">double</span> speedMbps = (chunkSize * <span class="number">8</span> / uploadTime.TotalSeconds) / <span class="number">1</span>_000_000;</span><br><span class="line">            <span class="comment">// 平滑处理速度值（加权平均）</span></span><br><span class="line">            _averageUploadSpeedMbps = <span class="number">0.7</span> * _averageUploadSpeedMbps + <span class="number">0.3</span> * speedMbps;</span><br><span class="line">            <span class="comment">// 更新延迟</span></span><br><span class="line">            _averageLatencyMs = <span class="number">0.8</span> * _averageLatencyMs + <span class="number">0.2</span> * latency.TotalMilliseconds;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;网络: <span class="subst">&#123;_averageUploadSpeedMbps:F1&#125;</span>Mbps, &quot;</span> +</span><br><span class="line">                                <span class="string">$&quot;延迟: <span class="subst">&#123;_averageLatencyMs:F0&#125;</span>ms, &quot;</span> +</span><br><span class="line">                                <span class="string">$&quot;分片: <span class="subst">&#123;CalculateDynamicChunkSize() / <span class="number">1024</span>&#125;</span>KB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerable&lt;FileChunk&gt; <span class="title">GenerateChunks</span>(<span class="params"><span class="built_in">long</span> fileSize, <span class="built_in">int</span> currentChunkSize, ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt; uploadedChunks</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">long</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> chunkIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (position &lt; fileSize)</span><br><span class="line">        &#123;</span><br><span class="line">            _semaphoreSlim.WaitAsync(); <span class="comment">// 使用异步锁确保分片信息更新时的原子性</span></span><br><span class="line">            <span class="keyword">if</span> (!uploadedChunks.TryGetValue(position, <span class="keyword">out</span> <span class="keyword">var</span> chunkSize))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 动态调整分片大小</span></span><br><span class="line">                currentChunkSize = CalculateDynamicChunkSize();</span><br><span class="line">                <span class="keyword">var</span> actualChunkSize = (<span class="built_in">int</span>)Math.Min(currentChunkSize, fileSize - position);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 惰性求值: 迭代器代码直到开始遍历才会执行，每次迭代时返回一个值，并保持当前执行状态(局部变量、执行位置等)</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> FileChunk</span><br><span class="line">                &#123;</span><br><span class="line">                    Index = chunkIndex,</span><br><span class="line">                    Offset = position,</span><br><span class="line">                    Size = actualChunkSize,</span><br><span class="line">                    RemainingSize = fileSize - (position + actualChunkSize)</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                position += actualChunkSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                position += chunkSize;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            chunkIndex++;</span><br><span class="line"></span><br><span class="line">            _semaphoreSlim.Release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> record</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">record</span> <span class="title">UploadedChunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Offset &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">record</span> <span class="title">UploadStatusResponse</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;UploadedChunk&gt; UploadedChunks &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">record</span> <span class="title">FileChunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Index &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Offset &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> RemainingSize &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现的效果如下：</p><img   src="/Hexo-Blog/2025/03/25/resumable-upload-and-download/adaptive_resumable_upload_in_winform.png"  class="" title="客户端断点续传上传演示"><h3 id="完整性校验"><a href="#完整性校验" class="headerlink" title="完整性校验"></a>完整性校验</h3><p>完整性校验包含两个方面：</p><ul><li>分片完整性校验：校验单个分片的完整性，用于检测网络传输错误(一般使用MD5校验)</li><li>文件完整性校验：校验合并后最终文件的完整性，确保内容安全(建议使用SHA-256校验)</li></ul><p>在计算哈希值时应当仅读取文件内容，避免隐藏的元数据差异(文件创建&#x2F;修改日期等)造成哈希值不同。</p><h4 id="分片完整校验"><a href="#分片完整校验" class="headerlink" title="分片完整校验"></a>分片完整校验</h4><p>以下为服务端UploadChunkAsync接口对于分片完整校验的部分代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">AllowAnonymous</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> chunkHash = form[<span class="string">&quot;chunkHash&quot;</span>].ToString();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> chunkStream = System.IO.File.OpenRead(chunkPath);</span><br><span class="line">    <span class="keyword">var</span> revievedChunkHash = GetFileHash(chunkStream, HashAlgorithmType.Md5);</span><br><span class="line">    <span class="keyword">if</span> (!chunkHash.Equals(revievedChunkHash))</span><br><span class="line">    &#123;</span><br><span class="line">        chunkStream.Close();</span><br><span class="line">        System.IO.File.Delete(chunkPath);</span><br><span class="line">        <span class="keyword">var</span> errorMsg = <span class="string">$&quot;分片完整性校验失败，原始分片哈希为<span class="subst">&#123;chunkHash&#125;</span>, 接收到的分片哈希为<span class="subst">&#123;revievedChunkHash&#125;</span>, 分片 <span class="subst">&#123;chunkIndex&#125;</span> 已被删除，请重新上传！&quot;</span>;</span><br><span class="line">        _logger.LogError(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为客户端UploadChunkAsync方法对于分片完整性校验的部分代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkIndex, <span class="built_in">long</span> chunkOffset, <span class="built_in">int</span> chunkSize, <span class="built_in">long</span> fileSize,  <span class="built_in">string</span> fileName, Stream fileStream, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[chunkSize];</span><br><span class="line">    fileStream.Seek(chunkOffset, SeekOrigin.Begin);</span><br><span class="line">    <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, chunkSize, cancellationToken);</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream(chunkData);</span><br><span class="line">    <span class="keyword">var</span> chunkHash = GetFileHash(stream, HashAlgorithmType.Md5);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#123; <span class="keyword">new</span> StringContent(chunkHash.ToString()), <span class="string">&quot;chunkHash&quot;</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件完整性校验"><a href="#文件完整性校验" class="headerlink" title="文件完整性校验"></a>文件完整性校验</h4><p>以下为服务端MergeChunksAsync接口中对于文件完整性校验的部分代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">AllowAnonymous</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">MergeChunksAsync</span>(<span class="params">MergeFile mergeFile, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> stream = System.IO.File.OpenRead(finalPath);</span><br><span class="line">    <span class="keyword">var</span> mergeFileId = GetFileHash(stream, HashAlgorithmType.Sha256);</span><br><span class="line">    <span class="keyword">if</span> (!mergeFile.FileId.Equals(mergeFileId))</span><br><span class="line">    &#123;</span><br><span class="line">        stream.Close();</span><br><span class="line">        System.IO.File.Delete(finalPath);</span><br><span class="line">        <span class="keyword">var</span> errorMsg = <span class="string">$&quot;合并后的文件内容哈希不正确，文件可能已损坏，合并前内容哈希为<span class="subst">&#123;mergeFile.FileId&#125;</span>, 合并后内容哈希为<span class="subst">&#123;mergeFileId&#125;</span>, 合并后的文件已被删除，请重新上传！&quot;</span>;</span><br><span class="line">        _logger.LogError(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重传尝试"><a href="#重传尝试" class="headerlink" title="重传尝试"></a>重传尝试</h3><p>分片上传过程中存在各种不稳定的因素(如网络波动)，可以为客户端上传服务类添加重传尝试机制，在上传失败后自动重新上传。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdaptiveResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxRetryCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveResumableUploadService</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    ...,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> maxRetryCount = <span class="number">10</span></span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _maxRetryCount = maxRetryCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主上传方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadFileAdaptiveAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备上传任务</span></span><br><span class="line">            <span class="keyword">var</span> currentChunkSize = _initialChunkSize;</span><br><span class="line">            <span class="keyword">var</span> fileSize = fileInfo.Length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> progressLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> parallelOptions = <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cancellationToken</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> retryCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> completed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!completed &amp;&amp; retryCount &lt; _maxRetryCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">                <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line">                <span class="keyword">var</span> totalUploaded = uploadedChunks.Values.Sum();</span><br><span class="line">                <span class="built_in">long</span> totalToUpload = fileSize - totalUploaded;</span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;需要上传 <span class="subst">&#123;totalToUpload&#125;</span> 字节&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> Parallel.ForEachAsync(GenerateChunks(fileSize, currentChunkSize, uploadedChunks), parallelOptions, <span class="keyword">async</span> (chunk, cancellationToken) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">bool</span> success = <span class="keyword">await</span> UploadChunkAsync(fileId, chunk.Index, chunk.Offset, chunk.Size, fileSize, fileInfo.Name, fileStream, cancellationToken);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (success)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// 使用锁保证进度更新的原子性</span></span><br><span class="line">                            <span class="keyword">lock</span> (progressLock)</span><br><span class="line">                            &#123;</span><br><span class="line">                                totalUploaded += chunk.Size;</span><br><span class="line">                                <span class="built_in">int</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)totalUploaded / fileSize * <span class="number">100</span>);</span><br><span class="line">                                ProgressChanged?.Invoke(progress);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">await</span> MergeChunksAsync(fileId, fileInfo.Name, cancellationToken);</span><br><span class="line">                    completed = <span class="literal">true</span>;</span><br><span class="line">                    ProgressChanged?.Invoke(<span class="number">100</span>);</span><br><span class="line">                    StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">                    UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    retryCount++;</span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= _maxRetryCount) <span class="keyword">throw</span>;</span><br><span class="line">                    <span class="keyword">await</span> Task.Delay(<span class="number">100</span> * retryCount, cancellationToken);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分片定时清理"><a href="#分片定时清理" class="headerlink" title="分片定时清理"></a>分片定时清理</h3><p>断点续传留下的分片会随着时间在服务器上越积越多，因此需要有一个分片定时清理策略。</p><p>首先在服务端创建一个后台任务配置类，用于读取appsettings.json中的后台任务配置项，并在Program.cs中注册配置项，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BackgroundJobOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> StartHour &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> StartMinute &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> StartSecond &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> IntervalMinute &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CleanUpDaysAgo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册配置类</span></span><br><span class="line">builder.Services.Configure&lt;BackgroundJobOptions&gt;(builder.Configuration.GetSection(<span class="string">&quot;BackgroundJobOptions&quot;</span>));</span><br></pre></td></tr></table></figure><p>appsettings.json中的配置项如下所示。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;BackgroundJobOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;StartHour&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;StartMinute&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;StartSecond&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IntervalMinute&quot;</span><span class="punctuation">:</span> <span class="number">1440</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;CleanUpDaysAgo&quot;</span><span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后定义IWorkServie和WorkService，作为分片定时清理服务类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WorkService</span> : <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> executionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WorkService&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> DateTime nextDateTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWebHostEnvironment _env;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> BackgroundJobOptions _backgroundJobOptions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkService</span>(<span class="params">ILogger&lt;WorkService&gt; logger, IWebHostEnvironment env, IOptions&lt;BackgroundJobOptions&gt; backgroundJobOptions</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _env = env;</span><br><span class="line">        _backgroundJobOptions = backgroundJobOptions.Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算下一个时间节点</span></span><br><span class="line">            <span class="keyword">var</span> now = DateTime.Now;</span><br><span class="line">            <span class="keyword">var</span> firstDateTime = <span class="keyword">new</span> DateTime(now.Year, now.Month, now.Day, _backgroundJobOptions.StartHour, _backgroundJobOptions.StartMinute, _backgroundJobOptions.StartSecond);</span><br><span class="line">            <span class="keyword">if</span> (executionCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = firstDateTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = nextDateTime.AddMinutes(_backgroundJobOptions.IntervalMinute);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextDateTime &lt; now)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime.AddDays(<span class="number">1</span>) - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">                    CleanupOldUploads(_backgroundJobOptions.CleanUpDaysAgo);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> count = Interlocked.Increment(<span class="keyword">ref</span> executionCount);</span><br><span class="line">                _logger.LogInformation(<span class="string">&quot;已完成分片自动清理. 累计清理次数: &#123;Count&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CleanupOldUploads</span>(<span class="params"><span class="built_in">int</span> daysAgo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cutoff = DateTime.Now.AddDays(-daysAgo);</span><br><span class="line">        <span class="keyword">var</span> uploadPath = Path.Combine(_env.WebRootPath, <span class="string">&quot;uploads&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> dir <span class="keyword">in</span> Directory.GetDirectories(uploadPath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> dirName = dir.Split(<span class="string">&#x27;\\&#x27;</span>).Last();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;completed&quot;</span>.Equals(dirName) &amp;&amp; Directory.GetCreationTime(dir) &lt; cutoff)</span><br><span class="line">            &#123;</span><br><span class="line">                Directory.Delete(dir, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个后台服务类UploadCleanupService继承BackgroundService，并调用WorkService中的分片定时清理服务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadCleanupService</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _services;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadCleanupService</span>(<span class="params">IServiceProvider services</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _services = services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> scope = _services.CreateScope();</span><br><span class="line">        <span class="comment">//获取服务类</span></span><br><span class="line">        <span class="keyword">var</span> taskWorkService = scope.ServiceProvider.GetRequiredService&lt;IWorkService&gt;();</span><br><span class="line">        <span class="comment">//执行服务类的定时任务</span></span><br><span class="line">        <span class="keyword">await</span> taskWorkService.TaskWorkAsync(stoppingToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在Program.cs中注册后台服务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册后台服务</span></span><br><span class="line">builder.Services.AddHostedService&lt;UploadCleanupService&gt;();</span><br></pre></td></tr></table></figure><h2 id="断点续传下载"><a href="#断点续传下载" class="headerlink" title="断点续传下载"></a>断点续传下载</h2><p>与断点续传上传类似，断点续传下载同样包含下载进度反馈、下载取消、并行下载等辅助功能。</p><p>下面我们来简单实现上述功能。</p><h3 id="下载进度反馈与下载取消"><a href="#下载进度反馈与下载取消" class="headerlink" title="下载进度反馈与下载取消"></a>下载进度反馈与下载取消</h3><h4 id="服务端实现-5"><a href="#服务端实现-5" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>由于断点续传上传中使用了wwwroot静态资源文件夹，服务端的文件可直接通过url访问。确保Program.cs中启用了静态文件服务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用静态文件服务</span></span><br><span class="line">app.UseStaticFiles(); </span><br></pre></td></tr></table></figure><h4 id="客户端实现-5"><a href="#客户端实现-5" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ResumableDownloadService服务类，根据传入的服务器文件地址，使用Range头请求从断点处继续下载(确保服务器支持Range请求头)，并提供进度条反馈和取消下载功能。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResumableDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; ProgressChanged; <span class="comment">// 上传百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; StatusChanged; <span class="comment">// 状态消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">bool</span>&gt; DownloadCompleted; <span class="comment">// 完成状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResumableDownloadService</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DownloadWithResumeAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查目标文件是否已存在部分下载内容</span></span><br><span class="line">            <span class="built_in">long</span> existingLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir))</span><br><span class="line">            &#123;</span><br><span class="line">                Directory.CreateDirectory(destDir);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (File.Exists(destinationPath))</span><br><span class="line">            &#123;</span><br><span class="line">                existingLength = <span class="keyword">new</span> FileInfo(destinationPath).Length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 Range 头请求从断点处继续下载</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, fileUrl);</span><br><span class="line">            <span class="keyword">if</span> (existingLength &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                request.Headers.Range = <span class="keyword">new</span> RangeHeaderValue(existingLength, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);</span><br><span class="line">            <span class="keyword">if</span> (!response.IsSuccessStatusCode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.StatusCode == System.Net.HttpStatusCode.RequestedRangeNotSatisfiable)</span><br><span class="line">                &#123;</span><br><span class="line">                    StatusChanged?.Invoke(<span class="string">&quot;下载完成！&quot;</span>); <span class="comment">// Range头请求范围超出文件大小，视为下载完成</span></span><br><span class="line">                    ProgressChanged?.Invoke(<span class="number">100</span>);</span><br><span class="line">                    DownloadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileTotalLength = response.Content.Headers.ContentLength;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync(cancellationToken);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(destinationPath, existingLength &gt; <span class="number">0</span> ? FileMode.Append : FileMode.Create, FileAccess.Write, FileShare.None);</span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">8192</span>];</span><br><span class="line">            <span class="built_in">int</span> bytesRead;</span><br><span class="line">            <span class="built_in">long</span> totalRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = <span class="keyword">await</span> contentStream.ReadAsync(buffer, <span class="number">0</span>, buffer.Length, cancellationToken)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> fileStream.WriteAsync(buffer, <span class="number">0</span>, bytesRead, cancellationToken);</span><br><span class="line">                totalRead += bytesRead;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)totalRead / fileTotalLength * <span class="number">100</span>);</span><br><span class="line">                ProgressChanged?.Invoke(progress);</span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;当前上传进度: <span class="subst">&#123;progress&#125;</span>%&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;下载完成！&quot;</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;下载已取消&quot;</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上传类似，主窗体MainForm中的代码如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ResumableDownloadService _downloader;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _downloader = <span class="keyword">new</span> ResumableDownloadService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _downloader.ProgressChanged += UpdateProgress;</span><br><span class="line">        _downloader.StatusChanged += UpdateStatus;</span><br><span class="line">        _downloader.DownloadCompleted += UploadCompleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateProgress</span>(<span class="params"><span class="built_in">int</span> percent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (progressBar.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">int</span>&gt;(UpdateProgress), percent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        progressBar.Value = percent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateStatus</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lblStatus.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            lblStatus.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">string</span>&gt;(UpdateStatus), message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lblStatus.Text = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UploadCompleted</span>(<span class="params"><span class="built_in">bool</span> success</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (btnDownload.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            btnDownload.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">bool</span>&gt;(UploadCompleted), success);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        btnDownload.Enabled = <span class="literal">true</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">btnDownload_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(textBox.Text) || !Directory.Exists(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;请选择有效目录！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnDownload.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">true</span>;</span><br><span class="line">        progressBar.Value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        <span class="built_in">string</span> fileUrl = <span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span>/uploads/completed/test.mp4&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> destDir = textBox.Text;</span><br><span class="line">        <span class="keyword">await</span> _downloader.DownloadWithResumeAsync(fileUrl, destDir, _cts.Token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnBrowse_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> folderBrowserDialog = <span class="keyword">new</span> FolderBrowserDialog();</span><br><span class="line">        <span class="comment">// 设置对话框标题</span></span><br><span class="line">        folderBrowserDialog.Description = <span class="string">&quot;请选择保存文件的目录&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置初始目录（可选）</span></span><br><span class="line">        folderBrowserDialog.SelectedPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示对话框</span></span><br><span class="line">        <span class="keyword">if</span> (folderBrowserDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取用户选择的目录路径</span></span><br><span class="line">            textBox.Text = folderBrowserDialog.SelectedPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFormClosing</span>(<span class="params">FormClosingEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">        <span class="keyword">base</span>.OnFormClosing(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行下载与暂停恢复"><a href="#并行下载与暂停恢复" class="headerlink" title="并行下载与暂停恢复"></a>并行下载与暂停恢复</h3><h4 id="客户端实现-6"><a href="#客户端实现-6" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ParallelDownloadService服务类，默认并发下载线程数为4，并使用并发字典记录CancellationTokenSource，以便实现下载的暂停和恢复。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt; _activeDownloads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> BufferSize = <span class="number">8192</span>; <span class="comment">// 缓冲区 8KB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">long</span>, <span class="built_in">long</span>&gt; ProgressChanged; <span class="comment">// 当前下载量, 总大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; DownloadCompleted;     <span class="comment">// 下载ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>, Exception&gt; DownloadFailed; <span class="comment">// 下载ID, 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParallelDownloadService</span>(<span class="params"><span class="built_in">int</span> maxParallelism = <span class="number">4</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        _httpClient.Timeout = Timeout.InfiniteTimeSpan;</span><br><span class="line">        _activeDownloads = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt;();</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">StartParallelDownloadAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> downloadId = fileUrl.GetHashCode();</span><br><span class="line">        <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        _activeDownloads.TryAdd(downloadId, cts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取文件总大小</span></span><br><span class="line">            <span class="keyword">var</span> fileSize = <span class="keyword">await</span> GetFileSizeAsync(fileUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempDir = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\temp&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempPath = <span class="string">$&quot;<span class="subst">&#123;tempDir&#125;</span>\\<span class="subst">&#123;Path.GetFileNameWithoutExtension(destFile)&#125;</span>.tmp&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir)) Directory.CreateDirectory(destDir);</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(tempDir)) Directory.CreateDirectory(tempDir);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(tempPath, FileMode.Create, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                fs.SetLength(fileSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分片</span></span><br><span class="line">            <span class="keyword">var</span> chunks = CalculateChunks(fileSize, _maxParallelism);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并行下载</span></span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; Parallel.ForEachAsync(chunks, <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cts.Token</span><br><span class="line">            &#125;, <span class="keyword">async</span> (chunk, ct) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _semaphoreSlim.WaitAsync();</span><br><span class="line">                <span class="keyword">await</span> DownloadChunkAsync(downloadId, fileUrl, tempPath, chunk.Start, chunk.End, fileSize, ct);</span><br><span class="line">                _semaphoreSlim.Release();</span><br><span class="line">            &#125;), cts.Token);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下载完成后重命名临时文件</span></span><br><span class="line">            File.Move(tempPath, destinationPath, <span class="literal">true</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(downloadId);</span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            DownloadFailed?.Invoke(downloadId, ex);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _activeDownloads.TryRemove(downloadId, <span class="keyword">out</span> _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PauseDownload</span>(<span class="params"><span class="built_in">int</span> downloadId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_activeDownloads.TryGetValue(downloadId, <span class="keyword">out</span> <span class="keyword">var</span> cts))</span><br><span class="line">        &#123;</span><br><span class="line">            cts.Cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadChunkAsync</span>(<span class="params"><span class="built_in">int</span> downloadId, <span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destinationPath, <span class="built_in">long</span> start, <span class="built_in">long</span> end, <span class="built_in">long</span> fileSize, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 Range 头请求从断点处继续下载</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, fileUrl);</span><br><span class="line">            request.Headers.Range = <span class="keyword">new</span> RangeHeaderValue(start, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);</span><br><span class="line"></span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(destinationPath, FileMode.Open, FileAccess.Write);</span><br><span class="line"></span><br><span class="line">            fileStream.Seek(start, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用固定大小缓冲区，避免内存问题</span></span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[BufferSize];</span><br><span class="line">            <span class="built_in">int</span> bytesRead;</span><br><span class="line">            <span class="built_in">long</span> totalRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = <span class="keyword">await</span> contentStream.ReadAsync(buffer, <span class="number">0</span>, buffer.Length, cancellationToken)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> fileStream.WriteAsync(buffer, <span class="number">0</span>, bytesRead, cancellationToken);</span><br><span class="line">                totalRead += bytesRead;</span><br><span class="line">                ProgressChanged?.Invoke(start + totalRead, fileSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;分片下载失败(<span class="subst">&#123;start&#125;</span>-<span class="subst">&#123;end&#125;</span>): <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;(<span class="built_in">long</span> Start, <span class="built_in">long</span> End)&gt; CalculateChunks(<span class="built_in">long</span> fileSize, <span class="built_in">int</span> threadCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> chunkSize = Math.Max(ChunkSize, fileSize / threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">long</span> i = <span class="number">0</span>; i &lt; fileSize; i += chunkSize + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> end = Math.Min(i + chunkSize, fileSize - <span class="number">1</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="title">return</span> (<span class="params">i, end</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">GetFileSizeAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Head, fileUrl);</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request);</span><br><span class="line"></span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">        <span class="keyword">return</span> response.Content.Headers.ContentLength ??</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;无法获取文件大小&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主窗体MainForm中的代码如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ParallelDownloadService _downloader;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _currentDownloadId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _downloader = <span class="keyword">new</span> ParallelDownloadService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _downloader.ProgressChanged += OnDownloadProgress;</span><br><span class="line">        _downloader.DownloadCompleted += OnDownloadComplete;</span><br><span class="line">        _downloader.DownloadFailed += OnDownloadFailed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按钮置灰</span></span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnStart_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(textBox.Text) || !Directory.Exists(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;请选择有效目录！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnStart.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnPause.Enabled = <span class="literal">true</span>;</span><br><span class="line">        progressBar.Value = <span class="number">0</span>;</span><br><span class="line">        lblStatus.Text = <span class="string">&quot;下载中...&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> fileUrl = <span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span>/uploads/completed/test.mp4&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> destDir = textBox.Text;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始下载</span></span><br><span class="line">        _ = Task.Run(<span class="keyword">async</span> () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">                _currentDownloadId = <span class="keyword">await</span> _downloader.StartParallelDownloadAsync(fileUrl, destDir);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnPause_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _downloader.PauseDownload(_currentDownloadId);</span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">true</span>;</span><br><span class="line">        lblStatus.Text = <span class="string">&quot;已暂停&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnResume_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 重新开始下载</span></span><br><span class="line">        btnStart_Click(sender, e);</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnBrowse_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> folderBrowserDialog = <span class="keyword">new</span> FolderBrowserDialog();</span><br><span class="line">        <span class="comment">// 设置对话框标题</span></span><br><span class="line">        folderBrowserDialog.Description = <span class="string">&quot;请选择保存文件的目录&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置初始目录（可选）</span></span><br><span class="line">        folderBrowserDialog.SelectedPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示对话框</span></span><br><span class="line">        <span class="keyword">if</span> (folderBrowserDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取用户选择的目录路径</span></span><br><span class="line">            textBox.Text = folderBrowserDialog.SelectedPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDownloadProgress</span>(<span class="params"><span class="built_in">long</span> bytes, <span class="built_in">long</span> fileSize</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Maximum = (<span class="built_in">int</span>)(fileSize / <span class="number">1024</span>);</span><br><span class="line">            progressBar.Value = (<span class="built_in">int</span>)(bytes / <span class="number">1024</span>);</span><br><span class="line">            lblProgress.Text = <span class="string">$&quot;<span class="subst">&#123;bytes / <span class="number">1024</span> / <span class="number">1024</span>&#125;</span>MB / <span class="subst">&#123;fileSize / <span class="number">1024</span> / <span class="number">1024</span>&#125;</span>MB&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDownloadComplete</span>(<span class="params"><span class="built_in">int</span> downloadId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            lblStatus.Text = <span class="string">&quot;下载完成&quot;</span>;</span><br><span class="line">            ResetUI();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDownloadFailed</span>(<span class="params"><span class="built_in">int</span> downloadId, Exception ex</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">$&quot;下载失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            lblStatus.Text = <span class="string">&quot;下载失败&quot;</span>;</span><br><span class="line">            ResetUI();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        btnStart.Enabled = <span class="literal">true</span>;</span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下载重试"><a href="#下载重试" class="headerlink" title="下载重试"></a>下载重试</h3><p>与上传类似，断点续传下载也可以添加重试机制。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxRetryCount;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParallelDownloadService</span>(<span class="params">..., <span class="built_in">int</span> maxRetryCount = <span class="number">10</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _maxRetryCount = maxRetryCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">StartParallelDownloadAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> downloadId = fileUrl.GetHashCode();</span><br><span class="line">        <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        _activeDownloads.TryAdd(downloadId, cts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取文件总大小</span></span><br><span class="line">            <span class="keyword">var</span> fileSize = <span class="keyword">await</span> GetFileSizeAsync(fileUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempDir = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\temp&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempPath = <span class="string">$&quot;<span class="subst">&#123;tempDir&#125;</span>\\<span class="subst">&#123;Path.GetFileNameWithoutExtension(destFile)&#125;</span>.tmp&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir)) Directory.CreateDirectory(destDir);</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(tempDir)) Directory.CreateDirectory(tempDir);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(tempPath, FileMode.Create, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                fs.SetLength(fileSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分片</span></span><br><span class="line">            <span class="keyword">var</span> chunks = CalculateChunks(fileSize, _maxParallelism);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并行下载</span></span><br><span class="line">            <span class="keyword">var</span> retryCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> completed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!completed &amp;&amp; retryCount &lt; _maxRetryCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> Task.Run(() =&gt; Parallel.ForEachAsync(chunks, <span class="keyword">new</span> ParallelOptions</span><br><span class="line">                    &#123;</span><br><span class="line">                        MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                        CancellationToken = cts.Token</span><br><span class="line">                    &#125;, <span class="keyword">async</span> (chunk, ct) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">await</span> _semaphoreSlim.WaitAsync();</span><br><span class="line">                        <span class="keyword">await</span> DownloadChunkAsync(downloadId, fileUrl, tempPath, chunk.Start, chunk.End, fileSize, ct);</span><br><span class="line">                        _semaphoreSlim.Release();</span><br><span class="line">                    &#125;), cts.Token);</span><br><span class="line"></span><br><span class="line">                    completed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    retryCount++;</span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= _maxRetryCount) <span class="keyword">throw</span>;</span><br><span class="line">                    <span class="keyword">await</span> Task.Delay(<span class="number">100</span> * retryCount); <span class="comment">// 指数退避</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下载完成后重命名临时文件</span></span><br><span class="line">            File.Move(tempPath, destinationPath, <span class="literal">true</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(downloadId);</span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            DownloadFailed?.Invoke(downloadId, ex);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _activeDownloads.TryRemove(downloadId, <span class="keyword">out</span> _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限速下载"><a href="#限速下载" class="headerlink" title="限速下载"></a>限速下载</h3><p>断点续传下载同样可以添加下载速度限制功能。下面创建一个SpeedLimitResumableDownloadService服务类，在并行下载基础上，添加限速下载功能。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpeedLimitResumableDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt; _activeDownloads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> BufferSize = <span class="number">8192</span>; <span class="comment">// 缓冲区 8KB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxRetryCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _maxSpeedKBps; <span class="comment">// 0表示不限速</span></span><br><span class="line">    <span class="keyword">private</span> Stopwatch _stopWatch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">long</span>, <span class="built_in">long</span>&gt; ProgressChanged; <span class="comment">// 当前下载量, 总大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; DownloadCompleted;     <span class="comment">// 下载ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>, Exception&gt; DownloadFailed; <span class="comment">// 下载ID, 异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">double</span>&gt; SpeedChanged;      <span class="comment">// 下载速度(KB/s)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpeedLimitResumableDownloadService</span>(<span class="params"><span class="built_in">int</span> maxParallelism = <span class="number">4</span>, <span class="built_in">int</span> maxRetryCount = <span class="number">10</span>, <span class="built_in">int</span> maxSpeedKBps = <span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        _stopWatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        _httpClient.Timeout = Timeout.InfiniteTimeSpan;</span><br><span class="line">        _activeDownloads = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt;();</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">        _maxRetryCount = maxRetryCount;</span><br><span class="line">        _maxSpeedKBps = maxSpeedKBps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">StartParallelDownloadAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> downloadId = fileUrl.GetHashCode();</span><br><span class="line">        <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        _activeDownloads.TryAdd(downloadId, cts);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取文件总大小</span></span><br><span class="line">            <span class="keyword">var</span> fileSize = <span class="keyword">await</span> GetFileSizeAsync(fileUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempDir = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\temp&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempPath = <span class="string">$&quot;<span class="subst">&#123;tempDir&#125;</span>\\<span class="subst">&#123;Path.GetFileNameWithoutExtension(destFile)&#125;</span>.tmp&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir)) Directory.CreateDirectory(destDir);</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(tempDir)) Directory.CreateDirectory(tempDir);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(tempPath, FileMode.Create, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                fs.SetLength(fileSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分片</span></span><br><span class="line">            <span class="keyword">var</span> chunks = CalculateChunks(fileSize, _maxParallelism);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并行下载</span></span><br><span class="line">            <span class="keyword">var</span> retryCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> completed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!completed &amp;&amp; retryCount &lt; _maxRetryCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> Task.Run(() =&gt; Parallel.ForEachAsync(chunks, <span class="keyword">new</span> ParallelOptions</span><br><span class="line">                    &#123;</span><br><span class="line">                        MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                        CancellationToken = cts.Token</span><br><span class="line">                    &#125;, <span class="keyword">async</span> (chunk, ct) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">await</span> _semaphoreSlim.WaitAsync();</span><br><span class="line">                        <span class="keyword">await</span> DownloadChunkAsync(downloadId, fileUrl, tempPath, chunk.Start, chunk.End, fileSize, ct);</span><br><span class="line">                        _semaphoreSlim.Release();</span><br><span class="line">                    &#125;), cts.Token);</span><br><span class="line"></span><br><span class="line">                    completed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    retryCount++;</span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= _maxRetryCount) <span class="keyword">throw</span>;</span><br><span class="line">                    <span class="keyword">await</span> Task.Delay(<span class="number">100</span> * retryCount); <span class="comment">// 指数退避</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下载完成后重命名临时文件</span></span><br><span class="line">            File.Move(tempPath, destinationPath, <span class="literal">true</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(downloadId);</span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            DownloadFailed?.Invoke(downloadId, ex);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _activeDownloads.TryRemove(downloadId, <span class="keyword">out</span> _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PauseDownload</span>(<span class="params"><span class="built_in">int</span> downloadId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_activeDownloads.TryGetValue(downloadId, <span class="keyword">out</span> <span class="keyword">var</span> cts))</span><br><span class="line">        &#123;</span><br><span class="line">            cts.Cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadChunkAsync</span>(<span class="params"><span class="built_in">int</span> downloadId, <span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destinationPath, <span class="built_in">long</span> start, <span class="built_in">long</span> end, <span class="built_in">long</span> fileSize, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 Range 头请求从断点处继续下载</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, fileUrl);</span><br><span class="line">            request.Headers.Range = <span class="keyword">new</span> RangeHeaderValue(start, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);</span><br><span class="line"></span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(destinationPath, FileMode.Open, FileAccess.Write);</span><br><span class="line"></span><br><span class="line">            fileStream.Seek(start, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用固定大小缓冲区，避免内存问题</span></span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[BufferSize];</span><br><span class="line">            <span class="built_in">int</span> bytesRead;</span><br><span class="line">            <span class="built_in">long</span> totalRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = <span class="keyword">await</span> ReadWithSpeedLimit(contentStream, buffer, cancellationToken)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> fileStream.WriteAsync(buffer, <span class="number">0</span>, bytesRead, cancellationToken);</span><br><span class="line">                <span class="comment">// 更新下载进度</span></span><br><span class="line">                totalRead += bytesRead;</span><br><span class="line">                ProgressChanged?.Invoke(start + totalRead, fileSize);</span><br><span class="line">                <span class="comment">// 更新下载速度</span></span><br><span class="line">                <span class="keyword">var</span> speed = bytesRead / <span class="number">1024.0</span> / _stopWatch.Elapsed.TotalSeconds;</span><br><span class="line">                SpeedChanged?.Invoke(speed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;分片下载失败(<span class="subst">&#123;start&#125;</span>-<span class="subst">&#123;end&#125;</span>): <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _stopWatch.Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">ReadWithSpeedLimit</span>(<span class="params">Stream stream, <span class="built_in">byte</span>[] buffer, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _stopWatch.Restart();</span><br><span class="line">        <span class="keyword">var</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (_maxSpeedKBps &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不限速</span></span><br><span class="line">            bytesRead = <span class="keyword">await</span> stream.ReadAsync(buffer, <span class="number">0</span>, buffer.Length, cancellationToken);</span><br><span class="line">            <span class="keyword">return</span> bytesRead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次读取的最大字节数</span></span><br><span class="line">        <span class="keyword">var</span> maxBytes = (<span class="built_in">int</span>)(_maxSpeedKBps * <span class="number">1024</span> * <span class="number">0.1</span>); <span class="comment">// 每100ms的限额</span></span><br><span class="line">        <span class="keyword">var</span> readSize = Math.Min(buffer.Length, maxBytes);</span><br><span class="line"></span><br><span class="line">        bytesRead = <span class="keyword">await</span> stream.ReadAsync(buffer, <span class="number">0</span>, readSize, cancellationToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 速度控制</span></span><br><span class="line">        <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span> &amp;&amp; _maxSpeedKBps &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> expectedTime = (bytesRead / <span class="number">1024.0</span>) / _maxSpeedKBps * <span class="number">1000</span>; <span class="comment">// 毫秒</span></span><br><span class="line">            <span class="keyword">var</span> actualTime = _stopWatch.ElapsedMilliseconds;</span><br><span class="line">            <span class="keyword">var</span> delayTime = (<span class="built_in">int</span>)(expectedTime - actualTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (delayTime &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delayTime, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytesRead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;(<span class="built_in">long</span> Start, <span class="built_in">long</span> End)&gt; CalculateChunks(<span class="built_in">long</span> fileSize, <span class="built_in">int</span> threadCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同并行下载</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">GetFileSizeAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同并行下载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主窗体MainForm中的部分代码如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SpeedLimitResumableDownloadService _downloader;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _currentDownloadId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _downloader = <span class="keyword">new</span> SpeedLimitResumableDownloadService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _downloader.ProgressChanged += OnDownloadProgress;</span><br><span class="line">        _downloader.DownloadCompleted += OnDownloadComplete;</span><br><span class="line">        _downloader.DownloadFailed += OnDownloadFailed;</span><br><span class="line">        _downloader.SpeedChanged += OnSpeedChanged;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按钮置灰</span></span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSpeedChanged</span>(<span class="params"><span class="built_in">double</span> speedKBps</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke((Delegate)(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            lblSpeed.Text = <span class="string">$&quot;<span class="subst">&#123;speedKBps / <span class="number">1024</span>:<span class="number">0.00</span>&#125;</span> MB/s&quot;</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现的效果如下：</p><img   src="/Hexo-Blog/2025/03/25/resumable-upload-and-download/resumable_download_in_winform.png"  class="" title="客户端断点续传下载演示"><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://help.aliyun.com/zh/oss/user-guide/resumable-upload" >阿里云OSS断点续传上传操作指南<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://help.aliyun.com/zh/oss/user-guide/oss-resumable-download" >阿里云OSS断点续传下载操作指南<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.control.invokerequired" >Control.InvokeRequired属性参考文档<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于.NET实现大文件的断点续传功能，包含上传与下载。其中上传部分包括分片上传与断点续传功能，并借助WinForm实现上传进度反馈、并行上传、分片大小动态调整等辅助功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Framework" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Framework/"/>
    
    
    <category term=".NET" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET/"/>
    
    <category term="ASP.NET Core" scheme="https://jocoboy.github.io/Hexo-Blog/tags/ASP-NET-Core/"/>
    
    <category term="WinForm" scheme="https://jocoboy.github.io/Hexo-Blog/tags/WinForm/"/>
    
  </entry>
  
  <entry>
    <title>C#进阶语法</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2025/03/20/csharp-advanced-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2025/03/20/csharp-advanced-usage/</id>
    <published>2025-03-20T06:57:10.000Z</published>
    <updated>2025-08-01T09:27:22.784Z</updated>
    
    <content type="html"><![CDATA[<p>c#进阶语法，包含委托与事件、动态类型与泛型、并发访问控制等。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>c#中的一些进阶语法使用记录，包含委托(Delegate)与事件(Event)、动态类型(Dynamic Types)与泛型(Generics)、并发访问控制(信号量、并发字典)等。 </p><h2 id="委托与事件"><a href="#委托与事件" class="headerlink" title="委托与事件"></a>委托与事件</h2><h3 id="委托-Delegate"><a href="#委托-Delegate" class="headerlink" title="委托(Delegate)"></a>委托(Delegate)</h3><p>在C#中，委托(Delegate)是一种类型安全的函数指针，用于封装一个或多个方法。委托允许你将方法作为参数传递、存储方法引用，并支持事件和回调机制。委托是C#中实现事件驱动编程和多播委托的基础。</p><p>下面是一个委托定义、实例化和调用的示例:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MathOperation</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义符合委托签名的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a - b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化委托</span></span><br><span class="line">        MathOperation operation = Add;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用委托</span></span><br><span class="line">        <span class="built_in">int</span> result = operation(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Addition Result: <span class="subst">&#123;result&#125;</span>&quot;</span>); <span class="comment">// 输出: Addition Result: 15</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新指向另一个方法</span></span><br><span class="line">        operation = Subtract;</span><br><span class="line">        result = operation(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Subtraction Result: <span class="subst">&#123;result&#125;</span>&quot;</span>); <span class="comment">// 输出: Subtraction Result: 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#支持匿名方法和Lambda表达式，简化了委托的使用，上面的委托实例化可以简写为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MathOperation operation = <span class="built_in">delegate</span>(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// 匿名方法</span></span><br><span class="line">MathOperation operation = (a, b) =&gt; a + b; <span class="comment">// Lambda表达式</span></span><br></pre></td></tr></table></figure><p>委托可以指向多个方法，称为多播委托。通过+&#x3D;和-&#x3D;运算符，可以添加或移除方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义符合委托签名的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;Message: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWarning</span>(<span class="params"><span class="built_in">string</span> message</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;Warning: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化多播委托</span></span><br><span class="line">        DisplayMessage display = ShowMessage;</span><br><span class="line">        display += ShowWarning; <span class="comment">// 添加第二个方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用多播委托（会依次调用所有方法）</span></span><br><span class="line">        display(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#提供了几种内置的泛型委托类型，避免了手动定义委托。</p><ul><li><p>Action: 表示没有返回值的方法，最多支持16个参数。示例：</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; print = message =&gt; Console.WriteLine(message);</span><br><span class="line">print(<span class="string">&quot;Hello, Action!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>Func: 表示有返回值的方法，最后一个泛型参数是返回值类型。示例：</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt; a + b;</span><br><span class="line"><span class="built_in">int</span> result = <span class="keyword">add</span>(<span class="number">10</span>, <span class="number">5</span>); </span><br></pre></td></tr></table></figure></li><li><p>Predicate: 表示返回布尔值的方法，通常用于条件判断。</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;<span class="built_in">int</span>&gt; isEven = num =&gt; num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> result = isEven(<span class="number">10</span>); </span><br></pre></td></tr></table></figure></li></ul><p>委托的应用场景有很多，例如事件处理、回调机制(将方法作为参数传递给其他方法，用于异步编程或延迟执行)、LINQ查询等。</p><h3 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件(Event)"></a>事件(Event)</h3><p>委托是C#事件的基础。在C#中，事件(Event)是一种特殊的委托，用于实现发布-订阅模式(观察者模式)。事件允许一个类(发布者)通知其他类(订阅者)某些事情发生了。事件的核心是委托，它定义了事件处理方法的签名。</p><p>下面是一个事件的定义、触发、订阅和取消的示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler OnMessageReceived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Publisher: Sending message - <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        OnMessageReceived?.Invoke(message); <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Subscriber: Received message - <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建发布者和订阅者</span></span><br><span class="line">        Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.OnMessageReceived += subscriber.HandleMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布者发送消息，触发事件</span></span><br><span class="line">        publisher.SendMessage(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅事件</span></span><br><span class="line">        publisher.OnMessageReceived -= subscriber.HandleMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次发送消息，不会触发事件</span></span><br><span class="line">        publisher.SendMessage(<span class="string">&quot;This message will not be received.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#提供了标准的EventHandler委托和EventArgs类，推荐使用它们来定义事件，下面是一个使用示例(调用方式同上)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;CustomEventArgs&gt; OnMessageReceived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Publisher: Sending message - <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        OnMessageReceived?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> CustomEventArgs &#123; Message = message &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleMessage</span>(<span class="params"><span class="built_in">object</span> sender, CustomEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Subscriber: Received message - <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件的使用场景有很多，例如用户界面事件、异步编程事件(如文件下载完成事件)、自定义通知机制(如状态更新)等。</p><h2 id="动态类型与泛型"><a href="#动态类型与泛型" class="headerlink" title="动态类型与泛型"></a>动态类型与泛型</h2><h3 id="动态类型-Dynamic-Types"><a href="#动态类型-Dynamic-Types" class="headerlink" title="动态类型(Dynamic Types)"></a>动态类型(Dynamic Types)</h3><p>dynamic是c#中的一个动态类型，属性的访问是在运行时解析的，因此需要确保运行时对象具有你访问的属性。</p><p>可以通过下面的方式创建一个dynamic对象：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> item = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Alice&quot;</span>, Age = <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure><p>要对<code>List&lt;dynamic&gt;</code>使用Where语句，可通过反射检查属性是否存在，确保dynamic对象具有需要访问的属性：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">dynamic</span>&gt; dynamicList = <span class="keyword">new</span> List&lt;<span class="built_in">dynamic</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Alice&quot;</span>, Age = <span class="number">25</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Bob&quot;</span>, Age = <span class="number">30</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Charlie&quot;</span>, Age = <span class="number">20</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dynamicList = dynamicList.Where(item =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> property = item.GetType().GetProperty(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> property != <span class="literal">null</span> &amp;&amp; (<span class="built_in">string</span>)property.GetValue(item) != <span class="string">&quot;Charlie&quot;</span>;</span><br><span class="line">&#125;).ToList();</span><br></pre></td></tr></table></figure><p>dynamic是提供用于在运行时指定动态行为的基类。必须继承此类；不能直接对其进行实例化。通常用到的是它的继承类ExpandoObject。</p><p><code>System.Dynamic.ExpandoObject</code>是一个动态对象，允许在运行时添加或删除属性。它可以像字典一样操作(实现了 <code>IDictionary&lt;string, object&gt;</code>)，也可以像普通对象一样访问属性。</p><p>可以通过下面的方式创建一个ExpandoObject对象：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> item = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item.Name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">item.Age = <span class="number">25</span>;</span><br><span class="line">Console.WriteLine(((IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)item)[<span class="string">&quot;Name&quot;</span>]);</span><br></pre></td></tr></table></figure><p>要对<code>List&lt;ExpandoObject&gt;</code>使用Where语句，通常需要将其视为<code>IDictionary&lt;string, object&gt;</code>，然后根据键值对进行过滤。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ExpandoObject&gt; expandoList = <span class="keyword">new</span> List&lt;ExpandoObject&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> item1 = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item1.Name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">item1.Age = <span class="number">25</span>;</span><br><span class="line">expandoList.Add(item1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> item2 = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item2.Name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">item2.Age = <span class="number">30</span>;</span><br><span class="line">expandoList.Add(item2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> item3 = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item3.Name = <span class="string">&quot;Charlie&quot;</span>;</span><br><span class="line">item3.Age = <span class="number">20</span>;</span><br><span class="line">expandoList.Add(item3);</span><br><span class="line"></span><br><span class="line">expandoList = expandoList.Where(item =&gt;</span><br><span class="line">                            ((IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)item).ContainsKey(<span class="string">&quot;Name&quot;</span>) &amp;&amp;</span><br><span class="line">                            (<span class="built_in">string</span>)((IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)item)[<span class="string">&quot;Name&quot;</span>] != <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">                        ).ToList();</span><br></pre></td></tr></table></figure><h3 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(Generics)</h3><p>在C#中，泛型允许你编写可以处理多种类型的代码，而无需为每种类型重复编写逻辑。泛型在编译时确定类型，并提供类型安全和性能优势。</p><p>泛型(Generics)和动态类型(Dynamic Types)是两种不同的特性，用于处理类型不确定的场景。它们的主要区别在于类型检查的时机、安全性、性能和使用场景等。以下是他们的主要区别：</p><table><thead><tr><th>区别</th><th>泛型(Generics)</th><th>动态类型(Dynamic Types)</th></tr></thead><tbody><tr><td>类型检查时机</td><td>编译时</td><td>运行时</td></tr><tr><td>类型安全</td><td>是</td><td>否</td></tr><tr><td>性能</td><td>高性能(避免装箱和拆箱)</td><td>较低(运行时解析类型)</td></tr><tr><td>灵活性</td><td>较低(类型在编译时确定)</td><td>高(类型在运行时确定)</td></tr><tr><td>适用场景</td><td>类型安全的通用代码、集合类、高性能场景</td><td>动态语言交互、未知类型处理、灵活性需求</td></tr></tbody></table><h2 id="并发访问控制"><a href="#并发访问控制" class="headerlink" title="并发访问控制"></a>并发访问控制</h2><h3 id="信号量Semaphore与SemaphoreSlim"><a href="#信号量Semaphore与SemaphoreSlim" class="headerlink" title="信号量Semaphore与SemaphoreSlim"></a>信号量Semaphore与SemaphoreSlim</h3><p>Semaphore和SemaphoreSlim是.NET中用于控制并发访问的同步原语，他们的主要区别如下：</p><table><thead><tr><th>区别</th><th>Semaphore</th><th>SemaphoreSlim</th></tr></thead><tbody><tr><td>跨进程支持</td><td>支持跨进程同步，可以用于不同进程之间的线程同步</td><td>仅支持单进程内的线程同步</td></tr><tr><td>性能</td><td>性能相对较低，因为它依赖于操作系统内核对象</td><td>性能更高，因为它完全基于.NET运行时</td></tr><tr><td>异步支持</td><td>不支持异步操作</td><td>支持异步操作</td></tr><tr><td>适用场景</td><td>适用于需要跨进程同步的场景</td><td>适用于单进程内需要高性能同步的场景</td></tr></tbody></table><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore用于限制可同时访问某一资源或资源池的线程数。下面是一个简单的使用示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个信号量，初始计数为0，最大计数为3</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">semaphore.WaitOne();</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">semaphore.Release();</span><br></pre></td></tr></table></figure><ul><li>Semaphore第一个参数是初始计数initialCount，代表未执行Release方法之前允许通过的信号量</li><li>Semaphore第二个参数是最大计数maximumCount，代表执行Release方法之后允许通过的最大信号量</li><li>释放之前的数量加上释放数量releaseCount应当不超过最大计数，即Release(releaseCount) + releaseCount &lt;&#x3D; maximumCount，其中Release(releaseCount)初始值为initialCount</li></ul><p>以下示例展示了信号量Semaphore是如何控制并发访问的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore _semaphore;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _padding;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>(<span class="params"><span class="built_in">object</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 开始并等待进入信号量.&quot;</span>, num);</span><br><span class="line">        _semaphore.WaitOne();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> padding = Interlocked.Add(<span class="keyword">ref</span> _padding, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 进入信号量.&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">1000</span> + padding);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 从信号量中释放.&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 释放之前信号量中的可用资源数: &#123;1&#125;&quot;</span>,</span><br><span class="line">            num, _semaphore.Release());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _semaphore = <span class="keyword">new</span> Semaphore(initialCount: <span class="number">1</span>, maximumCount: <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(Worker));</span><br><span class="line"></span><br><span class="line">            t.Start(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> releaseCount = <span class="number">4</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;主线程尝试释放<span class="subst">&#123;releaseCount&#125;</span>个资源&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            _semaphore.Release(releaseCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主线程退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出内容如下：</p><blockquote><p>线程 2 开始并等待进入信号量.<br>线程 5 开始并等待进入信号量.<br>线程 3 开始并等待进入信号量.<br>线程 1 开始并等待进入信号量.<br>线程 4 开始并等待进入信号量.<br>线程 2 进入信号量.<br>主线程尝试释放4个资源<br>主线程退出<br>线程 3 进入信号量.<br>线程 5 进入信号量.<br>线程 4 进入信号量.<br>线程 1 进入信号量.<br>线程 2 从信号量中释放.<br>线程 2 释放之前信号量中的可用资源数: 0<br>线程 5 从信号量中释放.<br>线程 5 释放之前信号量中的可用资源数: 1<br>线程 1 从信号量中释放.<br>线程 1 释放之前信号量中的可用资源数: 2<br>线程 3 从信号量中释放.<br>线程 3 释放之前信号量中的可用资源数: 3<br>线程 4 从信号量中释放.<br>警告: 释放数量超过信号量最大计数！</p></blockquote><h4 id="SemaphoreSlim"><a href="#SemaphoreSlim" class="headerlink" title="SemaphoreSlim"></a>SemaphoreSlim</h4><p>SemaphoreSlim是对可同时访问资源或资源池的线程数加以限制的Semaphore的轻量替代。下面是一个简单的使用示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个信号量，初始计数为0，最大计数为3</span></span><br><span class="line">SemaphoreSlim semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">await</span> semaphoreSlim.WaitAsync();</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">semaphoreSlim.Release();</span><br></pre></td></tr></table></figure><p>以下示例展示了信号量SemaphoreSlim是如何控制并发访问的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SemaphoreSlim _semaphoreSlim;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _padding;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 开始并等待进入信号量.&quot;</span>, Task.CurrentId);</span><br><span class="line">        _semaphoreSlim.Wait();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> semaphoreCount;</span><br><span class="line"></span><br><span class="line">        Interlocked.Add(<span class="keyword">ref</span> _padding, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 进入信号量.&quot;</span>, Task.CurrentId);</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">1000</span> + _padding);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 从信号量中释放.&quot;</span>, Task.CurrentId);</span><br><span class="line">            semaphoreCount = _semaphoreSlim.Release();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 释放之前信号量中的可用资源数: &#123;1&#125;&quot;</span>, Task.CurrentId, semaphoreCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        Task[] tasks = <span class="keyword">new</span> Task[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tasks[i] = Task.Run(Worker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> releaseCount = <span class="number">4</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;主线程尝试释放<span class="subst">&#123;releaseCount&#125;</span>个资源&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            _semaphoreSlim.Release(releaseCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Task.WaitAll(tasks);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主线程退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出内容与Semaphore类似，此处不再展示。</p><p>SemaphoreSlim还可用于异步锁，避免线程阻塞，下面是一个简单示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoWork</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _semaphoreSlim.WaitAsync(); <span class="comment">// 等待锁</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        _semaphoreSlim.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发字典ConcurrentDictionary"><a href="#并发字典ConcurrentDictionary" class="headerlink" title="并发字典ConcurrentDictionary"></a>并发字典ConcurrentDictionary</h3><p>在C#中，线程安全集合是一种特殊的数据结构，能够在多线程环境下安全地访问和修改集合元素。线程安全集合通常是通过加锁或者使用其他同步机制来实现线程安全。C#中提供了多种线程安全集合，包括ConcurrentDictionary、ConcurrentQueue、ConcurrentStack、ConcurrentBag等。</p><p>ConcurrentDictionary是C#中用于处理多线程并发访问的线程安全字典。它的设计目标是高效地支持多个线程同时读写数据，而无需显式加锁。它的核心特性使其在高并发场景下表现出色，以下是它的主要特性：</p><ul><li>线程安全：允许多个线程同时读取和写入数据，而不会导致数据损坏或抛出异常。它通过内部锁和无锁技术(如CAS操作)来实现高效的并发访问</li><li>原子操作：提供了一系列原子操作方法(TryAdd、TryUpdate、TryRemove、AddOrUpdate、GetOrAdd等)，确保在多线程环境下的操作是线程安全的，避免了手动加锁的复杂性</li><li>高性能：针对高并发场景进行了优化，使用了分区锁(lock striping)技术，将字典分成多个段(segments)，每个段使用独立的锁。这样可以减少锁竞争，提高并发性能</li><li>无锁读取：大多数情况下读取操作是无锁的(lock-free)，这意味着多个线程可以同时读取数据而不会阻塞。这使得读取操作非常高效</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>ConcurrentDictionary的应用场景很多，例如缓存系统、共享数据存储、统计和聚合数据、任务调度和状态管理、并发日志记录、分布式锁或资源管理、实时数据处理等。</p><h5 id="统计和聚合数据"><a href="#统计和聚合数据" class="headerlink" title="统计和聚合数据"></a>统计和聚合数据</h5><p>在并发任务中，ConcurrentDictionary可以用于统计或聚合数据，例如计数、求和等。</p><p>下面这个示例使用了常规字典Dictionary对字符串列表进行统计，由于Dictionary是线程不安全的，统计结果将会不可预知。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="built_in">string</span>[] words = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟多线程环境</span></span><br><span class="line">Parallel.ForEach(words, word =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.ContainsKey(word))</span><br><span class="line">    &#123;</span><br><span class="line">        dict[word] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dict[word] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> dict)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;kvp.Key&#125;</span>: <span class="subst">&#123;kvp.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码运行后有概率会出现以下错误提示：</p><blockquote><p>1.<code>Object reference not set to an instance of an object</code>.<br>2.<code>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection&#39;s state is no longer correct.</code></p></blockquote><p>更改非并发集合的操作必须具有独占访问权限。对非并发集合执行并发更新将会损坏其状态，集合的状态将不再正确。可以使用lock关键字手动添加互斥锁避免竞态条件，也可以直接使用ConcurrentDictionary。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> concurrentDict = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="built_in">string</span>[] words = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟多线程环境</span></span><br><span class="line">Parallel.ForEach(words, word =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    concurrentDict.AddOrUpdate(word, <span class="number">1</span>, (key, oldValue) =&gt; oldValue + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> concurrentDict)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;kvp.Key&#125;</span>: <span class="subst">&#123;kvp.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="并发日志记录"><a href="#并发日志记录" class="headerlink" title="并发日志记录"></a>并发日志记录</h5><p>在并发环境中，ConcurrentDictionary可以用于记录日志或事件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="keyword">new</span> ConcurrentDictionary&lt;DateTime, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    log.TryAdd(DateTime.Now, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟多线程环境</span></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">10</span>, i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    LogEvent(<span class="string">$&quot;Event <span class="subst">&#123;i&#125;</span> occurred&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> log)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;kvp.Key&#125;</span>: <span class="subst">&#123;kvp.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出的日志记录个数是不确定的，因为同一时间只会记录一条记录。</p><h5 id="分布式锁或资源管理"><a href="#分布式锁或资源管理" class="headerlink" title="分布式锁或资源管理"></a>分布式锁或资源管理</h5><p>ConcurrentDictionary可以用于实现简单的分布式锁或资源管理。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resourceLocks = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line"><span class="keyword">var</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AccessResource</span>(<span class="params"><span class="built_in">int</span> resourceId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> resourceLock = resourceLocks.GetOrAdd(resourceId, id =&gt; <span class="keyword">new</span> <span class="built_in">object</span>());</span><br><span class="line">    <span class="keyword">lock</span>(resourceLock)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Resource <span class="subst">&#123;resourceId&#125;</span> is being accessed by thread <span class="subst">&#123;Task.CurrentId&#125;</span>&quot;</span>);</span><br><span class="line">        Task.Delay(<span class="number">1000</span>).Wait(); <span class="comment">// 模拟资源访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程访问资源</span></span><br><span class="line">Parallel.For(<span class="number">1</span>, <span class="number">10</span>, i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    AccessResource(i % <span class="number">3</span>); <span class="comment">// 重复访问相同的资源</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码对于同一资源的访问赋予了独占访问权限，若使用普通锁(将resourceLock改为lockObj)，那么某个进程访问资源池中的某个资源时，将会导致资源池中的其他资源也无法被访问。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide" >C#编程指南<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/" >.NET API参考文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/fundamentals/runtime-libraries/system-dynamic-expandoobject" >System.Dynamic.ExpandoObject类使用说明<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;c#进阶语法，包含委托与事件、动态类型与泛型、并发访问控制等。&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Language/"/>
    
    
    <category term="c#" scheme="https://jocoboy.github.io/Hexo-Blog/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>.NET HttpClient使用详解</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2025/03/04/http-client-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2025/03/04/http-client-usage/</id>
    <published>2025-03-04T09:03:08.000Z</published>
    <updated>2025-08-01T09:27:22.785Z</updated>
    
    <content type="html"><![CDATA[<p>.NET中使用HttpClient发送HTTP请求的方式介绍。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在c#中常见发送http请求的方式有以下三种：</p><ul><li>HttpWebRequest: .NET平台原生提供，这是.NET创建者最初开发用于使用HTTP请求的标准类。使用HttpWebRequest可以让开发者控制请求&#x2F;响应流程的各个方面，如timeouts,cookies,headers,protocols</li><li>WebClient: .NET平台原生提供，WebClient是一种更高级别的抽象，是HttpWebRequest为了简化最常见任务而创建的，但也因此缺少了HttpWebRequest的灵活性</li><li>HttpClient: .NET平台原生提供，目前主流使用的Http请求工具类，直接基于Socket开发，提供了异步友好的代码编写方式，是线程安全的</li></ul><h2 id="HTTP-Content-Type"><a href="#HTTP-Content-Type" class="headerlink" title="HTTP Content-Type"></a>HTTP Content-Type</h2><p>在HTTP协议中，客户端和服务器之间通过请求和响应进行通信。在这个过程中，传输的数据有各种不同的格式类型，为了确保双方能够正确理解和处理数据，需要正确设置Content-Type。Content-Type是指示发送端内容的媒体类型的HTTP头部，广泛用于请求和响应中。</p><p>媒体类型(Media Type)，也称为MIME类型(Multipurpose Internet Mail Extensions)，指定了内容的格式和编码方式。常见的Content-Type有以下几种：</p><ul><li>text&#x2F;plain: 表示内容是纯文本，不包含格式化信息。通常用于简单的文本内容，没有特殊的意义标记</li><li>text&#x2F;html: 表示该内容是HTML文档</li><li>text&#x2F;xml: 表示内容是XML文档，可用于soap1.1协议。在text&#x2F;xml中，XML头指定的编码格式无效，必须在HTTP头部的Content-Type中指定才会生效</li><li>application&#x2F;soap+xml：表示内容是XML文档，可用于soap1.2协议</li><li>application&#x2F;xml: 表示内容是XML文档，可直接在XML头指定编码格式，是常规XML格式的首选类型</li><li>application&#x2F;octet-stream: 表示二进制流数据，可在下载文件类型未知的情况下使用</li><li>application&#x2F;json: 表示内容是JSON格式。JSON是一种轻量级的数据交换格式，广泛用于API的请求和响应中</li><li>application&#x2F;x-www-form-urlencoded: 表示数据以键值对形式进行编码，是HTML表单默认的Content-Type类型</li><li>multipart&#x2F;form-data: 通常用于表单数据中包含文件上传的情景。在这种类型中，数据被拆分成多个部分，每个部分包含自己独立的头部信息</li></ul><h2 id="HttpClient使用配置"><a href="#HttpClient使用配置" class="headerlink" title="HttpClient使用配置"></a>HttpClient使用配置</h2><p>当我们发送http请求时，可以使用SocketsHttpHandler处理一些事情，比如是否自动处理cookie，是否自动重定向以及最多重定向几次等。以下展示了常见的配置项：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在.net core 2.1之后，默认所有的http请求都会交给SocketsHttpHandler处理</span></span><br><span class="line"><span class="keyword">var</span> socketsHttpHandler = <span class="keyword">new</span> SocketsHttpHandler()</span><br><span class="line">&#123;</span><br><span class="line">    UseCookies = <span class="literal">false</span>, <span class="comment">//是否自动处理cookie</span></span><br><span class="line"></span><br><span class="line">    AllowAutoRedirect = <span class="literal">true</span>,<span class="comment">//是否自动重定向, 默认true</span></span><br><span class="line">    MaxAutomaticRedirections = <span class="number">50</span>,<span class="comment">//自动重定向的最大次数, 默认50</span></span><br><span class="line"></span><br><span class="line">    MaxConnectionsPerServer = <span class="number">100</span>, <span class="comment">//每个请求连接的最大数量, 默认是int.MaxValue</span></span><br><span class="line">    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(<span class="number">2</span>), <span class="comment">//连接池中TCP连接最多可以闲置多久, 默认2分钟</span></span><br><span class="line">    PooledConnectionLifetime = Timeout.InfiniteTimeSpan, <span class="comment">//连接最长的存活时间, 默认是不限制的</span></span><br><span class="line"></span><br><span class="line">    AutomaticDecompression = DecompressionMethods.GZip, <span class="comment">//是否压缩，默认是None，即不压缩</span></span><br><span class="line"></span><br><span class="line">   ConnectTimeout = Timeout.InfiniteTimeSpan,  <span class="comment">//建立TCP连接时的超时时间, 默认不限制</span></span><br><span class="line">   Expect100ContinueTimeout = TimeSpan.FromSeconds(<span class="number">1</span>), <span class="comment">//等待服务返回statusCode=100的超时时间, 默认1秒</span></span><br><span class="line"></span><br><span class="line">   MaxResponseHeadersLength = <span class="number">64</span>, <span class="comment">//响应头大小限制，单位kb</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient(socketsHttpHandler);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，可以给HttpClient设置基地址，当HttpClient发送的请求不包含前缀时，将自动拼接上，否则不予拼接。还可以设置默认的http版本、请求头。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpClient.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/&quot;</span>);</span><br><span class="line">httpClient.DefaultRequestVersion = HttpVersion.Version20;</span><br><span class="line">httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;parameter1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="HttpClient请求方法"><a href="#HttpClient请求方法" class="headerlink" title="HttpClient请求方法"></a>HttpClient请求方法</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET请求不需要设置Content-Type，因为GET请求的参数是通过URL传递的，而不是在请求体中。通过GET请求数据的示例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>?<span class="subst">&#123;parameter1&#125;</span>=<span class="subst">&#123;value1&#125;</span>&amp;<span class="subst">&#123;parameter2&#125;</span>=<span class="subst">&#123;value2&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(url);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure><p>若要通过GET方法下载文件，可以通过如下方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> downloadUrl = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;srcDir&#125;</span>/<span class="subst">&#123;srcFile&#125;</span>&quot;</span>; <span class="comment">// 文件虚拟路径</span></span><br><span class="line"><span class="keyword">var</span> downloadPath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;desDir&#125;</span>\\<span class="subst">&#123;desFile&#125;</span>&quot;</span>; <span class="comment">// 下载物理路径</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(downloadUrl);</span><br><span class="line"><span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(downloadPath, FileMode.OpenOrCreate, FileAccess.Write);</span><br><span class="line"><span class="keyword">await</span> response.Content.CopyToAsync(fileStream);</span><br><span class="line">fileStream.Close();</span><br></pre></td></tr></table></figure><p>若要下载超过2GB的文件，则需要通过如下方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> downloadUrl = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;srcDir&#125;</span>/<span class="subst">&#123;srcFile&#125;</span>&quot;</span>; <span class="comment">// 文件虚拟路径</span></span><br><span class="line"><span class="keyword">var</span> downloadPath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;desDir&#125;</span>\\<span class="subst">&#123;desFile&#125;</span>&quot;</span>; <span class="comment">// 下载物理路径</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(downloadUrl, HttpCompletionOption.ResponseHeadersRead); <span class="comment">// 拿到响应头就返回</span></span><br><span class="line"><span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(downloadPath, FileMode.OpenOrCreate, FileAccess.Write);</span><br><span class="line"><span class="keyword">await</span> response.Content.CopyToAsync(fileStream);</span><br><span class="line">fileStream.Close();</span><br></pre></td></tr></table></figure><p>若要给大文件下载添加进度提示，可以事先通过http响应头的Content-Length获取到文件大小，具体实现如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> downloadUrl = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;srcDir&#125;</span>/<span class="subst">&#123;srcFile&#125;</span>&quot;</span>; <span class="comment">// 文件虚拟路径</span></span><br><span class="line"><span class="keyword">var</span> downloadPath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;desDir&#125;</span>\\<span class="subst">&#123;desFile&#125;</span>&quot;</span>; <span class="comment">// 下载物理路径</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(downloadUrl, HttpCompletionOption.ResponseHeadersRead);</span><br><span class="line"><span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(downloadPath, FileMode.OpenOrCreate, FileAccess.Write);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line"><span class="keyword">var</span> totalLength = response.Content.Headers.ContentLength;</span><br><span class="line"><span class="built_in">long</span> readLength = <span class="number">0L</span>;</span><br><span class="line"><span class="built_in">int</span> length;</span><br><span class="line"><span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">5</span> * <span class="number">1024</span>]; <span class="comment">// 5KB缓存</span></span><br><span class="line"><span class="keyword">while</span> ((length = <span class="keyword">await</span> contentStream.ReadAsync(buffer)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    readLength += length;</span><br><span class="line">    <span class="keyword">if</span> (totalLength &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;下载进度: &quot;</span> + Math.Round((<span class="built_in">double</span>)readLength / totalLength.Value * <span class="number">100</span>, <span class="number">2</span>) + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;已下载: &quot;</span> + Math.Round(readLength / <span class="number">1024.0</span>, <span class="number">2</span>) + <span class="string">&quot;KB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fileStream.Write(buffer, <span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileStream.Close();</span><br></pre></td></tr></table></figure><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>根据Content-Type类型，常见的请求类型有application&#x2F;json、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded等。</p><h4 id="application-json"><a href="#application-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h4><p>使用POST请求application&#x2F;json类型的示例如下(.NET中对应接口参数使用FromBody特性，或直接使用类接收)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> stringContent = <span class="keyword">new</span> StringContent(JsonConvert.SerializeObject(<span class="keyword">new</span> &#123; parameter1 = <span class="string">&quot;value1&quot;</span>, parameter2 = <span class="string">&quot;value2&quot;</span> &#125;), Encoding.UTF8, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.PostAsync(url, stringContent);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure><h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h4><p>使用POST请求multipart&#x2F;form-data类型的示例如下(.NET中对应接口参数使用FromForm特性)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>&quot;</span>; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> formData = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="keyword">new</span> StringContent(<span class="string">&quot;value1&quot;</span>), <span class="string">&quot;parameter1&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="keyword">new</span> StringContent(<span class="string">&quot;value2&quot;</span>), <span class="string">&quot;parameter2&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.PostAsync(url, formData);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure><p>若要添加文件流参数(.NET中使用IFormFile接收), 可使用以下方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> downloadUrl = Path.Combine(<span class="keyword">new</span> DirectoryInfo(AppContext.BaseDirectory).Parent.FullName, <span class="string">&quot;Upload&quot;</span>, fileMd5);</span><br><span class="line"><span class="keyword">using</span> FileStream stream = System.IO.File.OpenRead(downloadUrl);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> memoryStream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"><span class="keyword">await</span> stream.CopyToAsync(memoryStream);</span><br><span class="line"><span class="built_in">byte</span>[] fileBytes = memoryStream.ToArray();</span><br><span class="line"></span><br><span class="line">formData.Add(<span class="keyword">new</span> ByteArrayContent(fileBytes), <span class="string">&quot;parameter3&quot;</span>, Path.GetFileName(fileName));</span><br></pre></td></tr></table></figure><h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h4><p>使用POST请求application&#x2F;x-www-form-urlencoded类型的示例如下(.NET中对应接口参数使用FromForm特性)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> urlEncodedContent = <span class="keyword">new</span> FormUrlEncodedContent(<span class="keyword">new</span> List&lt;KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;parameter1&quot;</span>,<span class="string">&quot;value1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;parameter2[0]&quot;</span>,<span class="string">&quot;value2&quot;</span>), <span class="comment">// parameter2为数组类型</span></span><br><span class="line">    <span class="keyword">new</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;parameter2[1]&quot;</span>,<span class="string">&quot;value3&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.PostAsync(url, urlEncodedContent);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://config.net.cn/tools/HttpContentType.html" >Http请求中各种Content-Type类型详解大全<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.net.http.socketshttphandler" >SocketsHttpHandler类使用参考<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/fundamentals/networking/http/httpclient" >使用HttpClient类发出HTTP请求<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;.NET中使用HttpClient发送HTTP请求的方式介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Network-Protocol" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Network-Protocol/"/>
    
    
    <category term=".NET" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET/"/>
    
    <category term="ASP.NET Core" scheme="https://jocoboy.github.io/Hexo-Blog/tags/ASP-NET-Core/"/>
    
    <category term="HttpClient" scheme="https://jocoboy.github.io/Hexo-Blog/tags/HttpClient/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core 实现定时后台任务</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2025/01/06/background-service/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2025/01/06/background-service/</id>
    <published>2025-01-06T07:35:14.000Z</published>
    <updated>2025-08-01T09:27:22.782Z</updated>
    
    <content type="html"><![CDATA[<p>.NET Core实现定时后台任务的几种方法。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发应用时，定时任务是一个常见的需求。它可以自动化周期性的操作，例如定期同步数据、定时清理缓存、发送通知等。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>数据处理<ul><li>数据同步：定时从外部数据源（如数据库、API等）同步数据到本地系统</li><li>数据备份：定期备份数据库或文件系统中的数据，以防止数据丢失</li></ul></li><li>系统维护<ul><li>缓存更新：定时刷新缓存数据，确保缓存中的数据是最新的</li><li>日志清理：定时清理日志文件，防止日志文件占用过多磁盘空间</li></ul></li><li>任务调度<ul><li>定时任务调度：根据预设的时间表或条件，自动执行特定的任务。例如，每天凌晨自动执行数据备份任务</li><li>任务队列处理：定时从任务队列中取出任务并执行，适用于需要异步处理的场景</li></ul></li><li>用户交互<ul><li>定时通知：定时向用户发送通知或提醒，例如发送邮件、短信或应用内通知</li></ul></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="基于IHostedService接口实现自定义后台服务"><a href="#基于IHostedService接口实现自定义后台服务" class="headerlink" title="基于IHostedService接口实现自定义后台服务"></a>基于IHostedService接口实现自定义后台服务</h3><p>定时后台任务使用System.Threading.Timer类。在StartAsync上使用计时器执行DoWork任务，在StopAsync上禁用计时器，并在Dispose上处置服务容器时处置计时器。</p><p>Timer不等待先前的DoWork执行完成。使用Interlocked.Increment以原子操作的形式将执行计数器递增，这可确保多个线程不会并行更新executionCount。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>首先创建自定义的后台服务类，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimedHostedService</span> : <span class="title">IHostedService</span>, <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> executionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;TimedHostedService&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> Timer _timer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimedHostedService</span>(<span class="params">ILogger&lt;TimedHostedService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">&quot;Timed Hosted Service running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        _timer = <span class="keyword">new</span> Timer(DoWork, <span class="literal">null</span>, TimeSpan.Zero,</span><br><span class="line">            TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> count = Interlocked.Increment(<span class="keyword">ref</span> executionCount);</span><br><span class="line"></span><br><span class="line">        _logger.LogInformation(</span><br><span class="line">            <span class="string">&quot;Timed Hosted Service is working. Count: &#123;Count&#125;&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">&quot;Timed Hosted Service is stopping.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        _timer?.Change(Timeout.Infinite, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _timer?.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Startup中注册服务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddHostedService&lt;TimedHostedService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用BackgroundService"><a href="#使用BackgroundService" class="headerlink" title="使用BackgroundService"></a>使用BackgroundService</h3><p>BackgroundService是用于实现长时间运行的IHostedService的基类，是IHostedService的一个简单实现。</p><p>StartAsync应仅限于短期任务，因为托管服务是按顺序运行的，在StartAsync运行完成之前不会启动其他服务。长期任务应放置在ExecuteAsync中。</p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>首先创建服务类，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WorkService</span> : <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> executionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WorkService&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> DateTime nextDateTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkService</span>(<span class="params">ILogger&lt;WorkService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> StartHour = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> StartMinute = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> StartSecond = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> IntervalMinute = <span class="number">1440</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算下一个时间节点</span></span><br><span class="line">            <span class="keyword">var</span> now = DateTime.Now;</span><br><span class="line">            <span class="keyword">var</span> firstDateTime = <span class="keyword">new</span> DateTime(now.Year, now.Month, now.Day, StartHour, StartMinute, StartSecond);</span><br><span class="line">            <span class="keyword">if</span>(executionCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = firstDateTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = nextDateTime.AddMinutes(IntervalMinute);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nextDateTime &lt; now)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime.AddDays(<span class="number">1</span>) - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">                <span class="keyword">await</span> DoWork();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> count = Interlocked.Increment(<span class="keyword">ref</span> executionCount);</span><br><span class="line">                _logger.LogInformation(<span class="string">&quot;Timed Hosted Service is working. Count: &#123;Count&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DoWork</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建后台服务调用类，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomBackgroundService</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _services;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomBackgroundService</span>(<span class="params">IServiceProvider services</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _services = services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> scope = _services.CreateScope();</span><br><span class="line">        <span class="comment">//获取服务类</span></span><br><span class="line">        <span class="keyword">var</span> taskWorkService = scope.ServiceProvider.GetRequiredService&lt;IWorkService&gt;();</span><br><span class="line">        <span class="comment">//执行服务类的定时任务</span></span><br><span class="line">        <span class="keyword">await</span> taskWorkService.TaskWorkAsync(stoppingToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在Startup中注册后台服务，并添加主机服务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddScoped&lt;IWorkService, WorkService&gt;();</span><br><span class="line">    services.AddHostedService&lt;CustomBackgroundService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/timer-service" >如何实现IHostedService接口<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&tabs=visual-studio" >如何在ASP.NET Core中使用托管服务实现后台任务<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;.NET Core实现定时后台任务的几种方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Framework" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Framework/"/>
    
    
    <category term=".NET" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET/"/>
    
    <category term="ASP.NET Core" scheme="https://jocoboy.github.io/Hexo-Blog/tags/ASP-NET-Core/"/>
    
    <category term="BackgroundJob" scheme="https://jocoboy.github.io/Hexo-Blog/tags/BackgroundJob/"/>
    
  </entry>
  
  <entry>
    <title>安全扫描技术及其应用场景</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/12/13/security-scan/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/12/13/security-scan/</id>
    <published>2024-12-13T06:36:57.000Z</published>
    <updated>2025-08-01T09:27:22.794Z</updated>
    
    <content type="html"><![CDATA[<p>三种常用的安全扫描技术原理、相关工具及应用场景。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安全扫描技术是网络安全领域中用于检测系统、网络和应用程序中潜在安全漏洞的重要手段，分为端口扫描技术、漏洞扫描技术、Web应用扫描技术等，其中漏洞扫描技术分为基于网络的漏洞扫描和基于主机的漏洞扫描。其工作流程分为信息收集、扫描执行、结果分析、漏洞报告四个部分。</p><h2 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过向目标主机的一系列端口发送数据包，根据目标主机的响应来判断端口是开放还是关闭的。例如，TCP 连接扫描（全连接扫描）会尝试与目标端口建立完整的 TCP 三次握手。如果能够成功完成三次握手，说明端口是开放的；如果在握手过程中收到复位（RST）信号，则表示端口是关闭的。</p><h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><p>Nmap是一款非常著名的端口扫描工具。它可以快速扫描目标主机上大量端口，并且能够识别端口对应的服务。例如，使用命令<code>nmap -p 1 - 1000 &lt;target_ip_address&gt;</code>可以扫描目标主机上1到1000号端口的开放情况。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="SSL-TLS协议信息泄露漏洞（CVE-2016-2183）"><a href="#SSL-TLS协议信息泄露漏洞（CVE-2016-2183）" class="headerlink" title="SSL&#x2F;TLS协议信息泄露漏洞（CVE-2016-2183）"></a>SSL&#x2F;TLS协议信息泄露漏洞（CVE-2016-2183）</h4><p>Windows系统下使用DES、3DES、IDEA等弱加密算法会引发SSL&#x2F;TLS协议信息泄露漏洞。</p><p>首先下载<a class="link"   href="https://nmap.org/download#windows" >nmap<i class="fas fa-external-link-alt"></i></a>，下载完成后打开命令行输入以下命令(端口以443为例)，查看套件中是否存在DES&#x2F;3DES加密套件</p><p><code>nmap -p 443 --script ssl-enum-ciphers localhost</code></p><p>确认漏洞存在后，下载<a class="link"   href="https://www.nartac.com/Products/IISCrypto/Download" >IISCrypto<i class="fas fa-external-link-alt"></i></a>禁用加密套件。安装完成后点击左下角推荐设置Best Practices，再取消勾选Ciphers框里的Triple DES 168，即可点击Apply并重启，此时使用nmap复查发现DES&#x2F;3DES加密套件已消失，漏洞修复完成。</p><h2 id="基于网络的漏洞扫描技术"><a href="#基于网络的漏洞扫描技术" class="headerlink" title="基于网络的漏洞扫描技术"></a>基于网络的漏洞扫描技术</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过网络向目标系统发送特定的探测数据包，模拟黑客攻击行为，检查目标系统是否存在已知的安全漏洞。这些扫描器通常拥有一个庞大的漏洞数据库，其中包含各种软件、操作系统和网络设备的已知漏洞信息。</p><h3 id="相关工具-1"><a href="#相关工具-1" class="headerlink" title="相关工具"></a>相关工具</h3><p>OpenVAS是一个开源的漏洞扫描器，它能够扫描网络中的各种设备，包括服务器、防火墙等，检测诸如操作系统漏洞、Web 应用漏洞等多种类型的漏洞。</p><h2 id="基于主机的漏洞扫描技术"><a href="#基于主机的漏洞扫描技术" class="headerlink" title="基于主机的漏洞扫描技术"></a>基于主机的漏洞扫描技术</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>在目标主机本地安装扫描软件，对主机系统本身进行扫描，检查系统配置、文件权限、安装的软件等方面是否存在安全隐患。它主要关注主机内部的安全状态，例如检查是否存在弱口令、未及时更新的软件等。</p><h3 id="相关工具-2"><a href="#相关工具-2" class="headerlink" title="相关工具"></a>相关工具</h3><p>MBSA（Microsoft Baseline Security Analyzer）是一款针对Windows系统的漏洞扫描工具，可以检测Windows操作系统以及微软的其他软件（如 IIS、SQL Server 等）是否存在安全漏洞，包括安全更新缺失、账户策略不安全等问题。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="IIS隐藏Server信息"><a href="#IIS隐藏Server信息" class="headerlink" title="IIS隐藏Server信息"></a>IIS隐藏Server信息</h4><p>IIS服务器端返回信息中包含有软件版本等详细信息，攻击者利用这些信息可以实现更有目的性的攻击。因此隐藏server版本信息，在一定程度上能够提高服务器的安全性。</p><p>可通过下载<a class="link"   href="https://www.iis.net/downloads/microsoft/url-rewrite" >Rewrite插件<i class="fas fa-external-link-alt"></i></a>，然后修改<code>C:\Windows\System32\inetsrv\config\applicationHost.config</code>配置文件来实现，配置必须写在system.webServer节点内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rewrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">allowedServerVariables</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">&quot;REMOTE_ADDR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">allowedServerVariables</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">&quot;REMOVE_RESPONSE_SERVER&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">match</span> <span class="attr">serverVariable</span>=<span class="string">&quot;RESPONSE_SERVER&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;.*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">type</span>=<span class="string">&quot;Rewrite&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">outboundRules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rewrite</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Web应用扫描技术"><a href="#Web应用扫描技术" class="headerlink" title="Web应用扫描技术"></a>Web应用扫描技术</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>主要用于检测Web应用程序中的安全漏洞，如SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等。扫描器会对Web应用的页面、表单、链接等进行分析，发送各种特制的请求来测试应用程序的安全性。</p><h3 id="相关工具-3"><a href="#相关工具-3" class="headerlink" title="相关工具"></a>相关工具</h3><p>Acunetix是一款专业的Web应用安全扫描工具，它能够自动检测多种Web漏洞。例如，在扫描一个包含用户登录功能的Web页面时，它可以检测输入框是否容易受到SQL注入攻击，以及登录后的页面是否存在 XSS 漏洞等。</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="URL参数安全防护"><a href="#URL参数安全防护" class="headerlink" title="URL参数安全防护"></a>URL参数安全防护</h4><p>对所有用户输入进行严格的验证和过滤是防范XSS攻击的关键，当应用程序将用户输入的数据嵌入到HTML页面中时，必须对数据进行适当的编码，确保只接受预期的字符集和格式。</p><p>例如，可将请求参数放到Headers中，并按指定的字符集(如ISO8859-1)进行编码。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Login</span>(<span class="params">[FromBody] LoginInput input</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringValues para = <span class="keyword">new</span> StringValues();</span><br><span class="line">    <span class="keyword">if</span> (Request.Headers.TryGetValue(<span class="string">&quot;username&quot;</span>, <span class="keyword">out</span> <span class="keyword">var</span> headerValues) &amp;&amp; headerValues.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        para = headerValues[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">&quot;参数username不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> strs = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> bytes = Encoding.GetEncoding(<span class="string">&quot;ISO8859-1&quot;</span>).GetBytes(para);</span><br><span class="line">        strs = Encoding.GetEncoding(<span class="string">&quot;ISO8859-1&quot;</span>).GetString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ArgumentException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">$&quot;编码转换异常: <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置Cookie的HTTPOnly属性"><a href="#设置Cookie的HTTPOnly属性" class="headerlink" title="设置Cookie的HTTPOnly属性"></a>设置Cookie的HTTPOnly属性</h4><p>Session和Cookie是两种常用的客户端存储技术，它们在Web开发中用于存储和管理用户状态，以下是二者的区别：</p><table><thead><tr><th>区别</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>存储在客户端浏览器中，以键值对的形式存在</td><td>存储在服务器端，每个用户会话对应一个唯一的Session对象</td></tr><tr><td>存储方式</td><td>通过HTTP响应头发送给客户端，并保存在浏览器中</td><td>通过Session ID（通常存储在Cookie中）在服务器端进行标识和存储</td></tr><tr><td>存储容量</td><td>4KB</td><td>无限制</td></tr><tr><td>安全性</td><td>容易受到XSS和CSRF等攻击，可以通过设置HttpOnly、Secure和SameSite属性来提高安全性</td><td>存储在服务器端，相对来说更安全，但也需要注意Session劫持和修复等安全问题</td></tr><tr><td>生命周期</td><td>可以设置过期时间，到期后浏览器会自动删除</td><td>依赖于服务器设置的超时时间，用户不活跃超过这个时间后，Session会失效</td></tr><tr><td>跨域问题</td><td>可以通过设置Domain属性实现跨域访问</td><td>通常与特定的域绑定，不支持跨域访问</td></tr><tr><td>访问方式</td><td>可以通过JavaScript的document.cookie属性直接访问和修改</td><td>需要通过服务器端代码来访问和修改</td></tr><tr><td>传输</td><td>每次HTTP请求都会自动发送到服务器，增加了请求的负载</td><td>不需要在每次请求中发送，只在建立Session和通过Session ID获取Session数据时与服务器交互</td></tr><tr><td>用途</td><td>常用于保存用户的偏好设置、会话标识等</td><td>用于跟踪用户的状态，如登录状态、购物车内容等</td></tr></tbody></table><p>WWW服务依赖于Http协议实现，Http是无状态的协议，所以为了在各个会话之间传递信息，就需要使用Cookie来标记访问者的状态，以便服务器端识别用户信息。Cookie由变量名与值组成，其属性里有标准的cookie变量，也有用户自定义的属性。Cookie保存在浏览器的document对象中，对于存在XSS漏洞的网站，入侵者可以插入简单的XSS语句执行任意的JS脚本，以XSS攻击的手段获取网站其余用户的Cookie。</p><p>为了防止用户Cookie被JS脚本恶意读取，可以在服务端设置HTTP - only属性，NET Core下可通过中间件添加到应用程序管道来实现。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpOnlyCookieMiddleware.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpOnlyCookieMiddleware</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">HttpOnlyCookieMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         _next = next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 在响应发送之前设置Cookie选项</span></span><br><span class="line">         context.Response.OnStarting(() =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">var</span> cookies = context.Response.Cookies;</span><br><span class="line">             <span class="keyword">var</span> options = <span class="keyword">new</span> CookieOptions</span><br><span class="line">             &#123;</span><br><span class="line">                 HttpOnly = <span class="literal">true</span></span><br><span class="line">             &#125;;</span><br><span class="line">             <span class="keyword">var</span> authToken = context.Request.Cookies[<span class="string">&quot;AuthToken&quot;</span>];</span><br><span class="line">             <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(authToken))</span><br><span class="line">             &#123;</span><br><span class="line">                 cookies.Append(<span class="string">&quot;AuthToken&quot;</span>, authToken, options);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">await</span> _next(context);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HttpOnlyCookieMiddlewareExtensions</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">UseHttpOnlyCookieMiddleware</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder builder</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> builder.UseMiddleware&lt;HttpOnlyCookieMiddleware&gt;();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    app.UseHttpOnlyCookieMiddleware();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://www.toolhelper.cn/EncodeDecode/EncodeDecode" >字符串编码和解码在线工具<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/iis/get-started/planning-your-iis-architecture/introduction-to-applicationhostconfig" >ApplicationHost.config简介<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/aspnet/core/migration/http-modules" >.NET Core中间件使用参考<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;三种常用的安全扫描技术原理、相关工具及应用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="Cyber-Security" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Cyber-Security/"/>
    
    
    <category term="Security-Scan" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Security-Scan/"/>
    
  </entry>
  
  <entry>
    <title>SQL Server常用SQL、T-SQL语句</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/12/04/sqlserver-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/12/04/sqlserver-usage/</id>
    <published>2024-12-04T02:02:40.000Z</published>
    <updated>2025-08-01T09:27:22.794Z</updated>
    
    <content type="html"><![CDATA[<p>SQL Server数据库的适用场景，以及一些常用SQL、T-SQL语句。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Microsoft SQL Server(又称 MS SQL)是一种关系数据库管理系统(RDBMS)。应用程序和工具连接到SQL Server实例或数据库，并使用Transact-SQL(T-SQL)进行通信。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>与MySQL相比，SQL Server数据库有以下优势：</p><ul><li>高可用性解决方案：SQL Server提供了一套成熟的高可用性解决方案，如Always - On可用性组。它允许数据库管理员在不同的服务器之间配置数据库副本，实现自动故障转移。</li><li>强大的查询优化器：SQL Server拥有一个先进的查询优化器，它能够根据查询的复杂程度、数据分布以及索引情况自动生成高效的执行计划。例如，在处理包含多个表连接、子查询和复杂条件的大型企业级查询时，SQL Server的查询优化器能够通过多种优化策略（如选择合适的连接算法、索引使用等）来减少查询响应时间。</li><li>集成的身份认证和权限管理：SQL Server支持Windows身份认证和SQL Server身份认证两种方式。在企业环境中，Windows身份认证可以与企业的活动目录集成，方便用户管理和权限控制。</li><li>数据加密功能：SQL Server提供了透明数据加密（TDE）功能，可以对整个数据库进行加密，包括数据文件和日志文件。这在数据存储和传输过程中，有效保护了数据的安全性。</li><li>与.NET集成：SQL Server与.NET 框架配合紧密，通过ADO.NET等技术，开发人员可以轻松地在各种.NET应用程序中访问和操作数据库。这种紧密的集成使得企业在构建基于微软技术栈的应用系统时，选择SQL Server能够减少技术整合的复杂性。</li></ul><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>.NET项目配置文件中数据库连接字符串如下，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;SqlserverConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data Source=DESKTOP-Q4ORSFH\\SQLEXPRESS;Initial Catalog=your-database;Persist Security Info=True;User ID=sa;Password=your-password&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>备注：SQL Server默认监听的端口号为1433，因此连接字符串可以不指定端口号</p><h3 id="GUI方式"><a href="#GUI方式" class="headerlink" title="GUI方式"></a>GUI方式</h3><p>SQL Server Management Studio（SSMS）是微软为SQL Server数据库提供的一款功能强大、集成度高的管理工具。以免费版为例，选择SQL Server身份认证方式登录，默认登录名为sa。</p><h3 id="CLI方式"><a href="#CLI方式" class="headerlink" title="CLI方式"></a>CLI方式</h3><p>sqlcmd是SQL Server自带的命令行工具，它允许用户在命令提示符或批处理文件中执行T-SQL语句和脚本。通过sqlcmd可以连接到本地或远程的SQL Server实例，执行数据库操作，如查询数据、创建数据库对象、执行存储过程等。</p><p>以SQL Server身份认证方式连接到数据库，</p><p><code>sqlcmd -S localhost -U sa -P your-password -d your-database</code></p><p>以Windows身份认证方式连接到数据库，</p><p><code>sqlcmd -S localhost -E -d your-database</code> </p><p><code>sqlcmd -S localhost -T -d your-database</code></p><h2 id="T-SQL"><a href="#T-SQL" class="headerlink" title="T-SQL"></a>T-SQL</h2><p>T - SQL（Transact - SQL）是微软为SQL Server数据库管理系统开发的一种编程语言。它是SQL的扩展，用于在SQL Server环境中进行数据定义、数据操纵、数据控制以及事务处理等操作。T - SQL不仅包含了标准SQL的命令，还增加了许多用于增强功能和编程便利性的扩展语法。</p><h3 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h3><h4 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h4><p>创建数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [dbo].[table_name] (</span><br><span class="line">    Id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    [column_name] <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h4><p>在表中添加新的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">ADD</span> [column_name] <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [dbo].[table_name];</span><br></pre></td></tr></table></figure><h3 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h3><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p>在表中插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [dbo].[table_name] ([column_name]) <span class="keyword">VALUES</span> (<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><p>更新表中数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">SET</span> [column_name] <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [dbo].[table_name]</span><br></pre></td></tr></table></figure><h3 id="数据查询语言（DQL）"><a href="#数据查询语言（DQL）" class="headerlink" title="数据查询语言（DQL）"></a>数据查询语言（DQL）</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [column_name] <span class="keyword">FROM</span> [dbo].[table_name]</span><br></pre></td></tr></table></figure><h3 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h3><h4 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="用户权限管理"></a>用户权限管理</h4><p>授予用户查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> [dbo].[table_name] <span class="keyword">TO</span> [user_name];</span><br></pre></td></tr></table></figure><p>撤销用户查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> [dbo].[table_name] <span class="keyword">TO</span> [user_name];</span><br></pre></td></tr></table></figure><h4 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h4><p>可以使用BEGIN TRANSACTION、COMMIT TRANSACTION和ROLLBACK TRANSACTION语句来控制事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">SET</span> [column_name] <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION;</span><br></pre></td></tr></table></figure><h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>T - SQL支持存储过程的创建和调用。存储过程是一组预编译的T - SQLx语句，可以在数据库中存储并反复调用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [dbo].[GetAllInfos]</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> [dbo].[table_name];</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">EXEC</span> [dbo].[GetAllInfos];</span><br></pre></td></tr></table></figure><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>用户自定义函数可以返回一个值，并且可以在查询语句中使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> [dbo].[AddNumbers](<span class="variable">@num1</span> <span class="type">INT</span>, <span class="variable">@num2</span> <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="variable">@num1</span> <span class="operator">+</span> <span class="variable">@num2</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行函数</span></span><br><span class="line"><span class="keyword">SELECT</span> [dbo].[AddNumbers](<span class="number">3</span>, <span class="number">5</span>) <span class="keyword">AS</span> <span class="keyword">Result</span>;</span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>T - SQL 包含多种流程控制语句，用于编写复杂的程序逻辑。</p><h4 id="IF-ELSE"><a href="#IF-ELSE" class="headerlink" title="IF ELSE"></a>IF ELSE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@Variable</span> <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@Variable</span> <span class="operator">=</span> [column_name] <span class="keyword">FROM</span> [dbo].[table_name] <span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">IF <span class="variable">@Variable</span> <span class="operator">&gt;</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h4 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@Index</span> <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@Index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">WHILE <span class="variable">@Index</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 执行一些更新操作</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@Index</span> <span class="operator">=</span> <span class="variable">@Index</span> <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/sql/sql-server" >SQL Server官方中文文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/sql/tools/sqlcmd/sqlcmd-utility" >sqlcmd使用参考<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL Server数据库的适用场景，以及一些常用SQL、T-SQL语句。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Database/"/>
    
    
    <category term="SQL Server" scheme="https://jocoboy.github.io/Hexo-Blog/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>基于.NET的MSBuild常用命令</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/12/02/msbuild/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/12/02/msbuild/</id>
    <published>2024-12-02T08:01:11.000Z</published>
    <updated>2025-08-01T09:27:22.789Z</updated>
    
    <content type="html"><![CDATA[<p>基于.NET的MSBuild常用命令记录。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Microsoft生成引擎是一个用于生成应用程序的平台。此引擎（也称为 MSBuild）为项目文件提供了一个XML架构，用于控制生成平台处理和生成软件的方式。Visual Studio会使用MSBuild，但MSBuild不依赖于Visual Studio。通过在项目或解决方案文件中调用msbuild.exe或dotnet build，可以在未安装Visual Studio的环境中安排和生成产品。</p><h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>以VS 2022为例，MSBuild可执行文件路径为<code>C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin</code></p><h2 id="项目配置文件"><a href="#项目配置文件" class="headerlink" title="项目配置文件"></a>项目配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--回车符\r &amp;#xD; 换行符\n &amp;#xA; 双引号&quot; &amp;quot;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;PostBuild&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;PostBuildEvent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">&quot;if &#x27;$(IS_Integrated)&#x27; == &#x27;true&#x27; (<span class="symbol">&amp;#xD;</span><span class="symbol">&amp;#xA;</span>  xcopy $(TargetPath) $(SolutionDir)..\Outputs\  /R /Y<span class="symbol">&amp;#xD;</span><span class="symbol">&amp;#xA;</span>  xcopy $(TargetDir)$(TargetName).dll $(SolutionDir)..\Outputs\  /R /Y<span class="symbol">&amp;#xD;</span><span class="symbol">&amp;#xA;</span>)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;CopyDirectory&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;Build&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CopyCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27; == &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>xcopy <span class="symbol">&amp;quot;</span>$(SolutionDir)..\Outputs\*.dll<span class="symbol">&amp;quot;</span> <span class="symbol">&amp;quot;</span>$(ProjectDir)bin\$(Configuration)\netcoreapp3.1\<span class="symbol">&amp;quot;</span> /E /D /I /Y</span><br><span class="line">        <span class="tag">&lt;/<span class="name">CopyCommand</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CopyCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27; != &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>cp -r <span class="symbol">&amp;quot;</span>$(SolutionDir)..\Outputs\*.dll<span class="symbol">&amp;quot;</span> <span class="symbol">&amp;quot;</span>$(ProjectDir)bin\$(Configuration)\netcoreapp3.1\<span class="symbol">&amp;quot;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">CopyCommand</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">&quot;$(CopyCommand)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;CreateFolderIfNotExists&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;Build&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uploadPath</span>&gt;</span>$(ProjectDir)bin\$(Configuration)\upload<span class="tag">&lt;/<span class="name">uploadPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CreateCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27; == &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>if not exist <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span> md <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span><span class="tag">&lt;/<span class="name">CreateCommand</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CreateCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27;!= &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>if [! -d <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span> ]; then mkdir -p <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span>; fi<span class="tag">&lt;/<span class="name">CreateCommand</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">&quot;$(CreateCommand)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="命令行构建"><a href="#命令行构建" class="headerlink" title="命令行构建"></a>命令行构建</h2><p>对于单个dotnet项目，可使用以下命令构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">项目文件携带环境变量的情况</span></span><br><span class="line">MSBuild [project file] /p:PropertyName=Value</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">MSBuild test.csproj /p:IS_Integrated = true</span><br></pre></td></tr></table></figure><h2 id="批处理构建"><a href="#批处理构建" class="headerlink" title="批处理构建"></a>批处理构建</h2><p>对于模块较多的dotnet项目，可使用批处理脚本批量构建，并跟踪构建情况</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> totalCount=<span class="number">14</span></span><br><span class="line"><span class="built_in">set</span> failCount=<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> failList=&quot;&quot;</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> your/test.sln/<span class="built_in">path</span></span><br><span class="line"><span class="built_in">echo</span> 正在构建test模块[进度 <span class="number">1</span>/<span class="variable">%totalCount%</span>]...</span><br><span class="line">dotnet build test.sln  &gt; <span class="built_in">nul</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorlevel%</span> <span class="keyword">neq</span> <span class="number">0</span> (</span><br><span class="line">    <span class="built_in">echo</span> test模块构建失败</span><br><span class="line">    <span class="built_in">set</span> /a failCount=failCount + <span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span> failList=&quot;<span class="variable">%failList%</span> test&quot;</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> test模块已构建成功！</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> /a successCount=<span class="variable">%totalCount%</span> - <span class="variable">%failCount%</span></span><br><span class="line"><span class="built_in">set</span> /p DUMMY=构建成功<span class="variable">%successCount%</span>个，失败<span class="variable">%failCount%</span>个，失败的模块有[<span class="variable">%failList%</span>]，请尝试手动构建，按回车键继续...</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link"   href="https://learn.microsoft.com/zh-cn/cpp/build/reference/common-macros-for-build-commands-and-properties" >用于MSBuild命令和属性的常用宏<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/msbuild-properties" >MSBuild 属性说明<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/xcopy" >xcopy命令参数说明<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于.NET的MSBuild常用命令记录。&lt;/p&gt;</summary>
    
    
    
    <category term="Package-Tool" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Package-Tool/"/>
    
    
    <category term="MSBuild" scheme="https://jocoboy.github.io/Hexo-Blog/tags/MSBuild/"/>
    
  </entry>
  
  <entry>
    <title>Oracle常用SQL、PL/SQL语句</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/11/29/oracle-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/11/29/oracle-usage/</id>
    <published>2024-11-29T07:48:14.000Z</published>
    <updated>2025-08-01T09:27:22.791Z</updated>
    
    <content type="html"><![CDATA[<p>Oracle数据库的适用场景，以及一些常用SQL、PL&#x2F;SQL语句。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Oracle是由Oracle公司开发和维护的商业数据库管理系统，使用Oracle数据库通常需要购买许可证，价格因版本、功能、用户数量等因素而异。它主要面向对数据安全、性能和稳定性要求极高的大型企业、金融机构、电信公司等，这些企业愿意为高端的数据库解决方案支付较高的成本。Oracle在数据库技术和Java之间进行了大量的技术整合，Java是Oracle生态系统中企业级应用开发的核心语言，在企业资源规划（ERP）系统、客户关系管理（CRM）系统等大型企业应用中具有重要地位。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>Oracle数据库有以下性能特点和功能特性：</p><ul><li>处理复杂查询：Oracle在处理复杂的企业级查询和大规模数据操作方面表现卓越。</li><li>并发处理：Oracle采用多版本并发控制（MVCC）机制来处理高并发事务，同时还具备强大的锁机制来确保数据的一致性和完整性。在高并发的 OLTP（联机事务处理）环境下，如银行的网上交易系统，大量用户同时进行账户查询、转账等操作时，Oracle 能够有效地协调并发事务，避免数据冲突。</li><li>数据存储和读写性能：Oracle在存储结构上有多种存储选项，如自动存储管理（ASM）等，可以根据不同的应用场景和数据类型优化存储性能。</li><li>数据类型和扩展性：Oracle支持丰富的内置数据类型，包括基本数据类型以及复杂的数据类型（如XMLTYPE用于处理XML数据）。在扩展性方面，Oracle 提供了诸如分区表、索引组织表等功能来提高数据管理的效率。</li><li>备份和恢复功能：Oracle提供了一套完整的备份和恢复解决方案，包括物理备份和逻辑备份。它还支持闪回技术，可以在一定程度上快速恢复数据到某个时间点，这在应对数据误操作等情况时非常有用。</li><li>安全机制：Oracle具有高度复杂的安全体系，包括用户认证、授权、角色管理、数据加密等多个层面。它可以通过细粒度的权限控制，对不同用户和角色访问不同的数据对象和操作进行严格的限制。</li></ul><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>在Oracle数据库中，模式是一个逻辑概念，它是一组数据库对象（如表、视图、存储过程、函数、序列等）的集合。可以将模式看作是一个用户所拥有的对象的容器，每个模式都与一个数据库用户相关联。</p><h4 id="使用CREATE-SCHEMA语句直接创建"><a href="#使用CREATE-SCHEMA语句直接创建" class="headerlink" title="使用CREATE SCHEMA语句直接创建"></a>使用CREATE SCHEMA语句直接创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有用户</span></span><br><span class="line"><span class="keyword">SELECT</span> USERNAME, USER_ID, ACCOUNT_STATUS <span class="keyword">FROM</span> DBA_USERS;</span><br><span class="line"><span class="comment">-- 查询当前用户</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span> <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 授权创建模式的系统权限给用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> SCHEMA <span class="keyword">TO</span> test_user;</span><br><span class="line"><span class="comment">-- 创建模式并授权所有者</span></span><br><span class="line"><span class="keyword">CREATE</span> SCHEMA new_schema <span class="keyword">AUTHORIZATION</span> test_user;</span><br></pre></td></tr></table></figure><h4 id="通过创建用户隐式创建模式"><a href="#通过创建用户隐式创建模式" class="headerlink" title="通过创建用户隐式创建模式"></a>通过创建用户隐式创建模式</h4><p>当创建一个新用户时，如果这个用户开始创建数据库对象（如创建表、视图等），Oracle会自动为这个用户创建一个与用户同名的模式来存放这些对象。</p><p>在Oracle容器数据库（CDB）架构中，包含一个根容器（CDB$ROOT）和多个可插拔数据库（PDB）。公用用户是可以在CDB的公共部分或者多个PDB中访问的用户。这些用户用于管理跨越多个PDB的公共资源或执行通用的管理任务。创建公用用户的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> C##test_user IDENTIFIED <span class="keyword">BY</span> test_password;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> SESSION <span class="keyword">TO</span> C##test_user;</span><br></pre></td></tr></table></figure><p>创建本地用户则需要切换当前会话到指定的PDB中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在容器数据库（CDB）中查看可插拔数据库（PDB）</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> v$pdbs;</span><br><span class="line"><span class="comment">-- 换到目标 PDB</span></span><br><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> CONTAINER <span class="operator">=</span> pdb1; </span><br><span class="line"><span class="comment">-- PDB中创建本地用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> new_schema_user IDENTIFIED <span class="keyword">BY</span> schema_password;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> SESSION <span class="keyword">TO</span> new_schema_user;</span><br></pre></td></tr></table></figure><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是Oracle数据库中用于存储数据库对象（如表、索引等）的逻辑存储区域，后续创建的数据库对象可以指定存放在表空间里。</p><h4 id="表空间操作"><a href="#表空间操作" class="headerlink" title="表空间操作"></a>表空间操作</h4><p>创建表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE tablespace_name</span><br><span class="line">DATAFILE <span class="string">&#x27;datafile_path&#x27;</span> SIZE size_value;</span><br></pre></td></tr></table></figure><p>例如创建名为WORKHUB的表空间，并设置大小为50M</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE &quot;WORKHUB&quot;</span><br><span class="line">DATAFILE <span class="string">&#x27;WORKHUB.dbf&#x27;</span> SIZE <span class="number">50</span>M </span><br></pre></td></tr></table></figure><p>修改表所在空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MOVE TABLESPACE new_tablespace_name;</span><br></pre></td></tr></table></figure><p>修改用户在特定表空间中的配额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> user_name QUOTA new_quota_size <span class="keyword">ON</span> tablespace_name;</span><br></pre></td></tr></table></figure><p>表空间参数组合使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> schema_name.table_name (</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">TABLESPACE &quot;WORKHUB&quot; <span class="comment">-- 定义了表空间的名称为 “WORKHUB”</span></span><br><span class="line">LOGGING <span class="comment">-- 启用日志记录功能</span></span><br><span class="line">NOCOMPRESS <span class="comment">-- 数据不进行压缩存储</span></span><br><span class="line">PCTFREE <span class="number">10</span> <span class="comment">-- 每个数据块中，会预留 10% 的空间作为空闲区域</span></span><br><span class="line">INITRANS <span class="number">1</span> <span class="comment">-- 每个数据块初始分配的事务入口数量为1</span></span><br><span class="line">STORAGE ( <span class="comment">-- 表空间存储相关参数的详细设置</span></span><br><span class="line">  <span class="keyword">INITIAL</span> <span class="number">65536</span>  <span class="comment">-- 指定了表空间的初始大小为 65536 * 8KB = 512MB</span></span><br><span class="line">  NEXT <span class="number">1048576</span> <span class="comment">-- 当表空间需要扩展时，每次扩展增加的大小为1048576 * 8KB = 8GB</span></span><br><span class="line">  MINEXTENTS <span class="number">1</span> <span class="comment">-- 表示表空间最初创建时至少包含的扩展次数为1</span></span><br><span class="line">  MAXEXTENTS <span class="number">2147483645</span> <span class="comment">-- 表空间最多可以扩展的次数为无限</span></span><br><span class="line">  BUFFER_POOL <span class="keyword">DEFAULT</span> <span class="comment">-- 指定该表空间使用默认的缓冲池</span></span><br><span class="line">)</span><br><span class="line">PARALLEL <span class="number">1</span> <span class="comment">-- 表示对这个表空间中数据的并行处理程度，最多可以启用 1 个并行执行服务器来协助处理任务</span></span><br><span class="line">NOCACHE <span class="comment">-- 指定了该表空间中的数据块在被读取到内存（缓冲池）后，不会被缓存起来用于后续的重复访问</span></span><br><span class="line">DISABLE <span class="type">ROW</span> MOVEMENT <span class="comment">-- 禁止行移动功能</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>场景：表中某个字段可能有重复值出现，对于重复出现的记录，根据创建时间只选取首次出现的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME, P_ID</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> t.<span class="operator">*</span>,</span><br><span class="line">            <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> P_ID <span class="keyword">ORDER</span> <span class="keyword">BY</span> CRT_TIME) <span class="keyword">AS</span> row_num</span><br><span class="line">    <span class="keyword">FROM</span> [schema_name].[table_name] t</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> row_num <span class="operator">=</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h2 id="PL-SQL语句"><a href="#PL-SQL语句" class="headerlink" title="PL&#x2F;SQL语句"></a>PL&#x2F;SQL语句</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>PL&#x2F;SQL（Procedural Language&#x2F;Structured Query Language）是Oracle数据库系统的过程化编程语言。它是一种块结构语言，将 SQL语句的强大数据处理能力与过程化编程语言的流程控制结构相结合。这使得开发人员可以在数据库内部编写复杂的业务逻辑，而不仅仅是执行简单的查询操作。由于PL&#x2F;SQL程序是在数据库服务器内部执行，减少了数据在客户端和服务器之间的传输，从而提高了性能。特别是对于复杂的数据库操作和大量的数据处理，这种优势更加明显。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h4 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h4><p>PL&#x2F;SQL程序由块（Block）组成，每个块都有一个声明部分、执行部分和可选的异常处理部分。声明部分用于定义变量、常量、游标等；执行部分包含了要执行的SQL语句和PL&#x2F;SQL语句，用于实现具体的业务逻辑；异常处理部分用于处理程序执行过程中可能出现的错误。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    <span class="comment">-- 声明部分，定义变量</span></span><br><span class="line">    v_count NUMBER;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 执行部分，查询并赋值</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> v_count <span class="keyword">FROM</span> employees;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;员工总数为：&#x27;</span> <span class="operator">||</span> v_count);</span><br><span class="line">EXCEPTION</span><br><span class="line">    <span class="comment">-- 异常处理部分，处理可能的错误</span></span><br><span class="line">    <span class="keyword">WHEN</span> NO_DATA_FOUND <span class="keyword">THEN</span></span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;未找到数据。&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h4><p>条件语句包括IF - THEN - ELSE语句用于根据条件执行不同的代码块。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF <span class="keyword">condition</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="comment">-- 条件为真时执行的语句</span></span><br><span class="line">ELSIF another_condition <span class="keyword">THEN</span></span><br><span class="line">    <span class="comment">-- 另一个条件为真时执行的语句</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="comment">-- 所有条件为假时执行的语句</span></span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure><p>循环语句有LOOP、WHILE - LOOP和FOR - LOOP等多种循环结构。例如，使用FOR - LOOP来遍历一个查询结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name) LOOP</span><br><span class="line">    <span class="comment">-- 对每一行数据进行操作</span></span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br></pre></td></tr></table></figure><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程：是一组预编译的PL&#x2F;SQL语句，存储在数据库中，可以被调用以执行特定的任务。存储过程可以接受参数，并且可以包含复杂的业务逻辑和数据库操作。例如，使用存储过程向employees表中插入一条新员工记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> insert_employee(</span><br><span class="line">    p_name VARCHAR2,</span><br><span class="line">    p_salary NUMBER</span><br><span class="line">) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, salary) <span class="keyword">VALUES</span> (p_name, p_salary);</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>存储过程可以结合块结构和控制结构，实现批量插入随机数据，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入随机数据(存储过程)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> batch_insert_users(</span><br><span class="line">    total <span class="keyword">IN</span> NUMBER <span class="keyword">DEFAULT</span> <span class="number">2</span></span><br><span class="line">) <span class="keyword">AS</span></span><br><span class="line">    <span class="comment">-- 定义变量</span></span><br><span class="line">    v_id ADMIN_USER.ID<span class="operator">%</span>TYPE;</span><br><span class="line">    v_name ADMIN_USER.NAME<span class="operator">%</span>TYPE;</span><br><span class="line">    v_gender ADMIN_USER.GENDER<span class="operator">%</span>TYPE;</span><br><span class="line">    v_pid ADMIN_USER.P_ID<span class="operator">%</span>TYPE;</span><br><span class="line">    v_orgcode ADMIN_USER.ORG_CODE<span class="operator">%</span>TYPE;</span><br><span class="line"></span><br><span class="line">    gender NUMBER :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    v_counter NUMBER :<span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 循环计数器</span></span><br><span class="line">    v_max NUMBER :<span class="operator">=</span> total; <span class="comment">-- 最大插入条数</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 循环插入数据</span></span><br><span class="line">    WHILE v_counter <span class="operator">&lt;=</span> v_max LOOP</span><br><span class="line">        v_id :<span class="operator">=</span> random_alphanum(<span class="number">6</span>); <span class="comment">-- 随机六位字符(包含大小写字母、数字)</span></span><br><span class="line">        v_name :<span class="operator">=</span> random_chinese_name(); <span class="comment">-- 随机两位或三位姓名</span></span><br><span class="line">        gender :<span class="operator">=</span> ROUND(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        v_pid :<span class="operator">=</span> simple_random_id_card(gender); <span class="comment">-- 随机身份证号</span></span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">&#x27;2&#x27;</span> </span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;1&#x27;</span> </span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> res <span class="keyword">INTO</span> v_gender; <span class="comment">-- 随机性别(1男性2女性)</span></span><br><span class="line">        <span class="keyword">SELECT</span> ID <span class="keyword">INTO</span> v_orgcode  <span class="comment">-- 从现有组织代码中随机挑选一个</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> ADMIN_ORG</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> DBMS_RANDOM.VALUE <span class="comment">-- 对查询结果进行随机排序</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 插入数据到表中</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> ADMIN_USER </span><br><span class="line">(ID, NAME, P_ID, ORG_CODE, GENDER) </span><br><span class="line"><span class="keyword">VALUES</span>(v_id, v_name, v_pid, v_orgcode, v_gender);</span><br><span class="line"></span><br><span class="line">        v_counter :<span class="operator">=</span> v_counter <span class="operator">+</span> <span class="number">1</span>; <span class="comment">-- 更新计数器</span></span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;成功插入&#x27;</span> <span class="operator">||</span> v_max <span class="operator">||</span> <span class="string">&#x27;条数据&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;                                   </span><br></pre></td></tr></table></figure><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数与存储过程类似，但函数必须返回一个值。函数可以用于计算并返回一个结果，这个结果可以在SQL语句中使用。例如，使用存储函数计算员工的年薪</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calculate_annual_salary(</span><br><span class="line">    p_salary NUMBER</span><br><span class="line">) <span class="keyword">RETURN</span> NUMBER <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> p_salary <span class="operator">*</span> <span class="number">12</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>存储函数中可以使用条件语句。例如，生成随机两位或三位姓名、随机身份证号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 常见姓氏数组</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> get_random_surname <span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    TYPE surname_array <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">10</span>);</span><br><span class="line">    v_surnames surname_array :<span class="operator">=</span> surname_array(</span><br><span class="line">        <span class="string">&#x27;王&#x27;</span>, <span class="string">&#x27;李&#x27;</span>, <span class="string">&#x27;张&#x27;</span>, <span class="string">&#x27;刘&#x27;</span>, <span class="string">&#x27;陈&#x27;</span>, <span class="string">&#x27;杨&#x27;</span>, <span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;黄&#x27;</span>, <span class="string">&#x27;周&#x27;</span>, <span class="string">&#x27;吴&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;徐&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;胡&#x27;</span>, <span class="string">&#x27;朱&#x27;</span>, <span class="string">&#x27;高&#x27;</span>, <span class="string">&#x27;林&#x27;</span>, <span class="string">&#x27;何&#x27;</span>, <span class="string">&#x27;郭&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;罗&#x27;</span></span><br><span class="line">    );</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> v_surnames(TRUNC(DBMS_RANDOM.VALUE(<span class="number">1</span>, v_surnames.COUNT <span class="operator">+</span> <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 随机名字生成</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> random_chinese_name <span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    v_name VARCHAR2(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    v_name :<span class="operator">=</span> get_random_surname;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 60%概率单字名，40%双字名</span></span><br><span class="line">    IF DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">1</span>) <span class="operator">&lt;</span> <span class="number">0.6</span> <span class="keyword">THEN</span></span><br><span class="line">        v_name :<span class="operator">=</span> v_name <span class="operator">||</span> UNISTR(<span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> LPAD(TO_CHAR(<span class="number">19968</span> <span class="operator">+</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">500</span>)), <span class="string">&#x27;FMXXXX&#x27;</span>), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        v_name :<span class="operator">=</span> v_name <span class="operator">||</span> </span><br><span class="line">                 UNISTR(<span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> LPAD(TO_CHAR(<span class="number">19968</span> <span class="operator">+</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">500</span>)), <span class="string">&#x27;FMXXXX&#x27;</span>), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>)) <span class="operator">||</span></span><br><span class="line">                 UNISTR(<span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> LPAD(TO_CHAR(<span class="number">19968</span> <span class="operator">+</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">500</span>)), <span class="string">&#x27;FMXXXX&#x27;</span>), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">RETURN</span> v_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成随机身份证号</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> simple_random_id_card(gender NUMBER <span class="keyword">DEFAULT</span> <span class="number">0</span>) <span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    v_id_card VARCHAR2(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 1. 前6位行政区划代码（随机）</span></span><br><span class="line">    v_id_card :<span class="operator">=</span> LPAD(TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">999999</span>)), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 2. 中间8位出生日期（1980-2000年间）</span></span><br><span class="line">    v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> </span><br><span class="line">                TO_CHAR(TO_DATE(<span class="string">&#x27;1980-01-01&#x27;</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="operator">+</span> </span><br><span class="line">                TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">365</span><span class="operator">*</span><span class="number">20</span>)), <span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 3. 顺序号3位（最后一位奇数男，偶数女）</span></span><br><span class="line">    v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> LPAD(TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">99</span>)), <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>) <span class="operator">||</span> TRUNC(gender);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 4. 随机校验码（1位数字或X）</span></span><br><span class="line">    IF DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">1</span>) <span class="operator">&lt;</span> <span class="number">0.9</span> <span class="keyword">THEN</span></span><br><span class="line">        v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">RETURN</span> v_id_card;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>存储函数中也可以使用循环语句。例如，获取随机6位包含大小写字母、数字的字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> random_alphanum(p_length NUMBER <span class="keyword">DEFAULT</span> <span class="number">6</span>) </span><br><span class="line"><span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    v_chars VARCHAR2(<span class="number">62</span>) :<span class="operator">=</span> <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;</span><br><span class="line">    v_result VARCHAR2(<span class="number">4000</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    v_result :<span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.p_length LOOP</span><br><span class="line">        v_result :<span class="operator">=</span> v_result <span class="operator">||</span> SUBSTR(v_chars, </span><br><span class="line">                             <span class="built_in">MOD</span>(<span class="built_in">ABS</span>(DBMS_RANDOM.RANDOM), <span class="number">62</span>) <span class="operator">+</span> <span class="number">1</span>, </span><br><span class="line">                             <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line">    <span class="keyword">RETURN</span> v_result;</span><br><span class="line"><span class="keyword">END</span> random_alphanum;</span><br></pre></td></tr></table></figure><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="SQL-Plus"><a href="#SQL-Plus" class="headerlink" title="SQL*Plus"></a>SQL*Plus</h3><p>SQL*Plus是Oracle数据库提供的一个命令行界面的工具，用于与Oracle数据库进行交互。它允许用户输入和执行SQL语句、PL&#x2F;SQL块以及执行各种数据库管理和操作任务。比如查询数据、创建表、修改数据库对象结构等。</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>方式一：使用Easy Connection Identifier连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus system/root1234@&quot;localhost:1521/FREEPDB1&quot;</span><br></pre></td></tr></table></figure><p>方式二：使用Full Connection Identifier连接。首先需要编辑tnsnames.ora文件(以23 ai个人免费版为例，对应目录为<code>C:\app\your-username\product\23ai\dbhomeFree\network\admin</code>)，添加以下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FREEPDB1 = </span><br><span class="line"> (DESCRIPTION=</span><br><span class="line">   (ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521))</span><br><span class="line">   (CONNECT_DATA=</span><br><span class="line">      (SERVICE_NAME=FREEPDB1)</span><br><span class="line">    )</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus system/root1234@FREEPDB1</span><br></pre></td></tr></table></figure><p>.NET项目配置文件中数据库连接字符串如下，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;OracleConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User Id=system;Password=your-password;Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=FREEPDB1)));&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>方式三：使用Oracle提供的外部认证方式，以操作系统管理员身份登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure><h3 id="SQLcl"><a href="#SQLcl" class="headerlink" title="SQLcl"></a>SQLcl</h3><p>SQLcl是Oracle推出的一款现代化的命令行工具，它是基于Java开发的，在功能上可以看作是SQL*Plus的增强版，提供了更加简洁易用、功能丰富的交互界面，并且融入了很多新的特性来提升开发和管理数据库的效率。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>SQLcl需要Java 11及以上版本的JDK，Oracle在使用过JDK后就会将JDK的配置写到配置文件中，若是Oracle的环境变量配置在JDK的变量前时将会被Oracle的配置信息加载覆盖掉。若遇到Java版本切换不生效的问题，可将PATH路径中的<code>C:\Program Files\Common Files\Oracle\Java\javapath</code>置于JDK变量之后。</p><p>SQL*Plus和SQLcl可执行文件一般位于<code>%ORACLE_HOME%/bin</code>目录下，以23 ai个人免费版为例，对应目录为<code>C:\app\your-username\product\23ai\dbhomeFree\bin</code>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/index.html" >Oracle数据库官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/index.html" >Oracle数据库SQL语法参考(23ai)<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/sql-developer-command-line/24.1/sqcug/working-sqlcl.html" >Oracle数据库命令行工具SQLcl使用参考<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/23/comsc/installing-sample-schemas.html" >Oracle数据库创建示例模式(23ai)<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://docs.oracle.com/en/error-help/db/" >Oracle数据库SQL报错帮助<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Oracle数据库的适用场景，以及一些常用SQL、PL&amp;#x2F;SQL语句。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Database/"/>
    
    
    <category term="Oracle" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用CLI命令及SQL语句</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/11/29/mysql-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/11/29/mysql-usage/</id>
    <published>2024-11-29T06:43:02.000Z</published>
    <updated>2025-08-01T09:27:22.789Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 数据库中的一些常用 SQL、CLI 命令，以及配置文件。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL 采用多种存储引擎，如 InnoDB 和 MyISAM 等。InnoDB 是 MySQL 默认的存储引擎，支持事务处理、行级锁和外键约束。MyISAM 存储引擎则更侧重于性能，适合以读为主的应用场景。MySQL 在简单的查询操作和高并发的读场景下，性能表现较好，但在处理复杂的嵌套查询和大规模数据写入时，性能可能会受到一定影响。MySQL 广泛应用于互联网行业的中小型应用、网站开发和云计算环境，因为它易于安装、配置和维护，能够满足大多数网站的基本数据存储和查询需求，同时拥有庞大的用户社区和丰富的文档资源及第三方工具和插件支持。</p><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>.NET 项目配置文件中数据库连接字符串如下，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;MysqlConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;userid=root;password=your-password;database=your-database;port=3306;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="MySQL-常用-CLI-命令"><a href="#MySQL-常用-CLI-命令" class="headerlink" title="MySQL 常用 CLI 命令"></a>MySQL 常用 CLI 命令</h2><h3 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h3><p>mysqld，也称为 MySQL Server，是 MySQL 数据库系统中的核心组件。它是一个服务守护进程（daemon），负责管理数据库的访问和操作。在 Linux 系统中，服务通常以“d”结尾，代表守护进程。mysqld 作为服务器端程序，它处理来自客户端程序的网络连接请求，并管理对数据库的访问。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>初始化 mysql 服务，初始化数据目录，但不生成随机密码(设置数据库空密码)，同时指定运行 mysqld 服务器的用户名为 root，端口号为 3306</p><p><code>mysqld --initialize-insecure --user=root --port=3306 --console</code></p><p>安装 mysql 服务，命名为 MySQL80，并设置默认配置文件</p><p><code>mysqld --install MySQL80 --defaults-file=C:\Program Files\MySQL\MySQL Server 8.0\my.ini</code></p><p>启动 MySQL80 服务</p><p><code>net start ANWISE-MySQL</code></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>my.ini 配置文件内容如下，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="comment"># 配置免密登录 (可选)</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">password</span>=your_passowrd</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">basedir</span>=C:\Program Files\MySQL\MySQL Server <span class="number">8.0</span></span><br><span class="line"><span class="attr">datadir</span>=C:\Program Files\MySQL\MySQL Server <span class="number">8.0</span>\data</span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="attr">default-storage-engine</span>=InnoDB</span><br><span class="line"><span class="attr">log_timestamps</span>=SYSTEM</span><br><span class="line"><span class="attr">innodb_page_size</span>=<span class="number">64</span>K</span><br><span class="line"><span class="attr">max_allowed_packet</span>=<span class="number">1</span>G</span><br><span class="line"><span class="comment"># 配置sql_mode (可选)</span></span><br><span class="line"><span class="attr">sql_mode</span>=<span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>mysql 是 MySQL 自带的命令行客户端程序，用于交互式输入 SQL 语句或以批处理模式从文件执行它们。</p><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><p>登录 mysql</p><p><code>mysql -u root -P 3306</code></p><p>修改 mysql 密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;your_passowrd&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">flush privileges;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">quit;</span></span><br></pre></td></tr></table></figure><p>查看所有数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">show databases;</span></span><br></pre></td></tr></table></figure><p>执行SQL文件(需要在控制台中将字符编码设置为UTF-8)</p><p><code>chcp 65001</code></p><p><code>mysql -uroot -p[your_passowrd] -D[your_databse] &lt; [your_script].sql</code></p><h2 id="MySQL-常用-SQL"><a href="#MySQL-常用-SQL" class="headerlink" title="MySQL 常用 SQL"></a>MySQL 常用 SQL</h2><h3 id="CREATE-GRANT"><a href="#CREATE-GRANT" class="headerlink" title="CREATE&#x2F;GRANT"></a>CREATE&#x2F;GRANT</h3><p>CREATE 可用于创建库名和用户名，配合GRANT可以在创建用户的同时赋予权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库名</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `demo` <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8mb4&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8mb4_unicode_ci&#x27;</span>;</span><br><span class="line"><span class="comment">-- 创建用户并赋予权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> test@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> demo.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;                </span><br></pre></td></tr></table></figure><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>获取数据库中所有 TRUNCATE 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">CONCAT(<span class="string">&#x27;TRUNCATE TABLE &#x27;</span>, table_schema, <span class="string">&#x27;.&#x27;</span>, TABLE_NAME, <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">table_schema <span class="keyword">IN</span> (<span class="string">&#x27;db_name&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="TRUNCATE-DROP-DELETE"><a href="#TRUNCATE-DROP-DELETE" class="headerlink" title="TRUNCATE&#x2F;DROP&#x2F;DELETE"></a>TRUNCATE&#x2F;DROP&#x2F;DELETE</h3><p>TRUNCATE 只能操作表，将表中数据全部删除，在功能上和不带 WHERE 子句的 DELETE 语句相同，但是 TRUNCATE 会释放表空间，且不能回滚事务。TRUNCATE 一般会配合禁用&#x2F;启动外键约束的语句使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 禁用外键约束</span></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [table_name]</span><br><span class="line"><span class="comment">-- 开启外键约束</span></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>DROP 将删除表的结构，以及被依赖的约束、触发器、索引。DROP 执行速度最快。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [table_name]</span><br></pre></td></tr></table></figure><p>DELETE 将表中数据全部删除，但是不会释放表空间，可以回滚事务。DELETE 执行速度最慢。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> [table_name]</span><br></pre></td></tr></table></figure><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>举例，对 int 类型的字段值进行转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储函数</span></span><br><span class="line">DELIMITER  <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> IF <span class="keyword">EXISTS</span> convert_function <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> convert_function([var_name] <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> res <span class="type">INT</span>;</span><br><span class="line">IF [var_name]  <span class="operator">=</span> <span class="number">100</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">SET</span> res <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">RETURN</span> res;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储函数</span></span><br><span class="line"><span class="keyword">SELECT</span> convert_function(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>mysql支持对类型为json的字段值进行操作，例如修改类型为<strong>json</strong>的字段中的某个属性值，需要调用JSON_SET和JSON_EXTRACT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [table_name] t</span><br><span class="line"><span class="keyword">SET</span> t.json <span class="operator">=</span> JSON_SET(t.json, <span class="string">&#x27;$.myProperty&#x27;</span>, convert_function(JSON_EXTRACT(t.json, <span class="string">&#x27;$.myProperty&#x27;</span>)));</span><br></pre></td></tr></table></figure><p>举例，修改类型为<strong>json数组</strong>的字段中的某个属性值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> update_json_array <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_json_array()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> json_index <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> json_length <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> current_id <span class="type">char</span>(<span class="number">36</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> current_json JSON;</span><br><span class="line">    <span class="keyword">DECLARE</span> cursor_json <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">        <span class="keyword">SELECT</span> id, json <span class="keyword">FROM</span> [table_name];</span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">OPEN</span> cursor_json;</span><br><span class="line">    read_loop: LOOP</span><br><span class="line">        <span class="keyword">FETCH</span> cursor_json <span class="keyword">INTO</span> current_id, current_json;</span><br><span class="line">        IF done <span class="keyword">THEN</span></span><br><span class="line">            LEAVE read_loop;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">        <span class="keyword">SET</span> json_length <span class="operator">=</span> JSON_LENGTH(current_json);</span><br><span class="line">        WHILE json_index <span class="operator">&lt;</span> json_length DO</span><br><span class="line">            <span class="comment">-- 更新json数组中每个对象的属性值</span></span><br><span class="line">            <span class="keyword">SET</span> current_json <span class="operator">=</span> JSON_SET(current_json,</span><br><span class="line">                CONCAT(<span class="string">&#x27;$[&#x27;</span>, json_index, <span class="string">&#x27;].myProperty&#x27;</span>), convert_function(JSON_EXTRACT(current_json, CONCAT(<span class="string">&#x27;$[&#x27;</span>, json_index, <span class="string">&#x27;].myProperty&#x27;</span>))));</span><br><span class="line">            <span class="keyword">SET</span> json_index <span class="operator">=</span> json_index <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 更新表中的记录</span></span><br><span class="line">        <span class="keyword">UPDATE</span> [table_name]</span><br><span class="line">        <span class="keyword">SET</span> files <span class="operator">=</span> current_json</span><br><span class="line">        <span class="keyword">WHERE</span> id <span class="operator">=</span> current_id;</span><br><span class="line">        <span class="keyword">SET</span> json_index <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line">    <span class="keyword">CLOSE</span> cursor_json;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> update_json_array();</span><br></pre></td></tr></table></figure><h3 id="全局参数修改"><a href="#全局参数修改" class="headerlink" title="全局参数修改"></a>全局参数修改</h3><blockquote><p>Error Code: 1418. This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you <em>might</em> want to use the less safe log_bin_trust_function_creators variable)</p></blockquote><p>出现如上报错，需要修改<code>log_bin_trust_function_creators</code>的值为true，<code>log_bin_trust_function_creators</code>控制是否可以信任存储函数创建者，不会创建写入二进制日志引起不安全事件的存储函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="literal">TRUE</span>;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a class="link"   href="https://mysql.net.cn/doc/refman/8.0/en/" >MySQL 官方中文文档<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL 数据库中的一些常用 SQL、CLI 命令，以及配置文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Database/"/>
    
    
    <category term="MySQL" scheme="https://jocoboy.github.io/Hexo-Blog/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于PGSQL咨询锁函数实现的分布式锁</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/30/pgsql-distributed-lock/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/30/pgsql-distributed-lock/</id>
    <published>2024-08-30T11:45:42.000Z</published>
    <updated>2025-08-01T09:27:22.791Z</updated>
    
    <content type="html"><![CDATA[<p>基于PGSQL咨询锁函数实现的一个分布式锁基础设施。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostgreSQL提供了分布式锁服务，可以用于多个数据库实例(会话)之间协调访问资源。通过使用pg_advisory_lock等咨询锁函数，可以实现一个由应用定义其含义的分布式锁基础设施。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>锁的一种宏观分类方式是悲观锁和乐观锁。乐观锁和悲观锁是并发控制的一种机制，用于多线程或多进程环境下对共享资源的访问管理，以防止数据不一致或竞态条件。悲观锁与乐观锁并不是特指某个锁，而是在并发情况下的两种不同策略。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁是一种对资源持有较悲观态度的锁定方式。它假设数据在并发访问时极有可能发生冲突，因此每次访问数据时都会先加锁，以确保其他线程不能访问此数据直到锁被释放。</p><p>悲观锁常见的实现方式是数据库中的行级锁、表级锁或行级锁等。一旦线程获得锁，其它尝试获取锁的线程都会被阻塞，直到锁被释放。</p><ul><li>适用场景：在高并发、数据竞争激烈的场景中使用，如金融交易、库存管理等。</li><li>缺点：<ul><li>可能导致系统吞吐量降低，因为锁定机制会阻止其他线程并发访问资源</li><li>容易产生死锁，如果锁的持有和释放管理不当，会导致系统无法继续运行</li></ul></li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁则持相对乐观的态度，假设并发操作冲突的可能性较小，因此不会主动加锁，而是进行数据版本检查来决定是否提交操作。</p><p>乐观锁一般通过版本号或时间戳等机制来实现。在数据读取时，获取当前版本号；在数据更新时，检查版本号是否与之前读取时的一致。如果一致，表示没有其他并发操作修改过数据，可以提交；否则，操作失败回滚。 </p><ul><li>适用场景：适用于读操作多、写操作少的场景，如一些阅读类应用、CMS系统等。因为这些场景下，冲突发生的概率较低，乐观锁可以提高系统的并发性。</li><li>缺点：<ul><li>在并发冲突频繁的场景下，可能会导致大量重试操作，影响性能</li><li>需要开发人员显式管理版本控制机制，增加开发复杂度</li></ul></li></ul><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>比较并替换(Compare-and-Swap)是乐观锁实现的基础。CAS操作包括三个步骤：读取内存值、比较内存值与预期值、如果相等则更新内存值。CAS锁可以有效地解决传统锁机制中的性能问题和死锁问题，是并发编程中常用的同步手段之一。</p><h3 id="线程锁、进程锁与分布式锁"><a href="#线程锁、进程锁与分布式锁" class="headerlink" title="线程锁、进程锁与分布式锁"></a>线程锁、进程锁与分布式锁</h3><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>线程锁也被称为互斥锁(Mutex)，主要用于控制同一进程中的多个线程对共享资源的访问。</p><p>在C#中，可以使用lock关键字来实现互斥锁。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lockObject = <span class="keyword">new</span> Object();</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 在需要保护共享资源的代码块中使用lock</span></span><br><span class="line">    <span class="keyword">lock</span> (lockObject)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 访问和修改共享资源的代码</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h4><p>进程锁是用于控制同一台机器上的多个进程对共享资源的访问。进程锁可以是系统级的，如文件锁；也可以是用户级的，如信号量。</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式锁是用于控制分布式系统中的多个节点对共享资源的访问。由于分布式系统中的节点可能位于不同的物理机甚至不同的地理位置，因此分布式锁的实现比线程锁和进程锁要复杂得多。分布式锁需要在网络中的多个节点之间进行协调，以保证锁的唯一性和一致性。</p><h3 id="PGSQL咨询锁"><a href="#PGSQL咨询锁" class="headerlink" title="PGSQL咨询锁"></a>PGSQL咨询锁</h3><p>PostgreSQL提供了一种由应用定义其含义的锁，这种锁被称为咨询锁(Advisory Lock)。咨询锁是一种悲观锁、分布式锁。咨询锁用一个long类型的数值或两个int类型的数值标识一把锁，long类型标识的锁和int类型标识的锁互相独立。</p><p>咨询锁有两个锁定级别：会话级和事务级。</p><ul><li>会话级锁定会持续到显式释放或会话结束，不受会话中事务的影响</li><li>事务级锁定不能显式释放，会持续锁定到事务结束</li></ul><p>不论哪个级别的锁定都是可重入的，即同一个线程在持有锁的情况下，可以多次获取该锁而不会造成死锁。</p><p>咨询锁有两种锁定模式：独占和共享。</p><ul><li>独占锁定和其它的独占锁定或共享锁定都互斥</li><li>共享锁定只和独占锁定互斥, 共享锁定之间不互斥</li></ul><p>锁定模式不受锁定级别影响，同一把锁的会话级独占锁定和事务级独占锁定会正确的互斥。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>PGSQL一共提供了21个咨询锁函数，抛开标识类型不谈，lock和unlock分别代表获取锁定和释放锁定。以_shared结尾的代表锁定是共享的而非独占的，带_xact_关键字代表锁定级别是事务级而非会话级的，带_try_关键字代表锁定是不可等待的。</p><h5 id="定义锁定模式"><a href="#定义锁定模式" class="headerlink" title="定义锁定模式"></a>定义锁定模式</h5><p>定义一个枚举作为区分锁定模式的参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 锁定模式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> LockMode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 独占</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Exclusive = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 共享</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Shared = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义咨询锁接口"><a href="#定义咨询锁接口" class="headerlink" title="定义咨询锁接口"></a>定义咨询锁接口</h5><p>会话级锁继承IDisposable接口，以便数据库连接等资源的释放。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISessionLock</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义不同标识类型、不同会话级别下的咨询锁接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAdvisoryLock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对long类型的数值标识的锁进行会话级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对由两个int类型的数值标识的锁进行会话级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对long类型的数值标识的锁进行事务级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对由两个int类型的数值标识的锁进行事务级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现会话级锁的显示释放"><a href="#实现会话级锁的显示释放" class="headerlink" title="实现会话级锁的显示释放"></a>实现会话级锁的显示释放</h5><p>由于会话级锁定会持续到显式释放或会话结束，需要实现显示释放。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PGSQLSessionLock</span> : <span class="title">ISessionLock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> DatabaseFacade database;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">long</span>? kid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>? mid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>? nid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isShare;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLSessionLock</span>(<span class="params">DatabaseFacade database, <span class="built_in">long</span> kid, <span class="built_in">bool</span> isShare</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">        <span class="keyword">this</span>.kid = kid;</span><br><span class="line">        <span class="keyword">this</span>.isShare = isShare;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLSessionLock</span>(<span class="params">DatabaseFacade database, <span class="built_in">int</span> mid, <span class="built_in">int</span> nid, <span class="built_in">bool</span> isShare</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">        <span class="keyword">this</span>.mid = mid;</span><br><span class="line">        <span class="keyword">this</span>.nid = nid;</span><br><span class="line">        <span class="keyword">this</span>.isShare = isShare;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReleaseLock</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShare)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kid != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock_shared(&#123;0&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; kid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock_shared(&#123;0&#125;,&#123;1&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; mid.Value, nid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kid != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock(&#123;0&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; kid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock(&#123;0&#125;,&#123;1&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; mid.Value, nid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReleaseLock();</span><br><span class="line">            database = <span class="literal">null</span>;</span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~PGSQLSessionLock()</span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现咨询锁"><a href="#实现咨询锁" class="headerlink" title="实现咨询锁"></a>实现咨询锁</h5><p>实现不同锁定标识、不同锁定级别下的咨询锁函数，每个咨询锁函数定义了锁定标识、锁定模式、是否可等待参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PGSQLAdvisoryLock</span> : <span class="title">IAdvisoryLock</span>, <span class="title">ISingletonDependency</span></span><br><span class="line">&#123;</span><br><span class="line">    IDbContextProvider&lt;ABPDemoDbContext&gt; _dbContextProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLAdvisoryLock</span>(<span class="params">IDbContextProvider&lt;ABPDemoDbContext&gt; dbContextProvider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _dbContextProvider = dbContextProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> locked = <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; k &#125;, lockMode, waiting, <span class="literal">false</span>, database, cancellationToken);</span><br><span class="line"></span><br><span class="line">        ISessionLock result = locked ? <span class="keyword">new</span> PGSQLSessionLock(database, k, lockMode == LockMode.Shared) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> locked = <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; m, n &#125;, lockMode, waiting, <span class="literal">false</span>, database, cancellationToken);</span><br><span class="line"></span><br><span class="line">        ISessionLock result = locked ? <span class="keyword">new</span> PGSQLSessionLock(database, m, n, lockMode == LockMode.Shared) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; k &#125;, lockMode, waiting, <span class="literal">true</span>, database, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; m, n &#125;, lockMode, waiting, <span class="literal">true</span>, database, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">InternalLockAsync</span>(<span class="params"><span class="built_in">object</span>[] parameters, LockMode lockMode, <span class="built_in">bool</span> waiting, <span class="built_in">bool</span> isXact, DatabaseFacade database, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> locked;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> xact = isXact ? <span class="string">&quot;_xact&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> param = parameters.Length == <span class="number">1</span> ? <span class="string">&quot;&#123;0&#125;&quot;</span> : <span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mode = lockMode <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            LockMode.Exclusive =&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">            LockMode.Shared =&gt; <span class="string">&quot;_shared&quot;</span>,</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">$&quot;LockMode.<span class="subst">&#123;lockMode&#125;</span> is not implemented.&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waiting)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> database.ExecuteSqlRawAsync(<span class="string">$&quot;select pg_advisory<span class="subst">&#123;xact&#125;</span>_lock<span class="subst">&#123;mode&#125;</span>(<span class="subst">&#123;param&#125;</span>)&quot;</span>, parameters);</span><br><span class="line"></span><br><span class="line">            locked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            locked = (<span class="keyword">await</span> database.SqlQueryRaw&lt;<span class="built_in">bool</span>&gt;(<span class="string">$&quot;select pg_try_advisory<span class="subst">&#123;xact&#125;</span>_lock<span class="subst">&#123;mode&#125;</span>(<span class="subst">&#123;param&#125;</span>)&quot;</span>, parameters).ToListAsync()).Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h4><h5 id="在应用中定义和使用"><a href="#在应用中定义和使用" class="headerlink" title="在应用中定义和使用"></a>在应用中定义和使用</h5><p>首先定义一个锁枚举，具体名称由应用的功能派生，比如定义一个更新学生信息的锁StudentUpdate。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Locks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">long</span> StudentUpdate = <span class="number">10001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后置于并发操作上下文(替换操作之前)即可。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IAdvisoryLock _advisoryLock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentAppService</span>(<span class="params">..., IAdvisoryLock advisoryLock</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    _advisoryLock = advisoryLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">await</span> _studentRepository.GetAsync(x =&gt; x.Name == input.Name, <span class="literal">false</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> _advisoryLock.LockAsync(Locks.StudentUpdate, LockMode.Exclusive, <span class="literal">true</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line">student.Name = input.Name;</span><br><span class="line">student.StudentLevel = input.StudentLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> _studentRepository.UpdateAsync(student, <span class="literal">false</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ObjectMapper.Map&lt;Student,StudentDto&gt;(student);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="验证锁是否生效"><a href="#验证锁是否生效" class="headerlink" title="验证锁是否生效"></a>验证锁是否生效</h5><p>在LockAsync之后打上断点，调用API命中断点之后，使用SQL语句查看锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_locks t1</span><br><span class="line"><span class="keyword">JOIN</span>  pg_stat_activity t2</span><br><span class="line"><span class="keyword">ON</span> t1.pid  <span class="operator">=</span> t2.pid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.pid;</span><br></pre></td></tr></table></figure><img   src="/Hexo-Blog/2024/08/30/pgsql-distributed-lock/pgsql_pg_lock.png"  class="" title="命中断点后数据库锁的情况"><p>使用SQL语句再次获取该锁定标识对应的锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_advisory_lock(<span class="number">10001</span>);</span><br></pre></td></tr></table></figure><img   src="/Hexo-Blog/2024/08/30/pgsql-distributed-lock/pgsql_pg_lock_waiting.png"  class="" title="获取该锁定标识对应的锁"><p>可以看到该锁定标识对应的资源已被阻塞，将等待直到该资源变成可用。点击继续跳过断点之后即可再次成功获取。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a class="link"   href="http://www.postgres.cn/docs/12/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS" >PGSQL中文文档-咨询锁函数<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于PGSQL咨询锁函数实现的一个分布式锁基础设施。&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Database/"/>
    
    
    <category term=".NET" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET/"/>
    
    <category term="PostgreSQL" scheme="https://jocoboy.github.io/Hexo-Blog/tags/PostgreSQL/"/>
    
    <category term="Concurrency Control" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Concurrency-Control/"/>
    
  </entry>
  
  <entry>
    <title>加密算法在JWT、SSH中的应用</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/27/jwt-and-ssh/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/27/jwt-and-ssh/</id>
    <published>2024-08-27T11:44:50.000Z</published>
    <updated>2025-08-01T09:27:22.785Z</updated>
    
    <content type="html"><![CDATA[<p>对称加密、非对称加密算法在不同场景中的应用，如使用JWT进行单点登录、使用SSH进行远程免密登录等。</p><span id="more"></span><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是一种加密和解密所使用的密钥是相同的加密算法。在对称加密中，发送方和接收方使用相同的密钥对数据进行加密和解密。常见的对称加密算法包括DES、3DES、AES等。</p><p>对称加密的优势在于速度快，加解密过程简单，适合用于传输大量数据。但是对称加密无法提供身份验证和数据完整性保护，即无法判断消息的发送方是否可信以及数据是否被篡改。</p><p>对称加密通常与其他的加密技术(如数字签名、消息认证码等)结合使用，以提供更高的安全性保护。</p><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>高级加密标准(Advanced Encryption Standard, 简称AES)为最常见的对称加密算法，在密码学中又称Rijndael加密法。AES算是Rijndael算法的一种特殊实现，选的分组为128bit（16字节），密钥可以使用128、192和256bit三种，而Rijndael使用的密钥和区块长度可以是32位的整数倍，以128位为下限，256比特为上限。加密过程中使用的密钥是由Rijndael密钥生成方案产生。</p><p>在AES加密中，密钥(key)、初始化向量(Initialization Vector, 简称IV)是两个重要的组成部分。此外，还可设置加密方式(Mode, 默认为CBC)和填充方式(Padding, 默认为PKCS7)，其中CBC模式需要有IV，ECB模式不需要IV。</p><ul><li><p>key</p><ul><li>定义：key是用于AES加密和解密的密钥，它是双方协商或生成的秘密信息，用于确保加密数据的安全性。</li><li>长度：AES支持多种长度的密钥，包括128位（16字节）、192位（24字节）和256位（32字节）。选择哪种长度的密钥取决于安全需求和性能考虑。</li><li>重要性：密钥的保密性至关重要，如果密钥被泄露，加密的数据就可能被解密，从而失去保护。</li></ul></li><li><p>iv</p><ul><li>定义：iv是一个随机或伪随机的值，它与密钥一起用于加密过程中的初始化。它确保了即使使用相同的密钥加密相同的明文，每次加密得到的密文也会不同，从而增强了加密的安全性。</li><li>长度：AES的iv长度通常是128位（16字节），这与AES的数据块长度相同。</li><li>重要性：iv的随机性对于防止重放攻击和统计分析攻击至关重要。使用固定的iv或可预测的iv会降低加密的安全性。</li></ul></li></ul><p>在AES加密过程中，首先会将明文分成多个128位的数据块（如果最后一个数据块不足128位，则需要进行填充，常用的填充方式包括PKCS5Padding、PKCS7Padding和ZeroPadding等）。然后，使用密钥和iv对数据进行加密。加密过程通常包括多个轮次，每轮都会执行一系列复杂的操作，如字节替换、行移位、列混合和轮密钥加等。最终，所有的数据块都被加密成密文。</p><p>以下是c#中AES加密与解密的实现方式，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> AES加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">AESEncrypt</span>(<span class="params"><span class="built_in">string</span> plainText, <span class="built_in">string</span> key, <span class="built_in">string</span> iv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">    <span class="built_in">byte</span>[] ivBytes = Encoding.UTF8.GetBytes(iv);</span><br><span class="line">    <span class="keyword">using</span> (Aes aesAlg = Aes.Create())</span><br><span class="line">    &#123;</span><br><span class="line">        aesAlg.Key = keyBytes;</span><br><span class="line">        aesAlg.IV = ivBytes;</span><br><span class="line">        aesAlg.Mode = CipherMode.CBC;</span><br><span class="line">        aesAlg.Padding = PaddingMode.PKCS7;</span><br><span class="line"></span><br><span class="line">        ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, encryptor, CryptoStreamMode.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(cs))</span><br><span class="line">                &#123;</span><br><span class="line">                    sw.Write(plainText);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Convert.ToBase64String(ms.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> AES加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">AESDecrypt</span>(<span class="params"><span class="built_in">string</span> cipherText, <span class="built_in">string</span> key, <span class="built_in">string</span> iv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">    <span class="built_in">byte</span>[] ivBytes = Encoding.UTF8.GetBytes(iv);</span><br><span class="line">    <span class="built_in">byte</span>[] cipherBytes = Convert.FromBase64String(cipherText);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Aes aesAlg = Aes.Create())</span><br><span class="line">    &#123;</span><br><span class="line">        aesAlg.Key = keyBytes;</span><br><span class="line">        aesAlg.IV = ivBytes;</span><br><span class="line">        aesAlg.Mode = CipherMode.CBC;</span><br><span class="line">        aesAlg.Padding = PaddingMode.PKCS7;</span><br><span class="line"></span><br><span class="line">        ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream(cipherBytes))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, decryptor, CryptoStreamMode.Read))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(cs))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> sr.ReadToEnd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密是一种加密算法，与对称加密不同，非对称加密使用一对不同的密钥来进行加密和解密。这对密钥中的一个被称为私钥(private key)，另一个被称为公钥(public key)。私钥只能由密钥的拥有者持有并保密，不对外公开，而公钥可以向任何人公开。常见的非对称加密算法包括RSA、ECC等。</p><p>在非对称加密中，加密和解密过程如下：</p><ol><li>发送方使用接收方的公钥对明文进行加密，生成密文</li><li>接收方使用自己的私钥对密文进行解密，恢复为明文</li></ol><p>非对称加密算法的特点是安全性高，能够提供身份验证和数据完整性保护。但是非对称加密的缺点是速度较慢，加解密过程相对复杂，适合处理少量的数据。</p><p>因此，通常会将对称加密和非对称加密相结合，在传输数据时使用非对称加密来交换对称加密所需的密钥，然后使用对称加密算法来加密和解密实际的数据。</p><h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>消息认证码(Message Authentication Code, 简称MAC)是一种确认完整性并进行认证的技术。</p><p>消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为MAC值。要计算MAC值必须持有共享密钥，消息认证码正是利用这一性质来完成身份认证的。此外，消息认证码通过类似单向散列函数的散列值来确保数据完整性。</p><p>HMAC是一种使用单向散列函数来构造消息认证码的方法。HMAC中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于HMAC，如果将来设计出新的单向散列函数，也同样可以使用。使用SHA-256、MD5、RIPEMD-160所构造的HMAC，分别称为HMAC-SHA-256、HMAC-MD5和HMAC-RlPEMD。</p><p>消息认证码中，由于发送者和接收者共享相同的密钥，因此会产生无法对第三方证明以及无法防止否认等问题。</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名(又称公钥数字签名)是只有信息的发送者才能产生的别人无法伪造的一段数字串。数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和非对称加密是相反的，即用私钥加密相当于生成签名，而用公钥解密则相当于验证签名。通常情况下，为了提高传输效率，不会直接对原始数据进行数字签名，而是对原始数据的Hash值进行签名。</p><p>数字签名的过程如下：</p><ol><li><p>生成签名：</p><ul><li><p>对原始数据进行哈希运算(使用预先约定的哈希算法)，得到Hash值</p></li><li><p>使用非对称加密的私钥对Hash值加密，得到签名</p></li><li><p>发送原始数据及签名</p></li></ul></li><li><p>验证签名：</p><ul><li><p>接收原始数据及签名</p></li><li><p>对数字签名使用公钥解密, 得到Hash值</p></li><li><p>对原始数据进行哈希运算得到新的Hash值，如果两者一致，则签名验证成功；如果两者不一致，则签名验证失败</p></li></ul></li></ol><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT(JSON Web Token)是目前最流行的跨域身份验证解决方案，适用于身份鉴权、授权、信息交换、单点登录等场景。JWT可以使用密钥(使用HMAC算法)或使用RSA或ECDSA的公钥&#x2F;私钥对进行签名。</p><p>应用程序获取JWT并用于访问API等资源的过程如下：</p><ol><li>客户端向授权服务器请求授权</li><li>授权服务器校验用户身份，如果校验成功，返回访问令牌(token)</li><li>应用程序使用访问令牌访问受保护的资源，服务端通过验证JWT的签名来确认用户的身份，通过解析JWT中的声明信息判断用户是否有权限执行特定的操作或访问特定的资源</li></ol><p>JWT由Header、Payload、Signature三部分组成：</p><ul><li><p>JWT的头部通常由两部分组成，分别是令牌类型(typ)和加密算法(alg)。一般情况下，头部会采用Base64编码。</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>JWT的载荷也称为声明信息(claims)，包含了一些有关实体(通常是用户)的信息以及其他元数据。通常包含预定义的字段，如iss(发行者)、sub(主题)、aud(受众)、exp(过期时间)、nbf(生效时间)、iat(发布时间)和jti(JWT ID)等，以及自定义字段。</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5a3cd526-caa4-4952-a5ba-f44245fe1762&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1681102951</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span> <span class="number">1681102951</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1681189351</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jocoboy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WebUser&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>JWT的签名是由头部、载荷和密钥(通常为32个字节)共同生成的，用于验证JWT的真实性和完整性。使用Header里面指定的签名算法(默认是HMAC-SHA256)，按照下面的公式产生签名</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload),</span><br><span class="line">secret)</span><br></pre></td></tr></table></figure></li></ul><p>.NET使用HMAC-SHA256对称加密算法生成JWT的部分代码如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> key = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_authOptions.Secret));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(key, SecurityAlgorithms.HmacSha256);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> token = <span class="keyword">new</span> JwtSecurityToken(_authOptions.Issuer,</span><br><span class="line">    _authOptions.Audience,</span><br><span class="line">    claims,</span><br><span class="line">    DateTime.Now,</span><br><span class="line">    DateTime.Now.AddMinutes(_authOptions.Expiration),</span><br><span class="line">    credentials);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(token);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>安全外壳协议(Secure Shell, 简称SSH)是一种建立在应用层基础上，在不安全网络上用于安全远程登录和其他安全网络服务的协议。</p><p>SSH建立在非对称加密之上，建立远程连接的过程如下：</p><ol><li>远程主机(虚拟机)收到本地主机的登录请求，把自己的公钥发给本地主机</li><li>本地主机使用这个公钥，将登录密码加密后，发送给远程主机</li><li>远程主机用自己的私钥，解密登录密码，如果密码正确，则同意本地主机登录</li></ol><h3 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h3><p>Linux系统中以用户名username，登录远程主机remote_host的命令如下</p><p><code>ssh username@remote_host</code></p><p>初次连接会提示公钥指纹，确认指纹无误后输入密码，远程主机的公钥就会自动保存到本地主机的.ssh&#x2F;known_hosts文件中。</p><h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>公钥登录可以省去输入密码的步骤。用户将自己的公钥储存在远程主机上，登录时远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录。</p><p>在本地主机生成一对公钥和私钥，然后将公钥添加到远程主机的 ~&#x2F;.ssh&#x2F;authorized_keys文件中(Windows系统中把.ssh&#x2F;id_rsa.pub的内容复制出来，手动追加即可)</p><p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p><p><code>ssh-copy-id username@remote_host</code></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.security.cryptography.aes" >.NET中的AES类<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://jwt.io/introduction" >JWT官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" >Generating new SSH key<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对称加密、非对称加密算法在不同场景中的应用，如使用JWT进行单点登录、使用SSH进行远程免密登录等。&lt;/p&gt;</summary>
    
    
    
    <category term="Cyber-Security" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Cyber-Security/"/>
    
    
    <category term="JWT" scheme="https://jocoboy.github.io/Hexo-Blog/tags/JWT/"/>
    
    <category term="SSH" scheme="https://jocoboy.github.io/Hexo-Blog/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>持续集成、交付与部署CI/CD及Jenkins</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/25/ci-and-cd/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/25/ci-and-cd/</id>
    <published>2024-08-25T12:41:57.000Z</published>
    <updated>2025-08-01T09:27:22.782Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成、交付与部署CI&#x2F;CD基本概念、流程，以及使用Jenkins实现自动化部署。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CI&#x2F;CD是持续集成(Continuous Integration，CI)、持续交付(Continuous Delivery，CD)与持续部署(Continuous Deployment，CD)的简称。</p><p>CI&#x2F;CD是实现敏捷开发和Devops理念的一种方法，可让持续自动化和持续监控贯穿于应用的整个生命周期。这些关联的事务通常被统称为CI&#x2F;CD管道(Pipeline)，由开发(RD)、测试(QA)、运维(OP)团队以敏捷方式协同支持。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><img   src="/Hexo-Blog/2024/08/25/ci-and-cd/ci_step.png"  class="" title="持续集成流程图"><p>持续集成(CI)指的是高频率地将代码合入主干，在合入之前触发单元测试去验证代码的改动，确保改动不会对应用造成破坏。</p><p>持续集成强调开发人员提交了新的代码后，立刻进行构建、(单元)测试。根据测试结果，我们可以确定新代码能否和原代码正确地集成在一起。</p><h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><img   src="/Hexo-Blog/2024/08/25/ci-and-cd/cd_step.png"  class="" title="持续交付流程图"><p>持续交付(CD)指的是频繁地将软件的新版本，交付给质量团队或者用户、以供评审。如果评审通过，代码就会进入生产阶段。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p><p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的类生产环境中。比如完成单元测试后，可以将代码部署到连接数据库的Staging环境中进行更多的(集成)测试。如果代码没有问题，可以继续手动部署到生产环境中。</p><h3 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><img   src="/Hexo-Blog/2024/08/25/ci-and-cd/cd_step_2.png"  class="" title="持续部署流程图"><p>持续部署(CD)是持续交付的下一步，指的是代码通过评审后，自动部署到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的自动化测试。</p><h2 id="CI-CD流程"><a href="#CI-CD流程" class="headerlink" title="CI&#x2F;CD流程"></a>CI&#x2F;CD流程</h2><p>根据CI&#x2F;CD的设计，代码从提交到生产，有以下几个步骤：</p><ul><li>提交：开发者向代码仓库提交一次代码</li><li>测试(第一轮)：代码仓库对commit操作配置了hook，只要提交了代码或者合并到主分支，就会跑自动化测试。测试的种类分为：<ul><li>单元测试(针对函数或模块的测试)</li><li>集成测试(针对产品的某个功能的测试)</li><li>端到端测试(从用户界面直达数据库的全链路测试)</li></ul></li><li>构建：将源码转换为可以运行的实际代码，如安装依赖、配置各种资源等。常用的构建工具有：<ul><li>Jenkins</li><li>Travis CI</li><li>GitLab CI&#x2F;CD</li></ul></li><li>测试(第二轮)：对第一轮测试的补充，可省略</li><li>部署：将可部署的版本中的所有文件打包到生产服务器上，生产服务器将打包文件解包成本地目录，再将运行路径符号链接指向这个目录，然后重新启动应用。</li><li>回滚：一但当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法是修改链接符号，指向上一个版本的目录</li></ul><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>Jenkins是一个开源的实现持续集成的工具。Jenkins能实时监控集成中的存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式展示项目构建的趋势和稳定性。</p><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><p>使用Docker下载Jenkins镜像</p><p><code>docker pull jenkins/jekins:lts</code></p><p>创建目录并更改权限</p><p><code>mkdir -p /mydata/jenkins_home</code></p><p><code>chmod 777 /mydata/jenkins_home</code></p><p>运行Jenkins容器</p><p><code>docker run -di --name=jenkins -p [host-port]:[container-port] -v /mydata/jenkins_home/:/var/jenkins_home/ jenkins/jekins:lts</code></p><p>查看Jenkins运行是否成功</p><p><code>docker ps -a</code></p><h3 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h3><p>通过docker启动日志获取Jenkins控制台解锁密码</p><p><code>docker logs jenkins</code></p><p>输入解锁密码后填写信息创建一个管理员用户。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>可通过Jenkins控制台的系统管理&gt;插件管理在线安装插件，也可到官网下载hpi插件文件然后上传使用。</p><h3 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h3><p>可通过Jenkins控制台的系统管理&gt;全局工具配置，配置JDK、Git、Maven等运行环境。</p><h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><ul><li>通过Jenkins控制台安装SSH插件</li><li>通过凭据&gt;全局添加服务器账号密码的凭据</li><li>通过系统管理&gt;系统配置，添加SSH remote hosts，主机名为服务器IP，端口默认22</li></ul><h3 id="创建自动构建任务"><a href="#创建自动构建任务" class="headerlink" title="创建自动构建任务"></a>创建自动构建任务</h3><p>可通过Jenkins控制台的新建任务&gt;构建一个自由风格的软件项目新建一个任务，在源码管理添加Git远程仓库(需要添加Git账号密码凭据)，构建环境选择Delete workspace before build starts，并增加构建步骤(添加执行shell，或添加使用SSH在远程服务器上执行脚本)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">app_name=[jenkinsdemo]</span><br><span class="line"><span class="built_in">cd</span> /var/lib/jenkins/workspace/<span class="variable">$&#123;app_name&#125;</span>/[project_name]</span><br><span class="line">docker container prune &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">docker container <span class="built_in">ls</span> -a | grep <span class="string">&quot;<span class="variable">$&#123;app_name&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    docker container stop <span class="variable">$&#123;app_name&#125;</span></span><br><span class="line">    docker container <span class="built_in">rm</span> <span class="variable">$&#123;app_name&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">docker image prune &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">docker build -t <span class="variable">$&#123;app_name&#125;</span> .</span><br><span class="line">docker run -d --name=<span class="variable">$&#123;app_name&#125;</span> -p [host-port]:[container-port]  <span class="variable">$&#123;app_name&#125;</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a class="link"   href="https://www.jenkins.io/zh/doc/" >Jenkins官方文档<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续集成、交付与部署CI&amp;#x2F;CD基本概念、流程，以及使用Jenkins实现自动化部署。&lt;/p&gt;</summary>
    
    
    
    <category term="CI/CD" scheme="https://jocoboy.github.io/Hexo-Blog/categories/CI-CD/"/>
    
    
    <category term="Devops" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Devops/"/>
    
    <category term="Jenkins" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Jenkins/"/>
    
    <category term="Docker" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>基于Wix和AutoUpdater的客户端打包与自动更新</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/19/wix-toolset-and-autoupdater/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/19/wix-toolset-and-autoupdater/</id>
    <published>2024-08-19T10:46:44.000Z</published>
    <updated>2025-08-01T09:27:22.802Z</updated>
    
    <content type="html"><![CDATA[<p>使用Wix Toolset和AutoUpdater.NET实现Windows桌面应用程序的打包与自动更新功能。</p><span id="more"></span><h2 id="Wix-Toolset"><a href="#Wix-Toolset" class="headerlink" title="Wix Toolset"></a>Wix Toolset</h2><p>Wix Toolset是用来打包Windows Installer的工具集，通过编译源代码，然后链接以创建可执行文件。WiX命令行构建工具适用于任何自动化构建系统，MSBuild还支持常见的CI&#x2F;CD构建系统，如GitHub Actions。</p><p>使用WiX Bundle可以创建安装包来安装先决条件，例如.NET Framework和其他运行时环境以及自己的msi文件。WiX Bundle将他们组合成一个可下载的exe文件。</p><p>注: 以下使用的Wix Toolset版本为5.0，与低版本的语法有所区别。在Wix语法中，[]内容为库中预定义的全局变量(安装期间可使用)，$()为用户自己定义的全局变量，!(bind.)为绑定的属性，!(wix.)为Wix编译时的变量(安装期间不可使用)，!(loc.)为本地化之后的内容。</p><h3 id="Wix-Package"><a href="#Wix-Package" class="headerlink" title="Wix Package"></a>Wix Package</h3><p>Wix Package的基本功能是将应用程序打包成msi文件。此外，还支持桌面快捷方式、菜单快捷方式、卸载快捷方式添加，开机自启动，引导程序本地化等。</p><p>注: 需预先使用NuGet引入依赖包WixToolset.UI、WixToolset.Util</p><h4 id="快捷方式添加"><a href="#快捷方式添加" class="headerlink" title="快捷方式添加"></a>快捷方式添加</h4><p>Folders.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Wix</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://wixtoolset.org/schemas/v4/wxs&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义桌面快捷方式目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">StandardDirectory</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopFolder&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义菜单栏快捷方式目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">StandardDirectory</span> <span class="attr">Id</span>=<span class="string">&quot;ProgramMenuFolder&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Wix</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Package.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--桌面快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopShortcut&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">Directory</span>=<span class="string">&quot;DesktopFolder&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Installed&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--菜单栏快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;StartMenuShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;StartMenuShortcut&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">Directory</span>=<span class="string">&quot;ProgramMenuFolder&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Installed&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--卸载程序快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallProduct&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Uninstall&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[SystemFolder]msiexec.exe&quot;</span> <span class="attr">Arguments</span>=<span class="string">&quot;/x [ProductCode]&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;UninstallIcon&quot;</span> <span class="attr">Description</span>=<span class="string">&quot;Uninstall &#123;your-product-name&#125;.&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Id</span>=<span class="string">&quot;RegUninstallShortcut&quot;</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;UninstallShortcut&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="快捷方式图标设置"><a href="#快捷方式图标设置" class="headerlink" title="快捷方式图标设置"></a>快捷方式图标设置</h4><p>Package.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 引用应用程序图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">Id</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">SourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\icon.ico&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引用卸载图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallIcon&quot;</span> <span class="attr">SourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\uninstall.ico&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制面板引用应用程序图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">Id</span>=<span class="string">&quot;ARPPRODUCTICON&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> /&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><p>Package.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;Register&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryKey</span> <span class="attr">ForceCreateOnInstall</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Id</span>=<span class="string">&quot;AutoStartKey&quot;</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Id</span>=<span class="string">&quot;AutoStartKeyValue&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RegistryValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RegistryKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="卸载或更改前自动关闭程序进程"><a href="#卸载或更改前自动关闭程序进程" class="headerlink" title="卸载或更改前自动关闭程序进程"></a>卸载或更改前自动关闭程序进程</h4><p>Package.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--卸载或更改前关闭程序进程--&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">Id</span>=<span class="string">&quot;TASKKILL&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DirectorySearch</span> <span class="attr">Id</span>=<span class="string">&quot;SysDir&quot;</span> <span class="attr">Path</span>=<span class="string">&quot;[SystemFolder]&quot;</span> <span class="attr">Depth</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FileSearch</span> <span class="attr">Id</span>=<span class="string">&quot;taskkillExe&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;taskkill.exe&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DirectorySearch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:CloseApplication</span> <span class="attr">Id</span>=<span class="string">&quot;CloseApp&quot;</span> <span class="attr">CloseMessage</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">RebootPrompt</span>=<span class="string">&quot;no&quot;</span>  <span class="attr">PromptToContinue</span>=<span class="string">&quot;yes&quot;</span>  <span class="attr">Description</span>=<span class="string">&quot;!(loc.CloseBeforeUninstall)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">CustomAction</span> <span class="attr">Id</span>=<span class="string">&quot;WixCloseApplications&quot;</span> <span class="attr">Property</span>=<span class="string">&quot;TASKKILL&quot;</span> <span class="attr">Execute</span>=<span class="string">&quot;immediate&quot;</span> <span class="attr">Impersonate</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Return</span>=<span class="string">&quot;ignore&quot;</span> <span class="attr">ExeCommand</span>=<span class="string">&quot;/F /FI <span class="symbol">&amp;quot;</span>IMAGENAME eq &#123;your-product-name&#125;.exe<span class="symbol">&amp;quot;</span>&quot;</span>/&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Package.zh-cn.wxl</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WixLocalization</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://wixtoolset.org/schemas/v4/wxl&quot;</span> <span class="attr">Culture</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;<span class="name">String</span> <span class="attr">Id</span>=<span class="string">&quot;CloseBeforeUninstall&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;请关闭应用程序后再进行卸载!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">String</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">WixLocalization</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="x86和x64平台区分可执行文件源"><a href="#x86和x64平台区分可执行文件源" class="headerlink" title="x86和x64平台区分可执行文件源"></a>x86和x64平台区分可执行文件源</h4><p>Package.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Package</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Manufacturer</span>=<span class="string">&quot;$(var.Manufacturer)&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;!(bind.FileVersion.ExeFile_m2)&quot;</span> <span class="attr">UpgradeCode</span>=<span class="string">&quot;$(var.UpgradeCode)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MajorUpgrade</span> <span class="attr">DowngradeErrorMessage</span>=<span class="string">&quot;!(loc.DowngradeError)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">MediaTemplate</span> <span class="attr">EmbedCab</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Files</span> <span class="attr">Include</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\**&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Exclude</span> <span class="attr">Files</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\&#123;your-product-name&#125;.exe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Exclude</span> <span class="attr">Files</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\&#123;your-product-name&#125;_x86.exe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">Id</span>=<span class="string">&quot;ExeFile_m2&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Source</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)&#123;your-product-name&#125;_x86.exe&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">Id</span>=<span class="string">&quot;ExeFile_m1&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Source</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;VersionNT64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Package</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Wix-Bundle"><a href="#Wix-Bundle" class="headerlink" title="Wix Bundle"></a>Wix Bundle</h3><p>Wix Bundle主要用于设置系统必备组件，如各种依赖环境，可以根据目标平台区分依赖的安装包版本。此外还可引入主题文件，定制个性化安装界面。</p><p>注: 需预先使用NuGet引入依赖包WixToolset.BootstrapperApplications、WixToolset.Netfx、WixToolset.Util</p><h4 id="设置系统必备组件"><a href="#设置系统必备组件" class="headerlink" title="设置系统必备组件"></a>设置系统必备组件</h4><p>以下以.NET Core 6.0运行时和WebEdge WebView2运行时为例</p><p>Bundle.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Chain</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Define the .NET Core Runtime 6.0 dependency --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageGroupRef</span> <span class="attr">Id</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_t&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Define the Edge WebView2 Runtime dependency --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageGroupRef</span> <span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Other packages can be added here --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsiPackage</span> <span class="attr">Id</span>=<span class="string">&quot;MainPackage&quot;</span> <span class="attr">Compressed</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">SourceFile</span>= <span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\zh-CN\&#123;your-product-name&#125;.msi&quot;</span> <span class="attr">Visible</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MsiProperty</span> <span class="attr">Name</span>=<span class="string">&quot;INSTALLFOLDER&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;[InstallFolder]&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MsiPackage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Chain</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Define the package group for .NET Core Runtime 6.0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">netfx:DotNetCoreSearch</span></span></span><br><span class="line"><span class="tag"> <span class="attr">RuntimeType</span>=<span class="string">&quot;desktop&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">Platform</span>=<span class="string">&quot;x86&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">MajorVersion</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">Variable</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">netfx:DotNetCoreSearch</span></span></span><br><span class="line"><span class="tag"> <span class="attr">RuntimeType</span>=<span class="string">&quot;desktop&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">Platform</span>=<span class="string">&quot;x64&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">MajorVersion</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">Variable</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopNetCoreRuntime_6029_Redist_DetectCondition_x86&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopNetCoreRuntime_6029_Redist_DetectCondition_x64&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageGroup</span> <span class="attr">Id</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_t&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackage</span> <span class="attr">Id</span>=<span class="string">&quot;NetCoreRuntime6_x86&quot;</span> <span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.DesktopNetCoreRuntime_6029_Redist_DetectCondition_x86)&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">InstallCondition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">InstallArguments</span>=<span class="string">&quot;/install /quiet&quot;</span>&gt;</span> <span class="comment">&lt;!-- 设置静默安装 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag"><span class="attr">Name</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackage</span> <span class="attr">Id</span>=<span class="string">&quot;NetCoreRuntime6_x64&quot;</span> <span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.DesktopNetCoreRuntime_6029_Redist_DetectCondition_x64)&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">InstallCondition</span>=<span class="string">&quot;VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">InstallArguments</span>=<span class="string">&quot;/install /quiet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag"><span class="attr">Name</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PackageGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- Define the package group for Edge WebView2 Runtime --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:RegistrySearch</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\Microsoft\EdgeUpdate\Clients\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;pv&quot;</span> <span class="attr">Variable</span>=<span class="string">&quot;WVRTInstalled_x86&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:RegistrySearch</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\WOW6432Node\Microsoft\EdgeUpdate\Clients\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;pv&quot;</span> <span class="attr">Variable</span>=<span class="string">&quot;WVRTInstalled_x64&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;WV_DetectCondition_x86&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;WVRTInstalled_x86&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;WV_DetectCondition_x64&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;WVRTInstalled_x64&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageGroup</span> <span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackage</span></span></span><br><span class="line"><span class="tag"><span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper_x86&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.WV_DetectCondition_x86)&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">InstallCondition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Vital</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">CacheId</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag"><span class="attr">Name</span>=<span class="string">&quot;WV_bootstrapper_x86&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackage</span></span></span><br><span class="line"><span class="tag"><span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper_x64&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.WV_DetectCondition_x64)&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">InstallCondition</span>=<span class="string">&quot;VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Vital</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">CacheId</span>=<span class="string">&quot;2&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag"><span class="attr">Name</span>=<span class="string">&quot;WV_bootstrapper_x64&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PackageGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="定制个性化安装界面"><a href="#定制个性化安装界面" class="headerlink" title="定制个性化安装界面"></a>定制个性化安装界面</h4><p>注意: CustomTheme.xml定义了安装窗口、页面、按钮等各种UI元素以及样式、响应事件，CustomLocalize.wxl定义了个性化文本内容，具体可参照<a class="link"   href="https://github.com/wixtoolset/wix" >Wix Toolset源码<i class="fas fa-external-link-alt"></i></a></p><p>Bundle.wxs</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Bundle</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Manufacturer</span>=<span class="string">&quot;$(var.Manufacturer)&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Version</span>=<span class="string">&quot;!(bind.packageVersion.MainPackage)&quot;</span> <span class="attr">UpgradeCode</span>=<span class="string">&quot;$(var.UpgradeCode)&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">IconSourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\&#123;your-company-name&#125;.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BootstrapperApplication</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bal:WixStandardBootstrapperApplication</span> <span class="attr">LicenseUrl</span>=<span class="string">&quot;&quot;</span> <span class="attr">Theme</span>=<span class="string">&quot;rtfLargeLicense&quot;</span> <span class="attr">ShowVersion</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">LogoFile</span> =<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\&#123;your-company-name&#125;.ico&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ThemeFile</span>=<span class="string">&quot;CustomTheme.xml&quot;</span> <span class="attr">LocalizationFile</span>=<span class="string">&quot;CustomLocalize.wxl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BootstrapperApplication</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Bundle</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="AutoUpdater-NET"><a href="#AutoUpdater-NET" class="headerlink" title="AutoUpdater.NET"></a>AutoUpdater.NET</h2><p>AutoUpdater.NET是一个类库，可让.NET开发人员轻松地将自动更新功能添加到桌面应用程序项目中。AutoUpdater.NET会从服务器下载包含更新信息的XML文件。它使用该XML文件获取软件最新版本的信息。如果软件的最新版本大于用户PC上安装的软件的当前版本，AutoUpdater.NET就会向用户显示更新对话框。如果用户按下更新按钮更新软件，它就会从XML文件中提供的URL下载更新文件（安装程序），并执行刚刚下载的安装程序文件。此后，安装程序的工作就是执行更新。如果您提供的是zip文件URL而不是安装程序，AutoUpdater.NET将把zip文件的内容解压缩到应用程序目录。</p><h3 id="配置XML"><a href="#配置XML" class="headerlink" title="配置XML"></a>配置XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>&#123;your-download-url&#125;<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">changelog</span>&gt;</span>&#123;your-changelog-url&#125;<span class="tag">&lt;/<span class="name">changelog</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mandatory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">mandatory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动更新检查"><a href="#启动更新检查" class="headerlink" title="启动更新检查"></a>启动更新检查</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoUpdater.Start(<span class="string">&quot;&#123;your-xml-url&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="手动处理更新"><a href="#手动处理更新" class="headerlink" title="手动处理更新"></a>手动处理更新</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">AutoUpdater.CheckForUpdateEvent += AutoUpdaterOnCheckForUpdateEvent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AutoUpdaterOnCheckForUpdateEvent</span>(<span class="params">UpdateInfoEventArgs args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.IsUpdateAvailable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> log = <span class="keyword">await</span> httpClient.GetStringAsync(args.ChangelogURL);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> textContent = <span class="string">$&quot;当前版本<span class="subst">&#123;args.InstalledVersion&#125;</span>, 最新版本<span class="subst">&#123;args.CurrentVersion&#125;</span>\n&quot;</span> +</span><br><span class="line">                              <span class="string">&quot;有新版本可用，是否立即更新？\n&quot;</span> + <span class="string">$&quot;<span class="subst">&#123;log&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">            MessageBoxResult result = MessageBox.Show(textContent, <span class="string">&quot;更新提示&quot;</span>, MessageBoxButton.YesNo, MessageBoxImage.Information);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == MessageBoxResult.Yes)</span><br><span class="line">            &#123;</span><br><span class="line">                Close();</span><br><span class="line">                AutoUpdater.DownloadUpdate(args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (HttpRequestException e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://wixtoolset.org/docs/intro/" >Wix Toolset官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://github.com/wixtoolset/wix" >Wix Toolset开源项目地址<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://github.com/ravibpatel/AutoUpdater.NET" >AutoUpdater.NET开源项目地址<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/windows/win32/msi/properties" >Windows Installer在安装期间使用的全局变量<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Wix Toolset和AutoUpdater.NET实现Windows桌面应用程序的打包与自动更新功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Package-Tool" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Package-Tool/"/>
    
    
    <category term=".NET" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET/"/>
    
    <category term="Wix Toolset" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Wix-Toolset/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket在C#与.NET中的简单实现</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/18/websocket-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/18/websocket-usage/</id>
    <published>2024-08-18T12:53:59.000Z</published>
    <updated>2025-08-01T09:27:22.801Z</updated>
    
    <content type="html"><![CDATA[<p>WebSocket的基本概念、应用场景，以及服务端和客户端在C#与.NET中的简单实现(包含心跳检测与自动重连)。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，它可以让客户端和服务器之间进行实时的双向通信。WebSocket使用一个长连接，在客户端和服务器之间保持持久的连接，从而可以实时地发送和接收数据。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p>OSI(Open System Interconnect)七层网络模型是一种将计算机网络体系结构按照功能划分为七层的标准模型。</p><ul><li>应用层(Application Layer)，负责提供应用程序之间的通信服务，使得不同的应用程序可以在网络上进行数据交换和通信。常见协议有HTTP、HTTPS、FTP、POP3、SSH、DNS等。</li><li>表示层(Presentation Layer)，负责处理数据在网络上传输时的格式和编码，以确保不同系统之间的数据交换能够有效地进行。常见协议有JPEG、PNG、MP3等。</li><li>会话层(Session Layer)，负责建立、管理和终止应用程序之间的会话。常见协议有NetBIOS(网络基本输入&#x2F;输出系统)、RPC等。</li><li>传输层(Transport Layer)，负责在不可靠的网络上提供可靠的数据传输服务。常见协议有TCP、UDP、SSL(安全套接层协议)、TLS(传输层安全性协议)等。TCP协议面向连接、可靠，UDP协议无连接、不可靠。</li><li>网络层(Network Layer)，负责将数据包从源主机传输到目标主机。常见协议有IP等。</li><li>数据链路层(Data Link Layer)，负责将网络层传输过来的数据包进行分帧，并在物理介质上进行传输。常见协议有IEEE802.2(逻辑链路控制标准)、PPP(点对点通信)等。</li><li>物理层(Physical Layer)，负责将数字数据转换成物理信号并在网络中传输。常见协议有RS232(串行通信接口标准)、IEEE802.3(以太网标准)等。</li></ul><h3 id="串口通信与网口通信"><a href="#串口通信与网口通信" class="headerlink" title="串口通信与网口通信"></a>串口通信与网口通信</h3><p>WebSocket有串口、网口两种通信方式。</p><ul><li><p>串口方式‌主要基于串行接口进行数据传输，采用串口通信协议(如RS232、RS485等)。这种方式适用于点对点的数据传输，使用有限连接，只能连接两台设备，不支持网络中的多台设备之间的通信。串口通信传输速度较慢，传输距离较长，比较稳定，可以确保数据传输的可靠性。</p></li><li><p>网口方式‌则基于网络通信协议(如TCP&#x2F;IP、UDP等)进行数据传输。这种方式使用无限连接，适用于网络中的多台设备之间的通信。网口通信传输速度较快，传输距离有限。</p></li></ul><h3 id="与TCP和HTTP的关系"><a href="#与TCP和HTTP的关系" class="headerlink" title="与TCP和HTTP的关系"></a>与TCP和HTTP的关系</h3><p>WebSocket协议是独立的基于TCP的协议。它和HTTP的唯一关系是建立连接的握手操作的升级请求是基于HTTP服务器的。</p><p>WebSocket默认使用80端口进行连接，而基于TLS(RFC2818)的WebSocket连接是基于443端口的。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>创建一个客户端和服务端的双向数据Web应用(例如IM应用和游戏应用)需要向服务端频繁发送不同于一般HTTP请求的HTTP轮询请求来从服务端上游更新数据，这个方法存在许多问题：</p><ul><li>服务端被迫使用大量的的潜在的TCP连接与客户端进行交互：一部分是用来发送数据，而另一部分是用来接收数据</li><li>应用层无线传输协议(HTTP)开销较大，每一个客户端到服务端的消息都有一个HTTP头</li><li>客户端脚本必须包含一个发送和接收对应的映射表来进行对应数据处理</li></ul><p>一个简单的解决方案是使用一个简单的TCP链接来进行双向数据传输，这就是WebSocket提供的能力。结合WebSocket的API，它能够提供一个可以替代HTTP轮询的方法来满足Web页面和远端服务器的双向数据通信。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h3><p>C#中可以通过System.Net.WebSockets命名空间提供的类来实现WebSocket通信。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>首先创建一个WebSocket服务端类，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketServer</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serverUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpListener _httpListener;</span><br><span class="line">    <span class="keyword">private</span> WebSocket _webSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketServer</span>(<span class="params"><span class="built_in">string</span> serverUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serverUri = serverUri;</span><br><span class="line">        _httpListener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpListener.Prefixes.Add(_serverUri);</span><br><span class="line">        _httpListener.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;WebSocket服务已启动，服务地址：<span class="subst">&#123;_serverUri&#125;</span>，等待客户端连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HttpListenerContext httpContext = <span class="keyword">await</span> _httpListener.GetContextAsync();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (httpContext.Request.IsWebSocketRequest)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> HandleWebSocketConnectionAsync(httpContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                httpContext.Response.StatusCode = <span class="number">400</span>;</span><br><span class="line">                httpContext.Response.Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HandleWebSocketConnectionAsync</span>(<span class="params">HttpListenerContext httpContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WebSocketContext webSocketContext = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            webSocketContext = <span class="keyword">await</span> httpContext.AcceptWebSocketAsync(subProtocol: <span class="literal">null</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;接收到客户端连接，WebSocket连接已建立，等待客户端消息...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            httpContext.Response.StatusCode = <span class="number">500</span>;</span><br><span class="line">            httpContext.Response.Close();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;WebSocket连接失败: &quot;</span> + e.Message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _webSocket = webSocketContext.WebSocket;</span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (_webSocket.State == WebSocketState.Open)</span><br><span class="line">        &#123;</span><br><span class="line">            WebSocketReceiveResult result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">await</span> _webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket消息接收错误 :&quot;</span> + e.Message);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Close)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, CancellationToken.None);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket连接已关闭!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Text)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理文本消息</span></span><br><span class="line">                <span class="built_in">string</span> message = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;接收到客户端的消息: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">byte</span>[] response = Encoding.UTF8.GetBytes(<span class="string">&quot;服务端已成功收到消息&quot;</span> + message);</span><br><span class="line">                <span class="keyword">await</span> _webSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(response), WebSocketMessageType.Text, <span class="literal">true</span>, CancellationToken.None);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Binary)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理二进制消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _webSocket.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketServer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动WebSocket服务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;http://localhost:8181/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketServer = <span class="keyword">new</span> WebSocketServer(serverUri);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketServer.StartAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>首先创建一个WebSocket客户端类，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketClient</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClientWebSocket _clientWebSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketClient</span>(<span class="params"><span class="built_in">string</span> uri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _uri = uri;</span><br><span class="line">        _clientWebSocket = <span class="keyword">new</span> ClientWebSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _clientWebSocket.ConnectAsync(<span class="keyword">new</span> Uri(_uri), CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WebSocket客户端已连接至：&quot;</span> + _uri);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] messageBytes = Encoding.UTF8.GetBytes(input);</span><br><span class="line">            <span class="keyword">await</span> _clientWebSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(messageBytes), WebSocketMessageType.Text, <span class="literal">true</span>, CancellationToken.None);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;客户端发送消息: &quot;</span> + input);</span><br><span class="line"></span><br><span class="line">            WebSocketReceiveResult result = <span class="keyword">await</span> _clientWebSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">            <span class="built_in">string</span> response = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;客户端接收到消息: &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _clientWebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WebSocket客户端已关闭!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _clientWebSocket.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketServer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动WebSocket客户端。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;http://localhost:8181/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketClient = <span class="keyword">new</span> WebSocketClient(serverUri.Replace(<span class="string">&quot;http&quot;</span>, <span class="string">&quot;ws&quot;</span>)); <span class="comment">// http升级请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketClient.StartAsync(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="支持WSS"><a href="#支持WSS" class="headerlink" title="支持WSS"></a>支持WSS</h4><p>若要使用WebSocket Secure(WSS)，即在WebSocket上使用TLS&#x2F;SSL加密通信，则需要对服务端和客户端进行一些调整。</p><p>首先服务端的uri前缀需要改为https，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;https://localhost:8182/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketServer = <span class="keyword">new</span> WebSocketServer(serverUri);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketServer.StartAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户端的http升级请求需要改为https，即从http-ws调整为https-wss，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;https://localhost:8182/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketClient = <span class="keyword">new</span> WebSocketClient(serverUri.Replace(<span class="string">&quot;https&quot;</span>, <span class="string">&quot;wss&quot;</span>)); <span class="comment">// https升级请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketClient.StartAsync(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果服务器使用自签名证书(未经过CA认证)，客户端默认会抛出SSL错误，测试环境中可通过在代码中忽略证书验证的方式解决。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketClient</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 忽略自签名证书验证</span></span><br><span class="line">        ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =&gt; <span class="literal">true</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自签名证书可以使用OpenSSL生成，</p><p><code>openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes</code></p><p>这将生成cert.pem(证书)和key.pem(私钥)，然后使用以下命令将PEM文件转换为PFX文件。(此PFX文件导入后颁发者默认为Internet Widgits Pty Ltd)</p><p><code>openssl pkcs12 -export -out certificate.pfx -inkey key.pem -in cert.pem</code></p><p>若服务端使用HttpListener，需确保证书已绑定到服务器的端口。例如，在Windows上可以使用netsh命令，(注：IP一般使用通配地址0.0.0.0)</p><p><code>netsh http add sslcert ipport=&lt;IP&gt;:&lt;PORT&gt; certhash=&lt;Certificate Thumbprint&gt; appid=&#123;&lt;Application GUID&gt;&#125;</code></p><p>证书指纹可通过<code>win+r</code>输入<code>mmc</code>并添加证书单元格后在受信任的根证书颁发机构中查看，也可通过openssl命令获取。(注：通过命令获取到的指纹中的<code>:</code>需要删除，否则绑定时会报参数错误)</p><p><code>openssl x509 -in cert.pem -noout -fingerprint</code></p><p>可使用netsh命令检查证书是否绑定成功。</p><p><code>netsh http show sslcert</code></p><h4 id="支持心跳检测与自动重连"><a href="#支持心跳检测与自动重连" class="headerlink" title="支持心跳检测与自动重连"></a>支持心跳检测与自动重连</h4><p>WebSocket心跳检测(Heartbeat)是一种机制，用于确保客户端和服务器之间的连接仍然活跃，并且能够及时检测到任何连接问题。在WebSocket连接中，由于网络不稳定或服务器重启等原因，可能会导致连接意外断开，而双方并不知情。心跳检测通过定期发送小的数据包(如Ping&#x2F;Pong帧)来验证连接是否仍然存在。</p><p>在ClientWebSocket中，SendAsync和ReceiveAsync是异步操作，但它们有一个重要的限制：每个操作(SendAsync和ReceiveAsync)在同一时间只能有一个未完成的任务。如果尝试同时发起多个SendAsync或ReceiveAsync调用，就会抛出异常</p><blockquote><p>There is already one outstanding ‘SendAsync’ call for this WebSocket instance. ReceiveAsync and SendAsync can be called simultaneously, but at most one outstanding operation for each of them is allowed at the same time.</p></blockquote><p>ClientWebSocket的设计是线程安全的，但它不允许同时发起多个SendAsync或ReceiveAsync操作。如果你在一个线程中调用SendAsync，而在同一个操作完成之前又在另一个线程中调用SendAsync，就会触发上述异常。(ReceiveAsync同理)</p><p>在ServerWebSocket的心跳检测中，如果使用异步方式调用SendAsync，可能会导致服务在”Aborted”状态下仍然被用于通信(理论上只有”Open”状态下才应当执行)，从而引发异常</p><blockquote><p>The ‘System.Net.WebSockets.ServerWebSocket’ instance cannot be used for communication because it has been transitioned into the ‘Aborted’ state</p></blockquote><p>可以通过加锁的方式确保线程安全。在异步方法中可以使用SemaphoreSlim来实现异步锁，避免阻塞线程。</p><p>下面我们来实现WebSocket服务端与客户端各自的心跳检测机制，以及客户端自动重连机制。首先服务端需要启动心跳检测任务，并对客户端发送过来的Ping消息作出Pong回应。服务端完整代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketServer</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serverUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpListener _httpListener;</span><br><span class="line">    <span class="keyword">private</span> WebSocket _webSocket;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cancellationTokenSource;</span><br><span class="line">    <span class="keyword">private</span> CancellationToken _cancellationToken &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _cancellationTokenSource == <span class="literal">null</span> ? CancellationToken.None : _cancellationTokenSource.Token; &#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> HeartbeatInterval = <span class="number">5000</span>;  <span class="comment">// 心跳间隔时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PingMessage = <span class="string">&quot;Ping&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PongMessage = <span class="string">&quot;Pong&quot;</span>;</span><br><span class="line">    <span class="comment">//private readonly object _sendLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _sendSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="comment">//private readonly object _receiveLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _receiveSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketServer</span>(<span class="params"><span class="built_in">string</span> serverUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serverUri = serverUri;</span><br><span class="line">        _httpListener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpListener.Prefixes.Add(_serverUri);</span><br><span class="line">        _httpListener.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;WebSocket服务已启动，服务地址：<span class="subst">&#123;_serverUri&#125;</span>，等待客户端连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HttpListenerContext httpContext = <span class="keyword">await</span> _httpListener.GetContextAsync();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (httpContext.Request.IsWebSocketRequest)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> HandleWebSocketConnectionAsync(httpContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                httpContext.Response.StatusCode = <span class="number">400</span>;</span><br><span class="line">                httpContext.Response.Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HandleWebSocketConnectionAsync</span>(<span class="params">HttpListenerContext httpContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WebSocketContext webSocketContext = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            webSocketContext = <span class="keyword">await</span> httpContext.AcceptWebSocketAsync(subProtocol: <span class="literal">null</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;接收到客户端连接，WebSocket连接已建立，等待客户端消息...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            httpContext.Response.StatusCode = <span class="number">500</span>;</span><br><span class="line">            httpContext.Response.Close();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;WebSocket连接失败: &quot;</span> + e.Message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _webSocket = webSocketContext.WebSocket;</span><br><span class="line">        _cancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始心跳检测</span></span><br><span class="line">        <span class="keyword">var</span> heartbeatTask = HeartbeatAsync();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (_webSocket.State == WebSocketState.Open)</span><br><span class="line">        &#123;</span><br><span class="line">            WebSocketReceiveResult result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _receiveSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line">                result = <span class="keyword">await</span> _webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), _cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket消息接收错误 :&quot;</span> + e.Message);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                _receiveSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Close)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, _cancellationToken);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket连接已关闭!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Text)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理文本消息</span></span><br><span class="line">                <span class="built_in">string</span> message = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;接收到来自客户端的消息: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> SendMessageAsync(<span class="string">&quot;服务端已成功收到消息&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (message == PingMessage)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> SendMessageAsync(PongMessage);</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PongMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Binary)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理二进制消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _cancellationTokenSource.Cancel();</span><br><span class="line">        <span class="keyword">await</span> heartbeatTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">SendMessageAsync</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> _sendSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line">            <span class="keyword">var</span> msg = Encoding.UTF8.GetBytes(message);</span><br><span class="line">            <span class="keyword">await</span> _webSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(msg), WebSocketMessageType.Text, <span class="literal">true</span>, _cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _sendSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HeartbeatAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(HeartbeatInterval, _cancellationToken); </span><br><span class="line">                <span class="keyword">if</span> (_webSocket.State == WebSocketState.Open)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> SendMessageAsync(PingMessage);</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PingMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;WebSocket已关闭，心跳已停止.&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 任务被取消，跳出循环</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;心跳检测任务被取消，跳出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;心跳检测错误: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _webSocket.Dispose();</span><br><span class="line">            _cancellationTokenSource.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketServer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户端同样需要启动心跳检测任务，并对服务端发送过来的Ping消息作出Pong回应。此外，客户端还需要确保在连接断开后能自动重连。客户端完整代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketClient</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uri;</span><br><span class="line">    <span class="keyword">private</span> ClientWebSocket _clientWebSocket;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cancellationTokenSource;</span><br><span class="line">    <span class="keyword">private</span> CancellationToken _cancellationToken &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _cancellationTokenSource.Token; &#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> HeartbeatInterval = <span class="number">5000</span>;  <span class="comment">// 心跳间隔时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ReconnectDelay = <span class="number">10000</span>; <span class="comment">// 重连延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PingMessage = <span class="string">&quot;Ping&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PongMessage = <span class="string">&quot;Pong&quot;</span>;</span><br><span class="line">    <span class="comment">//private readonly object _sendLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _sendSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="comment">//private readonly object _receiveLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _receiveSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketClient</span>(<span class="params"><span class="built_in">string</span> uri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _uri = uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 忽略自签名证书验证</span></span><br><span class="line">        ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                _clientWebSocket = <span class="keyword">new</span> ClientWebSocket(); <span class="comment">// 对于每一次连接尝试，都要重新创建一个ClientWebSocket实例，否则会一直提示&quot;The WebSocket has already been started&quot;</span></span><br><span class="line">                _cancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource(); <span class="comment">// 对于每一次连接尝试，都要重新创建一个CancellationTokenSource实例，否则会一直提示&quot;A task was canceled&quot;</span></span><br><span class="line">                <span class="keyword">await</span> _clientWebSocket.ConnectAsync(<span class="keyword">new</span> Uri(_uri), _cancellationToken); <span class="comment">// 无法对一个已经启动或已经关闭的ClientWebSocket实例再次调用ConnectAsync </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开始心跳检测</span></span><br><span class="line">                <span class="keyword">var</span> heartbeatTask = HeartbeatAsync();</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;客户端已连接上WebSocket服务器，握手请求后的服务地址为<span class="subst">&#123;_uri&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收消息</span></span><br><span class="line">                <span class="keyword">await</span> ReceiveMessagesAsync();</span><br><span class="line"></span><br><span class="line">                _cancellationTokenSource.Cancel();</span><br><span class="line">                <span class="keyword">await</span> heartbeatTask;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;WebSocket错误：<span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;在<span class="subst">&#123;ReconnectDelay / <span class="number">1000</span>&#125;</span>秒后尝试重连...&quot;</span>);</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(ReconnectDelay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">ReceiveMessagesAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (_clientWebSocket.State == WebSocketState.Open)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">await</span> _receiveSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> result = <span class="keyword">await</span> _clientWebSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), _cancellationToken);</span><br><span class="line">                    <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Close)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">await</span> _clientWebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, _cancellationToken);</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;WebSocket客户端已关闭!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> message = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">                        Console.WriteLine(<span class="string">$&quot;接收到来自服务端的消息: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (message == PingMessage)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">await</span> SendMessageAsync(PongMessage);</span><br><span class="line">                            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PongMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 任务被取消，跳出循环</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;消息接收任务被取消，跳出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;客户端接收消息发生错误: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                _receiveSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">SendMessageAsync</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> _sendSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line">            <span class="keyword">var</span> msg = Encoding.UTF8.GetBytes(message);</span><br><span class="line">            <span class="keyword">await</span> _clientWebSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(msg), WebSocketMessageType.Text, <span class="literal">true</span>, _cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _sendSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HeartbeatAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(HeartbeatInterval, _cancellationToken);</span><br><span class="line">                <span class="keyword">if</span> (_clientWebSocket.State == WebSocketState.Open)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> SendMessageAsync(PingMessage);</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PingMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;WebSocket已关闭，心跳已停止.&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 任务被取消，跳出循环</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;心跳检测任务被取消，跳出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;心跳检测错误: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _clientWebSocket.Dispose();</span><br><span class="line">            _cancellationTokenSource.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketClient()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了客户端反复掉线重连时，服务端控制台的输出情况。</p><img   src="/Hexo-Blog/2024/08/18/websocket-usage/websocket_server_console.png"  class="" title="服务端控制台的输出情况"><p>下图展示了服务端反复重启时，客户端控制台的输出情况。</p><img   src="/Hexo-Blog/2024/08/18/websocket-usage/websocket_client_console.png"  class="" title="客户端控制台的输出情况"><h3 id="第三方库实现"><a href="#第三方库实现" class="headerlink" title="第三方库实现"></a>第三方库实现</h3><p>.NET中也可以引入Nuget包来实现WebSocket通信。</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p>Fleck是C#中的一个WebSocket服务器实现，Fleck不依赖于HttpListener。下面借助Fleck来模拟一个WebSocket服务端。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Fleck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FleckLog.Level = LogLevel.Debug;</span><br><span class="line">        <span class="keyword">var</span> allSockets = <span class="keyword">new</span> List&lt;IWebSocketConnection&gt;();</span><br><span class="line">        <span class="keyword">var</span> server = <span class="keyword">new</span> WebSocketServer(<span class="string">&quot;ws://127.0.0.1:8181&quot;</span>);</span><br><span class="line">        server.Start(socket =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            socket.OnOpen = () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                allSockets.Add(socket);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;当前客户端数量：&quot;</span> + allSockets.ToList().Count);</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.OnClose = () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;客户端已经关闭!&quot;</span>);</span><br><span class="line">                allSockets.Remove(socket);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;当前客户端数量：&quot;</span> + allSockets.ToList().Count);</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.OnMessage = message =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(message);</span><br><span class="line">                allSockets.ToList().ForEach(s =&gt; s.Send(message));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> socket <span class="keyword">in</span> allSockets.ToList())</span><br><span class="line">            &#123;</span><br><span class="line">                socket.Send(input);</span><br><span class="line">            &#125;</span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>WebSocket4Net是基于.NET的一个WebSocket客户端实现。下面借助WebSocket4Net来模拟一个WebSocket客户端。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> WebSocket4Net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> WebSocket webSocket4Net = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WebSocket4Net_Opened</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net.Send(<span class="string">$&quot;客户端连接成功，准备发送数据！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WebSocket4Net_MessageReceived</span>(<span class="params"><span class="built_in">object</span> sender, MessageReceivedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;服务端回复数据:<span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClientSendMsgToServer</span>(<span class="params"><span class="built_in">object</span> input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net.Send((<span class="built_in">string</span>)input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://127.0.0.1:8181&quot;</span>);</span><br><span class="line">        webSocket4Net.Opened += WebSocket4Net_Opened;</span><br><span class="line">        webSocket4Net.MessageReceived += WebSocket4Net_MessageReceived;</span><br><span class="line">        webSocket4Net.Open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(ClientSendMsgToServer));</span><br><span class="line">            thread.Start(input);</span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        webSocket4Net.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="支持WSS-1"><a href="#支持WSS-1" class="headerlink" title="支持WSS"></a>支持WSS</h4><p>首先在基于Fleck实现的服务端中加载域名证书和密码，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebSocketServer(<span class="string">&quot;wss://127.0.0.1:8182&quot;</span>);</span><br><span class="line">server.Certificate = <span class="keyword">new</span> X509Certificate2(<span class="string">&quot;certificate.pfx&quot;</span>, <span class="string">&quot;&quot;</span>, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet); <span class="comment">// 自签名证书密码默认为&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>然后在基于WebSocket4Net实现的客户端中修改握手后的升级请求(ws前缀改为wss)。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webSocket4Net = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://127.0.0.1:8182&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://www.rfc-editor.org/rfc/rfc6455" >RFC 6455官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://websocket.xiniushu.com/" >WebSocket协议(RFC 6455中文版)<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://github.com/statianzo/Fleck" >Fleck开源项目地址<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://github.com/kerryjiang/WebSocket4Net" >WebSocket4Net开源项目地址<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;WebSocket的基本概念、应用场景，以及服务端和客户端在C#与.NET中的简单实现(包含心跳检测与自动重连)。&lt;/p&gt;</summary>
    
    
    
    <category term="Network-Protocol" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Network-Protocol/"/>
    
    
    <category term=".NET" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET/"/>
    
    <category term="WebSocket" scheme="https://jocoboy.github.io/Hexo-Blog/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Web Service远程调用技术</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/18/web-service-and-rpc/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/18/web-service-and-rpc/</id>
    <published>2024-08-18T06:15:36.000Z</published>
    <updated>2025-08-01T09:27:22.801Z</updated>
    
    <content type="html"><![CDATA[<p>Web Service远程调用技术(RPC)的基本概念及实现方式。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web Service即web服务，是一种跨编程语言和跨操作系统平台的远程调用技术。Web服务包含了一套标准,例如HTTP、XML、SOAP、WSDL、UDDI等，定义了应用程序如何在Web上实现互操作，可以在任何支持这些标准的平台（如Windows、Linux）中使用。</p><p>Web Service与Web API相比，更加适合端到端的应用场景(C&#x2F;S架构)，适合作为内部服务使用。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><p>SOAP即简单对象访问协议(Simple Object Access Protocol)，是Web Service的通信协议，基于XML文件并绑定在HTTP协议上传递。SOAP消息包括Envelope、Header和Body元素。</p><p>一条SOAP消息就是一个普通的XML文档，文档包括下列元素：</p><ul><li>Envelope元素，必选，可把此XML文档标识为一条SOAP消息</li><li>Header元素，可选，包含头部信息</li><li>Body元素，必选，包含所有的调用和响应信息</li></ul><p>目前WebSerivce的协议主要有SOAP1.1与SOAP1.2，二者的区别如下：</p><table><thead><tr><th>区别</th><th>SOAP1.1</th><th>SOAP1.2</th></tr></thead><tbody><tr><td>命名空间</td><td><code>http://schemas.xmlsoap.org/soap/envelope/</code></td><td><code>http://www.w3.org/2003/05/soap-envelope</code></td></tr><tr><td>请求与响应</td><td>请求头包含SOAPAction，且请求与响应的Content-Type为text&#x2F;xml，以soap作为前缀</td><td>请求头不包含SOAPAction，且请求与响应的Content-Type为application&#x2F;soap+xml，以soap12作为前缀</td></tr><tr><td>错误处理</td><td>使用SOAP Fault元素，包含faultcode, faultstring, faultactor, detail</td><td>使用Code和Reason元素，提供更结构化的错误信息</td></tr><tr><td>协议绑定</td><td>主要支持HTTP绑定</td><td>支持更多协议绑定，如SMTP、FTP等</td></tr><tr><td>数据模型</td><td>数据模型较为简单</td><td>引入了更复杂的数据模型，支持更多数据类型和编码方式</td></tr><tr><td>处理规则</td><td>处理规则较为宽松</td><td>处理规则更严格，要求必须忽略未知的SOAP头元素</td></tr><tr><td>规范文档</td><td>由W3C提交，非正式推荐标准</td><td>由W3C正式推荐，文档更详细</td></tr><tr><td>扩展性</td><td>扩展性有限</td><td>扩展性更强，支持更多扩展机制</td></tr><tr><td>安全性</td><td>安全性较弱</td><td>安全性增强，支持更多安全机制</td></tr><tr><td>兼容性</td><td>兼容性较好，广泛支持</td><td>兼容性稍差，部分旧系统可能不支持</td></tr></tbody></table><h3 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h3><p>Web Service描述语言(WebService Definition Language，简称WSDL)就是用机器能阅读的方式提供的一个正式描述文档而基于XML的语言，用于描述Web Service及其函数、参数和返回值。</p><p>在WSDL说明书中，描述了</p><ul><li>对外发布的服务名称（类）</li><li>接口方法名称（方法）</li><li>接口参数（方法参数）</li><li>​服务返回的数据类型（方法返回值）</li></ul><p>WSDL目前有1.1和2.0两个版本，它们在语法、结构和功能上有显著差异，二者的区别如下：</p><table><thead><tr><th>区别</th><th>WSDL1.1</th><th>WSDL2.0</th></tr></thead><tbody><tr><td>命名空间</td><td><code>http://schemas.xmlsoap.org/wsdl/</code></td><td><code>http://www.w3.org/ns/wsdl</code></td></tr><tr><td>文档结构</td><td>根元素为<code>&lt;wsdl:definitions&gt;</code>，主要部分包括<code>&lt;wsdl:types&gt;</code>、<code>&lt;wsdl:message&gt;</code>、<code>&lt;wsdl:portType&gt;</code>、<code>&lt;wsdl:binding&gt;</code>、<code>&lt;wsdl:service&gt;</code></td><td>根元素为<code>&lt;wsdl:description&gt;</code>，使用<code>&lt;wsdl:interface&gt;</code>替代<code>&lt;wsdl:portType&gt;</code></td></tr><tr><td>操作定义</td><td>使用<code>&lt;wsdl:portType&gt;</code>定义操作，操作类型包括One-way、Request-response、Solicit-response、Notification</td><td>使用<code>&lt;wsdl:interface&gt;</code>定义操作，操作类型包括One-way、Request-response、Robust In-only、In-out</td></tr><tr><td>消息定义</td><td>使用<code>&lt;wsdl:message&gt;</code>定义消息，消息由<code>&lt;wsdl:part&gt;</code>组成，每个部分可以引用类型或元素</td><td>取消了 <code>&lt;wsdl:message&gt;</code>和<code>&lt;wsdl:part&gt;</code>，直接在操作中定义输入和输出消息的类型</td></tr><tr><td>绑定支持</td><td>主要支持SOAP1.1绑定，支持HTTP GET&#x2F;POST和MIME绑定，但使用较少</td><td>支持SOAP1.1和SOAP1.2绑定，增强了对HTTP GET&#x2F;POST和MIME绑定的支持，支持更多协议绑定（如JMS、SMTP等）</td></tr><tr><td>错误处理</td><td>错误处理依赖于SOAP的Fault消息</td><td>引入了<code>&lt;wsdl:fault&gt;</code>元素，直接在操作中定义错误消息</td></tr><tr><td>模块化</td><td>模块化支持较弱，主要通过<code>&lt;wsdl:import&gt;</code>引入外部WSDL或XSD文件</td><td>增强了模块化支持，允许更灵活地组合和重用 WSDL文档</td></tr><tr><td>扩展性</td><td>扩展性较差，主要通过<code>&lt;wsdl:documentation&gt;</code>和<code>&lt;wsdl:extensibility&gt;</code>实现</td><td>增强了扩展性，支持更多的自定义元素和属性</td></tr><tr><td>标准化</td><td>未被正式标准化，但被广泛使用</td><td>是WSDL1.1的改进和标准化版本</td></tr></tbody></table><h3 id="UDDI"><a href="#UDDI" class="headerlink" title="UDDI"></a>UDDI</h3><p>UDDI(Universal Description，Discovery and Integration)，也就是通用的描述、发现以及整合，是一套基于Web的、分布式的、为WebService提供的、信息注册中心的实现标准规范。用户可以通过UDDI来注册和搜索Web服务。</p><h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>面向服务架构(Service Oriented Architecture，简称SOA)，是一个组件模型，它将应用程序的不同功能单元(服务)通过预先定义的接口和契约联系起来。接口是采用中立的方式进行定义的，独立于实现服务的硬件平台、操作系统和编程语言，构建在系统中的服务以一种统一和通用的方式进行交互。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>注: 以下项目基于.NET Framework，.NET中无法使用</p><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>使用ASP.NET Web应用程序(.NET Framework)创建一个Web服务(asmx文件)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Web.Services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplicationDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">WebService(Namespace = <span class="string">&quot;http://tempuri.org/&quot;</span>)</span>] <span class="comment">// 定义命名空间</span></span><br><span class="line">    [<span class="meta">WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)</span>] <span class="comment">// 绑定规范</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebServiceTest</span> : <span class="title">WebService</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">WebMethod(Description = <span class="string">&quot;测试方法&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h2><h3 id="静态引用"><a href="#静态引用" class="headerlink" title="静态引用"></a>静态引用</h3><p>根据提供的Web Service地址，通过Connected Services添加WCF Web服务引用，生成cs文件，然后直接调用。</p><p>以下是在控制台程序以及ASP.NET Web API项目中的调用方式。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WebServiceTestSoapClient client = <span class="keyword">new</span> WebServiceTestSoapClient();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = client.SumAsync(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(res.Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/Test&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建 HTTP 绑定对象</span></span><br><span class="line">        <span class="keyword">var</span> binding = <span class="keyword">new</span> BasicHttpBinding();</span><br><span class="line">        <span class="comment">//根据 WebService 的 URL 构建终端点对象，参数是提供的WebService地址</span></span><br><span class="line">        <span class="keyword">var</span> endpoint = <span class="keyword">new</span> EndpointAddress(<span class="string">@&quot;http://localhost:8083/WebServiceTest.asmx&quot;</span>);</span><br><span class="line">        <span class="comment">//创建调用接口的工厂，注意这里泛型只能传入接口 泛型接口里面的参数是WebService里面定义的类名+Soap</span></span><br><span class="line">        <span class="keyword">var</span> factory = <span class="keyword">new</span> ChannelFactory&lt;WebServiceTestSoap&gt;(binding, endpoint);</span><br><span class="line">        <span class="comment">//从工厂获取具体的调用实例</span></span><br><span class="line">        <span class="keyword">var</span> callClient = factory.CreateChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> task = callClient.SumAsync(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">var</span> res = task.Result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;WebService中Sum方法返回结果为<span class="subst">&#123;res&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h3><p>将Web Service地址存放到配置文件中，通过读取地址生成代理类，动态在项目中生成代理类文件，然后通过反射调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = (<span class="built_in">int</span>)WebServiceProxy.InvokeWebService(<span class="string">&quot;https://localhost:44319/WebServiceTest.asmx&quot;</span>, <span class="string">&quot;WebServiceTest&quot;</span>, <span class="string">&quot;Sum&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 反射代理类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebServiceProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">InvokeWebService</span>(<span class="params"><span class="built_in">string</span> url,<span class="built_in">string</span> ns, <span class="built_in">string</span> methodname, <span class="built_in">object</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取WSDL</span></span><br><span class="line">            WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">            Stream stream = wc.OpenRead(url + <span class="string">&quot;?WSDL&quot;</span>);</span><br><span class="line">            ServiceDescription sd = ServiceDescription.Read(stream);</span><br><span class="line">            <span class="built_in">string</span> classname = sd.Services[<span class="number">0</span>].Name;</span><br><span class="line">            ServiceDescriptionImporter sdi = <span class="keyword">new</span> ServiceDescriptionImporter();</span><br><span class="line">            sdi.AddServiceDescription(sd, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            CodeNamespace cn = <span class="keyword">new</span> CodeNamespace(ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成客户端代理类代码</span></span><br><span class="line">            CodeCompileUnit ccu = <span class="keyword">new</span> CodeCompileUnit();</span><br><span class="line">            ccu.Namespaces.Add(cn);</span><br><span class="line">            sdi.Import(cn, ccu);</span><br><span class="line">            CSharpCodeProvider csc = <span class="keyword">new</span> CSharpCodeProvider();</span><br><span class="line">            ICodeCompiler icc = csc.CreateCompiler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设定编译参数</span></span><br><span class="line">            CompilerParameters cplist = <span class="keyword">new</span> CompilerParameters();</span><br><span class="line">            cplist.GenerateExecutable = <span class="literal">false</span>;</span><br><span class="line">            cplist.GenerateInMemory = <span class="literal">true</span>;</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.XML.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.Web.Services.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.Data.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//编译代理类</span></span><br><span class="line">            CompilerResults cr = icc.CompileAssemblyFromDom(cplist, ccu);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">true</span> == cr.Errors.HasErrors)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Text.StringBuilder sb = <span class="keyword">new</span> System.Text.StringBuilder();</span><br><span class="line">                <span class="keyword">foreach</span> (System.CodeDom.Compiler.CompilerError ce <span class="keyword">in</span> cr.Errors)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.Append(ce.ToString());</span><br><span class="line">                    sb.Append(System.Environment.NewLine);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(sb.ToString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成代理实例，并调用方法</span></span><br><span class="line">            System.Reflection.Assembly assembly = cr.CompiledAssembly;</span><br><span class="line">            Type t = assembly.GetType(ns + <span class="string">&quot;.&quot;</span> + classname, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">object</span> obj = Activator.CreateInstance(t);</span><br><span class="line">            System.Reflection.MethodInfo mi = t.GetMethod(methodname);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mi.Invoke(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用HTTP方式调用"><a href="#使用HTTP方式调用" class="headerlink" title="使用HTTP方式调用"></a>使用HTTP方式调用</h3><p>Web Service还可以使用HTTP方式，通过发送SOAP请求体进行调用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> webServiceUri = <span class="string">&quot;http://localhost:8083/WebServiceTest.asmx&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> soapRequest = <span class="string">@&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;</span></span><br><span class="line"><span class="string">                              &lt;soap:Envelope xmlns:xsi=&quot;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&quot; xmlns:xsd=&quot;&quot;http://www.w3.org/2001/XMLSchema&quot;&quot; xmlns:soap=&quot;&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">                                &lt;soap:Body&gt;</span></span><br><span class="line"><span class="string">                                  &lt;Sum xmlns=&quot;&quot;http://tempuri.org/&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">                                    &lt;a&gt;1&lt;/a&gt;</span></span><br><span class="line"><span class="string">                                    &lt;b&gt;2&lt;/b&gt;</span></span><br><span class="line"><span class="string">                                  &lt;/Sum&gt;</span></span><br><span class="line"><span class="string">                                &lt;/soap:Body&gt;</span></span><br><span class="line"><span class="string">                              &lt;/soap:Envelope&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// var request = new HttpRequestMessage(HttpMethod.Post, &quot;http://localhost:8083/WebServiceTest.asmx&quot;);</span></span><br><span class="line">        <span class="comment">// request.Headers.Add(&quot;SOAPAction&quot;, &quot;\&quot;http://tempuri.org/Sum\&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// request.Content = new StringContent(soapRequest, Encoding.UTF8, &quot;text/xml&quot;);</span></span><br><span class="line">        <span class="comment">// HttpResponseMessage response = client.SendAsync(request).Result;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> content = <span class="keyword">new</span> StringContent(soapRequest, Encoding.UTF8, <span class="string">&quot;text/xml&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> response =  client.PostAsync(webServiceUri, content).Result;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> responseContent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">        &#123;</span><br><span class="line">            responseContent = response.Content.ReadAsStringAsync().Result;</span><br><span class="line">            <span class="comment">// 解析XML响应</span></span><br><span class="line">            XDocument xmlResponse = XDocument.Parse(responseContent);</span><br><span class="line">            <span class="comment">// 处理XML</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;xmlResponse&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Error: <span class="subst">&#123;response.StatusCode&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求返回的soap消息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:soap</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SumResponse</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tempuri.org/&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">SumResult</span>&gt;</span>3<span class="tag">&lt;/<span class="name">SumResult</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">SumResponse</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="soap消息解析"><a href="#soap消息解析" class="headerlink" title="soap消息解析"></a>soap消息解析</h4><p>假设返回的soap消息包含xml数据如下，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:soap</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">getMqResponse</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tempuri.org/&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">getMqResult</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maindata</span> <span class="attr">table</span>=<span class="string">&quot;person&quot;</span> <span class="attr">disid</span>=<span class="string">&quot;1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">opeType</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">idno</span>&gt;</span>1001<span class="tag">&lt;/<span class="name">idno</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">maindata</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">getMqResult</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">getMqResponse</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想要解析带命名空间的xml并获取其中某些节点的属性值和内容，则需要使用命名空间管理器。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载SOAP响应的XML数据</span></span><br><span class="line">XmlDocument xmlDoc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">xmlDoc.LoadXml(soapResponse);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建命名空间管理器，并添加SOAP命名空间</span></span><br><span class="line">XmlNamespaceManager namespaceManager = <span class="keyword">new</span> XmlNamespaceManager(xmlDoc.NameTable);</span><br><span class="line">namespaceManager.AddNamespace(<span class="string">&quot;soap&quot;</span>, <span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>);</span><br><span class="line">namespaceManager.AddNamespace(<span class="string">&quot;ns&quot;</span>, <span class="string">&quot;http://tempuri.org/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用XPath表达式提取所需的数据</span></span><br><span class="line">XmlNode mainDataNode = xmlDoc.SelectSingleNode(<span class="string">&quot;/soap:Envelope/soap:Body/ns:getMqResponse/ns:getMqResult/maindata&quot;</span>, namespaceManager);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取maindata中disid的属性值</span></span><br><span class="line">XmlElement mainDataElement = (XmlElement)mainDataNode;</span><br><span class="line"><span class="keyword">var</span> disid = mainDataElement.GetAttribute(<span class="string">&quot;disid&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> childNodes = mainDataNode.SelectNodes(<span class="string">&quot;item&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> itemNode <span class="keyword">in</span> childNodes)</span><br><span class="line">&#123;</span><br><span class="line">    XmlElement itemElement = (XmlElement)itemNode;</span><br><span class="line">    <span class="comment">// 获取item中opeType的属性值</span></span><br><span class="line">    <span class="keyword">var</span> opeType = itemElement.GetAttribute(<span class="string">&quot;opeType&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取idno的文本值</span></span><br><span class="line">    <span class="keyword">var</span> idno = itemElement.SelectSingleNode(<span class="string">&quot;idno&quot;</span>).InnerText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="xml字符串转义问题"><a href="#xml字符串转义问题" class="headerlink" title="xml字符串转义问题"></a>xml字符串转义问题</h4><p>在WebService方法返回XML数据的时候，将XML处理成字符串返回，在客户端得到的XML字符串会出现被转义的情况。</p><p>将已经为HTTP传输进行过HTML编码的字符串转换为已解码的字符串，可在不改动服务端代码的情况下解决转义问题。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = System.Net.WebUtility.HtmlDecode(xmlResponse.ToString());</span><br></pre></td></tr></table></figure><p>string类型和XmlDocument类型在WebService序列化过程中的处理方法不同。如果返回可序列化的标准XML对象，可从根本上解决转义问题。</p><p>对应的服务端代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">WebMethod(Description = <span class="string">&quot;测试方法&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> System.Xml.<span class="function">XmlDocument <span class="title">GetMainData</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// your xml response</span></span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">@&quot;&lt;maindata&gt;</span></span><br><span class="line"><span class="string">                 &lt;item&gt;&lt;/item&gt;</span></span><br><span class="line"><span class="string">                &lt;/maindata&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.Xml.XmlDocument xmldoc = <span class="keyword">new</span> System.Xml.XmlDocument();</span><br><span class="line">    xmldoc.LoadXml(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xmldoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/?view=netframework-4.8.1" >.NET Framework API参考文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/framework/wcf/" >使用WCF开发面向服务的应用程序<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.net.webutility.htmldecode" >WebUtility.HtmlDecode方法<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Web Service远程调用技术(RPC)的基本概念及实现方式。&lt;/p&gt;</summary>
    
    
    
    <category term="Remote-Procedure-Call" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Remote-Procedure-Call/"/>
    
    
    <category term=".NET" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET/"/>
    
    <category term="ASP.NET Core" scheme="https://jocoboy.github.io/Hexo-Blog/tags/ASP-NET-Core/"/>
    
    <category term="Web Service" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Web-Service/"/>
    
    <category term=".NET Framework" scheme="https://jocoboy.github.io/Hexo-Blog/tags/NET-Framework/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes核心组件与集群搭建</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/17/kubernetes-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/17/kubernetes-usage/</id>
    <published>2024-08-17T05:18:34.000Z</published>
    <updated>2025-08-01T09:27:22.786Z</updated>
    
    <content type="html"><![CDATA[<p>kubernetes的核心组件、架构体系、环境搭建(minikube&#x2F;k3s)，以及kubectl常用命令和可视化管理工具Portainer。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>kubernetes是一个全新的基于容器技术的分布式架构领先方案。kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><img   src="/Hexo-Blog/2024/08/17/kubernetes-usage/kubernetes_components.png"  class="" title="kubernetes部分核心组件"><ul><li>node，一个物理机或虚拟机</li><li>pod，一个或多个应用容器的组合(如sidecar模式，应用容器与辅助容器共用一个Pod)。pod之间可通过内部ip地址访问</li><li>svc(service)，将一组pod封装为一个服务，可以通过一个统一的入口来访问，相当于反向代理，可以解决因pod销毁导致的内部ip地址变更问题</li><li>node:port，端口节点，提供内部服务对外的IP映射</li><li>ing(ingress)，用来管理从集群外部访问集群内部服务的入口和方式，可以配置不同的转发规则，根据不同的规则访问不同的svc，以及svc对应的pod。此外还可以配置域名、负载均衡、SSL证书等</li><li>cm(config map)，用来存储应用程序配置信息，实现应用程序与配置信息的解耦</li><li>secret，为cm中的敏感信息提供Base64加密，需要配合其他安全机制(如网络控制、访问控制、身份认证)一起使用</li><li>vol(volume)，可以将应用数据挂载到集群内部的本地磁盘上，或是集群外部的远程存储上，实现数据的持久化</li><li>deploy(deployment)，定义和管理应用程序的副本数量，是pod上的一层抽象</li><li>replicaset，介于pod与deploy之间，用于管理pod</li><li>sts(stateful set)，和deploy类似，用来管理有状态的应用(如数据库、缓存、消息队列等)</li></ul><h2 id="Master-Worker架构"><a href="#Master-Worker架构" class="headerlink" title="Master-Worker架构"></a>Master-Worker架构</h2><p>kubernetes是典型的Master-Worker架构。Master-Node负责管理整个集群，Worker-Node负责运行应用程序和服务。</p><img   src="/Hexo-Blog/2024/08/17/kubernetes-usage/kubernetes_architecture.png"  class="" title="kubernetes架构图"><ul><li>kubelet，负责管理和维护每个node上的pod</li><li>kube-proxy，负责提供网络代理和负载均衡服务</li><li>container-runtime，负责提供容器运行时(如docker engine)</li><li>kube-apiserver，负责提供API接口服务</li><li>etcd，高可用的键值存储系统，负责存储集群中各种资源对象的状态信息</li><li>c-m(controller manager)，负责管理集群中各种资源对象的状态</li><li>sched(schedular)，负责监控集群中所有节点的资源使用情况，然后根据一些调度策略，将pod调度到合适的node上运行</li><li>c-c-m(cloud controller manager)，云平台控制器，负责与云平台的api交互</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h3><p>minukube是一个轻量级的kubernetes实现，可在本地计算机上创建虚拟机，并部署仅包含一个节点的简单集群。</p><p>kubectl是一个命令行工具，可以通过在命令行输入各种命令与MasterNode的kube-apiserver交互，从而与Kubernetes集群进行交互。</p><p>在windows中使用chocolatey安装minukube</p><p><code>choco install minkube</code></p><p>查看版本信息验证是否安装成功</p><p><code>minikube version</code></p><p>创建集群(选择国内镜像源并指定版本)</p><p><code>minikube start --image-mirror-country=&#39;cn&#39;  --kubernetes-version=v1.23.9</code></p><p>查看集群中的节点信息</p><p><code>kubectl get nodes</code></p><p>Docker Desktop也自带了minukube，可手动开启。</p><h3 id="k3s"><a href="#k3s" class="headerlink" title="k3s"></a>k3s</h3><p>k3s是一个CNCF认证的轻量级的kubernetes发行版，可以方便地搭建一个多节点集群。</p><h4 id="准备虚拟机环境"><a href="#准备虚拟机环境" class="headerlink" title="准备虚拟机环境"></a>准备虚拟机环境</h4><p>在windows中使用chocolatey安装multipass</p><p><code>choco install multipass</code></p><p>创建一个名为k3s的虚拟机</p><p><code>multipass launch --name k3s</code></p><p>启动虚拟机</p><p><code>multipass start k3s</code></p><p>登录到虚拟机</p><p><code>multipass shell k3s</code></p><p>通过multipass创建的虚拟机默认不允许SSH远程登录，需要额外配置。</p><ul><li>添加用户密码 <code>sudo passwd ubuntu</code></li><li>修改SSH配置 <code>sudo vi /etc/ssh/sshd_config</code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">KbdInteractiveAuthentication yes    </span><br></pre></td></tr></table></figure></li><li>重启SSH服务 <code>sudo service ssh restart</code></li><li>使用SSH登录 <code>ssh ubuntu@ip</code></li></ul><h4 id="创建和配置Master节点"><a href="#创建和配置Master节点" class="headerlink" title="创建和配置Master节点"></a>创建和配置Master节点</h4><p>使用国内镜像安装k3s</p><p><code>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -</code></p><p>查看当前节点(Master节点)</p><p><code>sudo kubectl get nodes</code></p><h4 id="创建和配置Worker节点"><a href="#创建和配置Worker节点" class="headerlink" title="创建和配置Worker节点"></a>创建和配置Worker节点</h4><p>在Master节点上获取token，作为其它节点加入集群的凭证</p><p><code>sudo cat /var/lib/rancher/k3s/server/node-token</code></p><p>将TOKEN保存到环境变量</p><p><code>TOKEN=$(multipass exec k3s sudo cat /var/lib/rancher/k3s/server/node-token)</code></p><p>保存master节点的IP地址</p><p><code>MASTER_IP=$(multipass info k3s | grep IPv4 | awk &#39;&#123;print $2&#125;&#39;)</code></p><p>使用刚刚的TOKEN和MASTER_IP来创建两个worker节点，并把它们加入到集群中</p><ul><li><p>创建两个worker节点的虚拟机</p><p>  <code>multipass launch --name worker1 --cpus 2 --memory 8G --disk 10G</code></p><p>  <code>multipass launch --name worker2 --cpus 2 --memory 8G --disk 10G</code></p></li><li><p>在worker节点虚拟机上安装k3s</p><p>  <code>for f in 1 2; do   multipass exec worker$f -- bash -c &quot;curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=\&quot;https://$MASTER_IP:6443\&quot; K3S_TOKEN=\&quot;$TOKEN\&quot; sh -&quot;   done</code></p></li></ul><h3 id="在线环境"><a href="#在线环境" class="headerlink" title="在线环境"></a>在线环境</h3><p>k8s也可通过在线环境使用</p><ul><li><p><a class="link"   href="https://labs.play-with-k8s.com/" >labs.play-with-k8s<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://killercoda.com/" >killercoda<i class="fas fa-external-link-alt"></i></a></p></li></ul><h2 id="kubectl常用命令"><a href="#kubectl常用命令" class="headerlink" title="kubectl常用命令"></a>kubectl常用命令</h2><p>创建一个pod</p><p><code>sudo kubectl run [pod-name] --image=[image-name]</code></p><p>创建一个deployment，指定镜像为nginx</p><p><code>sudo kubectl create deployment [deployment-name] --image=[image-name]</code></p><p>通过配置文件创建一个deployment</p><p><code>vi [deployment-name].yaml</code></p><p><code>sudo kubectl create -f [deployment-name].yaml</code></p><p>修改deployment</p><p><code>sudo kubectl edit deployment [deployment-name]</code></p><p>通过配置文件修改deployment</p><p><code>sudo kubectl apply -f [deployment-name].yaml</code></p><p>删除deployment</p><p><code>sudo kubectl delete deployment [deployment-name]</code></p><p>通过配置文件删除deployment</p><p><code>sudo kubectl delete -f [deployment-name].yaml</code></p><p>查看pod或deployment</p><p><code>sudo kubectl get pod</code></p><p><code>sudo kubectl get deployment</code></p><p>查看pod日志</p><p><code>sudo kubectl logs [pod-name]</code></p><p>将deployment对外公开为service</p><p><code>sudo kubectl expose deployment [deployment-name]</code></p><p>查看服务详细信息</p><p><code>sudo kubectl describe service [deployment-name]</code></p><p>删除服务</p><p><code>sudo kubectl delete service [deployment-name]</code></p><p>通过配置文件创建NodePort类型的服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 使用的Kubernetes API版本，这里是v1。</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 定义资源类型为Service，表示创建一个服务。</span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 元数据部分，用于描述Service的基本信息。</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>  <span class="comment"># Service的名称为nginx-service。</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 规格部分，定义Service的规格。</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span><span class="comment"># 指定服务类型，默认为ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span>  <span class="comment"># 选择器部分，用于指定服务应该选择哪些Pod作为后端。</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>  <span class="comment"># 选择具有标签app=nginx的Pod作为后端。</span></span><br><span class="line">  <span class="attr">ports:</span>  <span class="comment"># 端口配置，定义Service暴露的端口。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span>  <span class="comment"># 使用TCP协议。</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service暴露的端口号为80。</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>  <span class="comment"># 转发到后端Pod的端口号也为80。</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure><p><code>sudo kubectl apply -f [service-name].yaml</code></p><p>查看当前集群命名空间</p><p><code>sudo kubectl ns</code></p><h2 id="可视化管理工具Portainer"><a href="#可视化管理工具Portainer" class="headerlink" title="可视化管理工具Portainer"></a>可视化管理工具Portainer</h2><p>安装portainer，并将其暴露在NodePort&#x3D;30777上</p><p><code>kubectl apply -n portainer -f https://downloads.portainer.io/ce2-19/portainer.yaml</code></p><p>在集群外部输入ip地址+端口号即可访问。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a class="link"   href="https://kubernetes.io/docs/home/" >kubernetes官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://minikube.sigs.k8s.io/docs/" >minukube官方文档<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://multipass.run/docs/multipass-cli-client" >multipass官方文档-常用命令<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://docs.rancher.cn/docs/k3s/quick-start/_index/" >k3s官方文档-快速入门<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://docs.portainer.io/" >Portainer官方文档<i class="fas fa-external-link-alt"></i></a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;kubernetes的核心组件、架构体系、环境搭建(minikube&amp;#x2F;k3s)，以及kubectl常用命令和可视化管理工具Portainer。&lt;/p&gt;</summary>
    
    
    
    <category term="Architecture" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Architecture/"/>
    
    
    <category term="kubernetes" scheme="https://jocoboy.github.io/Hexo-Blog/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ核心概念及应用场景</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/17/rabbitmq-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/17/rabbitmq-usage/</id>
    <published>2024-08-17T00:20:47.000Z</published>
    <updated>2025-08-01T09:27:22.792Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ基本概念、安装配置、使用场景、消息模型，以及消息持久化、签收机制、延迟队列的实现。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ是基于AMQP(Advanced Message Queue Protocol)协议实现的消息队列，是一种应用程序之间的通信方法，在分布式系统开发中应用广泛。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img   src="/Hexo-Blog/2024/08/17/rabbitmq-usage/rabbitmq_architecture.png"  class="" title="RabbitMQ工作原理"><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>Broker是消息队列进程，包含Exchange、Queue两个部分。</p><h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><p>Exchange指消费队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过滤。</p><p>常用类型有direct、topic、fanout、headers四种。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue指消息队列，消息打达队列后转发给指定的消费方。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producer指消息生产者，生产者发布消息的过程如下：</p><ul><li><p>生产者和broker建立Connection，并开启一个channel</p></li><li><p>生产者声明一个交换机并设置相关属性(交换机类型、是否持久化)</p></li><li><p>生产者声明一个队列并设置相关属性(是否排他、是否持久化、是否自动删除)</p></li><li><p>生产者通过routing key将交换机和队列绑定</p></li><li><p>生产者通过channel发送给broker，由交换机根据接收到的routing key匹配队列</p></li><li><p>如果找到匹配的队列则存入，否则丢弃或回传</p></li></ul><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer指消息消费者，消费者接受消息的过程如下：</p><ul><li><p>消费者和broker建立Connection，并开启一个channel</p></li><li><p>消费者监听指定的队列，根据需要设置回调函数</p></li><li><p>当有消息到达队列时broker将消息推送给消费者</p></li><li><p>消费者确认接受到消息</p></li><li><p>broker删除队列中已经确认的消息</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>RabbitMQ通常有如下应用场景：</p><ul><li>高并发场景消除峰值，让并发请求在MQ中排队</li><li>大数据处理，将数据放入MQ，多开几个消费者处理(如日志收集)</li><li>服务异步和解耦，使用MQ进行异步通信后，服务之间没有直接的调用关系，生产方通过MQ与消费方通信，将应用程序进行解耦</li><li>FIFO排序，保证数据按顺序消费</li></ul><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Windows系统中RabbitMQ可通过安装包下载(需要Erlang环境)，安装目录下启动图形化界面并重启服务</p><p><code>rabbitmq-plugins enable rabbitmq_management</code></p><p><code>rabbitmq-server stop</code></p><p><code>rabbitmq-server start</code></p><p>也可通过Dokcer下载镜像</p><p><code>docker pull rabbitmq:3-management</code></p><p>下载完成后启动容器(5672是程序连接的端口，15672是可视化界面接口)</p><p><code>docker run -id --name=rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management</code></p><h2 id="消息模型与交换机类型"><a href="#消息模型与交换机类型" class="headerlink" title="消息模型与交换机类型"></a>消息模型与交换机类型</h2><p>RabbitMQ包含以下5种消息模型</p><ul><li><p>Hello World简单模型，只需一个生产者、一个队列、一个消费者</p></li><li><p>Work Queue工作队列模型，多个消费者绑定到一个队列，共同消费队列中的消息，同一个消息只会被一个消费者消费。可使用prefetch防止某个消费者消费能力偏弱导致后续的消息阻塞</p></li><li><p>Publish&#x2F;Subscribe发布订阅模型(type&#x3D;fanout)，允许一个消息向多个消费者投递</p></li><li><p>Routing路由模型(type&#x3D;direct)，不同的消息可被不同的队列消费，通过一个routing key来收发消息</p></li><li><p>Topic通配符模型(type&#x3D;topic)，一种特殊的路由模式，在绑定队列时routing key可以使用通配符</p></li></ul><p>注: headers类型的路由不是用routing Key进行路由匹配，而是在匹配请求头中所带的键值进行路由</p><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>MQ消息在内存中进行读写，如果MQ宕机那么消息就要丢失的风险，我们需要可以通过交换机持久化、队列持久化等来防止消息丢失。</p><h2 id="签收机制"><a href="#签收机制" class="headerlink" title="签收机制"></a>签收机制</h2><p>RabbitMQ包含手动签收和自动签收2钟模式。</p><p>自动签收指MQ把消息投递给消费者后，消息默认被签收，MQ就会直接把消息删除掉。这种模式可能会导致消息丢失分享。</p><p>手动签收指MQ不会自动签收消息，而是把消息推送给消费者后，等到消费者自己去签收消息后，再删除队列中的消息，这种模式可以防止消息丢失。</p><h2 id="延迟队列和死信消息"><a href="#延迟队列和死信消息" class="headerlink" title="延迟队列和死信消息"></a>延迟队列和死信消息</h2><p>RabbitMQ可以给队列设置过期时间，也可以单独给每个消息设置过期时间，如果到了过期时间消息没被消费该消息就会标记为死信消息。根据这一特点，我们可以准备一个队列来接收死信交换机中的死信消息，然后准备一个消费者来消费该队列中的消息，这就是延迟队列。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a class="link"   href="https://www.rabbitmq.com/docs" >RabbitMQ官方文档<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ基本概念、安装配置、使用场景、消息模型，以及消息持久化、签收机制、延迟队列的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Middleware" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Middleware/"/>
    
    
    <category term="RabbitMQ" scheme="https://jocoboy.github.io/Hexo-Blog/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理与负载均衡</title>
    <link href="https://jocoboy.github.io/Hexo-Blog/2024/08/16/nginx-usage/"/>
    <id>https://jocoboy.github.io/Hexo-Blog/2024/08/16/nginx-usage/</id>
    <published>2024-08-16T06:04:51.000Z</published>
    <updated>2025-08-01T09:27:22.789Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx常用命令，反向代理与负载均衡实现方法，以及HTTPS配置。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是高性能的HTTP和反向代理的web服务器，处理高并发能力是十分强大，能支持高达50,000个并发连接数。Nginx支持热部署，启动简单，可以做到7*24不间断运行，几个月都不需要重新启动。Nginx适用于各种场景，包括静态文件服务、反向代理、负载均衡等。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="正向-反向代理"><a href="#正向-反向代理" class="headerlink" title="正向&#x2F;反向代理"></a>正向&#x2F;反向代理</h3><p>正向代理代理的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过何种方式访问的。</p><img   src="/Hexo-Blog/2024/08/16/nginx-usage/forward_proxy.png"  class="" title="正向代理架构图"><p>反向代理代理的是服务端，客户端对代理是无感知的，客户端不需要任何配置就可以访问。我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。</p><img   src="/Hexo-Blog/2024/08/16/nginx-usage/reverse_proxy.png"  class="" title="反向代理架构图"><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是指增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上。</p><p>Nignx提供了三种负载均衡的方式：轮询法(默认)、加权轮询、ip_hash。</p><p>这三种负载均衡方式可以组合使用，例如搭建三个服务器并完成反向代理，对应的配置文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 127.0.0.1:8000 weight=3;</span><br><span class="line">        server 127.0.0.1:8001;</span><br><span class="line">        server 127.0.0.1:8002;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        location /app &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>Nignx可通过包管理器、C语言编译、docker等方式安装。</p><p>Linux平台下，使用包管理器安装</p><p><code>sudo apt update</code></p><p><code>sudo apt install nginx</code></p><p>使用docker安装</p><p><code>docker pull nginx</code></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>启动nginx</p><p><code>nginx</code></p><p>查看nginx进程</p><p><code>ps -ef|grep nginx</code></p><p>查看nginx端口占用情况</p><p><code>lsof -i:[port]</code></p><p>停止nginx</p><p><code>nginx -s stop</code> 或 <code>nginx -s quit</code></p><p>重载配置文件</p><p><code>nginx reload</code></p><p>重新打开配置文件</p><p><code>nginx reopen</code></p><p>查看安装目录、编译参数、日志文件及配置文件位置</p><p><code>nginx -V</code></p><p>查看nginx配置文件</p><p><code>nginx -t</code></p><p>静态文件部署</p><p><code>cp -rf * [path]</code></p><h2 id="HTTPS配置"><a href="#HTTPS配置" class="headerlink" title="HTTPS配置"></a>HTTPS配置</h2><p>HTTPS协议需要使用SSL证书，在主流的云平台上都可以申请到免费的SSL证书，也可以通过openssl命令生成一个自签名的证书(未经过CA认证)。</p><h3 id="使用openssl生成证书"><a href="#使用openssl生成证书" class="headerlink" title="使用openssl生成证书"></a>使用openssl生成证书</h3><p>生成私钥文件(private key)</p><p><code>openssl genrsa -out private.key 2048</code></p><p>根据私钥生成证书签名请求文件(csr文件)</p><p><code>openssl req -new -key private.key -out cert.csr</code></p><p>使用私钥对证书申请进行签名从而生成证书文件(pem文件)</p><p><code>openssl x509 -req -in cert.csr -out cacert.pem -signkey private.key</code></p><h3 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        listen   443 ssl;</span><br><span class="line">        server_name         localhost;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        ssl_certificate_key www.example.com.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a class="link"   href="http://nginx.org/en/docs/" >Nignx官方文档<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx常用命令，反向代理与负载均衡实现方法，以及HTTPS配置。&lt;/p&gt;</summary>
    
    
    
    <category term="Web-Server" scheme="https://jocoboy.github.io/Hexo-Blog/categories/Web-Server/"/>
    
    
    <category term="Nginx" scheme="https://jocoboy.github.io/Hexo-Blog/tags/Nginx/"/>
    
  </entry>
  
</feed>
