<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>领域驱动设计与ABP框架</title>
    <url>/Hexo-Blog/2024/08/13/abp-and-ddd/</url>
    <content><![CDATA[<p>领域驱动设计核心概念与ABP框架实践。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ABP框架基于.NET和ASP.NET Core，是对领域驱动设计(Domain Driven Design，简称DDD)的一种实现，主要目标是为应用程序开发引入的一种架构方法。</p>
<blockquote>
<ul>
<li>.NET Framework仅支持Windows平台，适用于传统的Windows桌面和Web应用开发</li>
<li>.NET Core是一个全新的、从头开发的.NET 实现，支持跨平台，适用于构建现代化的云原生应用、微服务、跨平台应用等</li>
<li>.NET融合了.NET Core和.NET Framework的优点，支持跨平台，适用于各种类型的应用开发，包括桌面应用、Web 应用、云服务、移动应用等</li>
<li>ASP.NET是一个Web应用程序开发框架，仅支持Windows平台，使用.NET Framework运行时</li>
<li>ASP.NET Core是对ASP.NET的重构，更加轻量、高性能，支持跨平台，使用.NET Core运行时</li>
</ul>
</blockquote>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><p>领域驱动设计是一种针对复杂需求的软件开发方法，它适用于复杂领域和大规模应用，关注核心领域逻辑而不是基础设施细节。</p>
<h3 id="基本分层"><a href="#基本分层" class="headerlink" title="基本分层"></a>基本分层</h3><p>DDD分层设计包含表现层(Presentation Layer)、应用层(Application Layer)、领域层(Domain Layer)、基础设施层(Infrastructure Layer)四个部分。</p>
<ul>
<li>表现层包含应用的UI组件，通过API网关连接前端应用和后端微服务</li>
<li>应用层用于协调表现层和领域层，不包含领域逻辑，只负责调用领域层的功能</li>
<li>领域层包含基本的业务对象，是独立的可重用的领域逻辑，不依赖于任何层</li>
<li>基础设施层提供数据持久化、消息传递和第三方集成等服务，包括数据库访问层、消息队列等</li>
</ul>
<p>领域层和应用层是业务逻辑的核心部分。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层包含应用服务、数据传输对象(DTO)、工作单元(UOW)等基本概念。</p>
<ul>
<li>数据传输对象用于表现层和应用层之间传输数据</li>
<li>工作单元是事务边界，其中的所有状态更改必须以原子方式实现</li>
</ul>
<h4 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h4><p>领域层包含实体(Entity)、值对象(Value Object)、聚合(Aggregate)和聚合根(AggregateRoot)、仓储(IRepository)、领域服务(Domain Service)、领域事件(Domain Event)等基本概念。</p>
<ul>
<li>值对象与实体不同之处在于，没有唯一标识符，如果两个值对象的所有属性都相同，则它们被认为是相同的(c# 9.0中record新特性与此类似)</li>
<li>聚合根通常是一个具有唯一标识(‌如GUID)的实体，‌它负责协调聚合内部的其他实体和值对象，‌确保数据的一致性和完整性</li>
<li>领域服务是实现核心业务规则的无状态服务(类命名通常以Manager为结尾)，它的实现依赖于多种聚合或外部服务</li>
</ul>
<h2 id="ABP框架"><a href="#ABP框架" class="headerlink" title="ABP框架"></a>ABP框架</h2><p>在使用ABP框架时，需要特别注意项目之间的引用和依赖关系。</p>
<h3 id="设计演变"><a href="#设计演变" class="headerlink" title="设计演变"></a>设计演变</h3><p>按照DDD的最初设计，ABP框架应当包含以下四个部分</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].Infrastructure</li>
</ul>
<p>基础设施层通常需要包含一种对象关系映射(ORM)方式，ABP中使用了EntityFrameworkCore，<br>由此框架演变为</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].EntityFrameworkCore</li>
</ul>
<p>由于Web层直接引用Application，而Application直接引用Domain，这将导致Application间接引用Domain，这不符合抽象和实现分层原则，因此ABP引入了Application.Contracts</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application.Contracts</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].EntityFrameworkCore</li>
</ul>
<p>由于我们将接口定义和DTO存放在了Application.Contracts，而DTO有时需要重用Domain中的枚举类型，但Application.Contracts又无法直接添加对Domain的引用，为了解决这个问题，ABP引入了Domain.Shared</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].Application.Contracts</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].Domain.Shared</li>
<li>[company].[application].EntityFrameworkCore</li>
</ul>
<p>为了将REST API与UI分离，ABP引入了HttpApi，此外还引入了HttpApi.Client客户端代理系统和数据库迁移工具DbMigrator，由此完整的项目框架为</p>
<ul>
<li>[company].[application].Web</li>
<li>[company].[application].HttpApi</li>
<li>[company].[application].HttpApi.Client</li>
<li>[company].[application].Application.Contracts</li>
<li>[company].[application].Application</li>
<li>[company].[application].Domain</li>
<li>[company].[application].Domain.Shared</li>
<li>[company].[application].EntityFrameworkCore</li>
<li>[company].[application].DbMigrator</li>
</ul>
<img   src="/Hexo-Blog/2024/08/13/abp-and-ddd/abp_layer_deps.png"  class="" title="ABP框架中各层之间的依赖关系">

<p>从上图可以看出，Domain层无法直接使用Application.Contracts中的DTO，必要时可使用Domain.Shared中的Value Object代替DTO。</p>
<p>此外，ABP框架中test文件夹中还包含了每一层单独配置的单元&#x2F;集成测试项目。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="安装cli"><a href="#安装cli" class="headerlink" title="安装cli"></a>安装cli</h4><p>使用donet tool命令行工具下载abp-cli(第一代)</p>
<p><code>dotnet tool install -g Volo.Abp.Cli</code></p>
<p>查看是否安装成功</p>
<p><code>dotnet tool list -g</code></p>
<h4 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h4><p>EFCore提供了一套原生的数据库迁移系统，基于Code First原则。</p>
<p>在Domain层创建好相关实体后，将EntityFrameworkCore模块设为启动项目，打开Nuget Package Manager Console输入以下命令</p>
<p><code>Add-Migration &quot;Initial&quot;</code></p>
<p><code>Update-Database</code></p>
<p>最后将DbMigrator模块设为启动项后，运行即可完成种子数据迁移</p>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="PGSQL时间类型问题"><a href="#PGSQL时间类型问题" class="headerlink" title="PGSQL时间类型问题"></a>PGSQL时间类型问题</h4><p><a class="link"   href="https://github.com/abpframework/abp/issues/11437" >PGSQL issues with 5.1.2 (and earlier, due to Npgsql 6+) #11437<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>Cannot write DateTime with Kind&#x3D;Local to PostgreSQL type ‘timestamp with time zone’, only UTC is supported.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// adding the below to the WebModule, DbMigratorModule and TestBaseModule </span></span><br><span class="line"><span class="comment">// if postgres is used there as well</span></span><br><span class="line">Configure&lt;AbpClockOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Kind = DateTimeKind.Utc;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="Autofac依赖注入问题"><a href="#Autofac依赖注入问题" class="headerlink" title="Autofac依赖注入问题"></a>Autofac依赖注入问题</h4><blockquote>
<p>Autofac.Core.DependencyResolutionException:<br>An exception was thrown while activating xxxController -&gt; xxxAppService.<br>—&gt; Autofac.Core.DependencyResolutionException:<br>None of the constructors found on type ‘xxxAppService’ can be invoked with the available services and parameters:<br>Cannot resolve parameter<br>‘Microsoft.AspNetCore.Identity.SignInManager`1[Volo.Abp.Identity.IdentityUser] signInManager’ of constructor<br>‘Void .ctor(Microsoft.AspNetCore.Identity.SignInManager&#96;1[Volo.Abp.Identity.IdentityUser], …)’.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add AbpIdentityAspNetCoreModule to your WebModule,</span></span><br><span class="line"><span class="comment">// be careful about the difference between Volo.Abp.Identity.AspNetCore and Microsoft.AspNetCore.Identity</span></span><br><span class="line">[<span class="meta">DependsOn(</span></span><br><span class="line"><span class="meta">    ...</span></span><br><span class="line"><span class="meta">    typeof(AbpIdentityAspNetCoreModule)</span></span><br><span class="line"><span class="meta">    )</span>]</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a class="link"   href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history#c-version-9" >C# 9.0 新特性<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://abp.io/docs/latest/" >ABP官方文档<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=vs" >EFCore数据库迁移<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>ABP</tag>
        <tag>.NET</tag>
        <tag>ASP.NET Core</tag>
      </tags>
  </entry>
  <entry>
    <title>AI大模型本地部署</title>
    <url>/Hexo-Blog/2025/07/17/ai-model-on-premise/</url>
    <content><![CDATA[<p>使用大模型部署和管理工具Ollama在本地部署AI大模型，并使用基于大语言模型和RAG的知识库问答系统MaxKB为大模型添加UI界面。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本地部署AI模型可以确保数据隐私和安全，降低长期成本，并提供更高的性能和控制权。本地部署AI模型的方案有很多，例如使用桌面应用程序LMstudio、使用大模型命令行部署和管理工具Ollama等。</p>
<p>本地大模型部署完成后，通常还需要添加UI界面，可以使用MaxKB、OpenWebUI等。二者侧重点不同，MaxKB侧重于为大模型添加关联知识库，OpenWebUI侧重于大模型的使用和管理。</p>
<h2 id="Ollama"><a href="#Ollama" class="headerlink" title="Ollama"></a>Ollama</h2><p>Ollama是一个命令行大模型部署和管理工具，可以用它将类似deepseek-r1这样的AI大模型部署到本地。Ollama支持运行Llama 3、Phi 3、Mistral、Gemma和其他模型，并允许定制和创建自己的模型。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>Ollama支持MacOS、Linux、Windows等多种操作系统，在<a class="link"   href="https://ollama.com/" >Ollama官网<i class="fas fa-external-link-alt"></i></a>下载安装Ollama后，输入地址<code>http://localhost:11434/</code>可查看Ollama是否成功运行。</p>
<p>可以使用<code>ollama run [model-name]</code>命令下载并运行AI模型，下载完成后可以使用命令行进行对话，对话响应速度和显卡性能有关，输入<code>&gt;&gt;&gt; /bye</code>可以结束当前对话。使用<code>ollama list</code>命令可查看当前已下载的AI模型。</p>
<h3 id="Rest-API方式交互"><a href="#Rest-API方式交互" class="headerlink" title="Rest API方式交互"></a>Rest API方式交互</h3><p>除了命令行交互的方式，Ollama同样支持REST API的方式管理和运行大模型。</p>
<p>例如<code>POST /api/generate</code>使用提供的模型为给定提示生成响应，对应curl命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://localhost:11434/api/generate -d &#x27;&#123;</span><br><span class="line">  &quot;model&quot;: &quot;deepseek-r1&quot;,</span><br><span class="line">  &quot;prompt&quot;: &quot;Why is the sky blue?&quot;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="MaxKB"><a href="#MaxKB" class="headerlink" title="MaxKB"></a>MaxKB</h2><p>MaxKB是一个基于大语言模型和RAG的知识库问答系统。</p>
<h3 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h3><p>检索增强生成RAG(Retrieval-Augmented Generation)是一种结合了信息检索技术与语言生成模型的人工智能技术。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>由于大模型都是基于预训练的数据集训练出来的，如果你的问题超出了这个数据集的范围，那么它生成的内容很可能是不够准确的，也称为大模型的幻觉。</p>
<p>为了解决这个问题，通常需要将检索模型和生成模型结合在一起，通过从外部数据源添加一些上下文和背景知识，确保大模型有足够的信息来生成更加准确和可靠的答案。</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><img   src="/Hexo-Blog/2025/07/17/ai-model-on-premise/rag_workflow.png"  class="" title="RAG工作流程">

<p>首先用户提出问题后，这个问题会被作为一个查询条件，从你的向量化知识库中进行检索，找到最相关的信息或文档，然后这些信息和文档会随着问题一起输入到大模型中，最后大模型会根据这些信息来生成答案，确保生成的答案更加准确和可靠。</p>
<h3 id="安装和部署"><a href="#安装和部署" class="headerlink" title="安装和部署"></a>安装和部署</h3><p>由于MaxKB只支持Linux系统(Unbuntu和CentOS等)上使用，在Windows上使用需要借助Docker。</p>
<p>可以使用以下命令下载MaxKB镜像到本地，创建并启动一个MaxKB容器。</p>
<p><code>docker run -d --name=maxkb -p 8088:8080 -v ~/.maxkb:/var/lib/postgresql/data 1panel/maxkb</code></p>
<p>启动后输入网址<code>http://localhost:8088</code>即可访问，默认账号为<code>admin</code>，密码为<code>MaxKB@123..</code>。</p>
<p>登录后点击模型设置，选择Ollama并点击添加模型，填写模型相关信息后会自动下载大模型，其中API URL填写<code>http://host.docker.internal:11434</code>。添加完成后点击应用，点击设置填写相关应用信息即可完成创建。</p>
<blockquote>
<p>注：host.docker.internal是Docker提供的一个特殊DNS名称，指向宿主机(Host)的内部IP地址。当容器需要访问宿主机上运行的服务(如数据库、API或其他应用)时，可以使用这个地址。</p>
</blockquote>
<h2 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h2><p>为了将AI大模型应用分享给其他人，需要使用ngrok。ngrok是一款强大的内网穿透工具，可帮助用户将本地服务暴露到公网，实现在外网访问本地服务。</p>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>在<a class="link"   href="https://ngrok.com/" >ngrok官网<i class="fas fa-external-link-alt"></i></a>下载安装ngrok，下载完成后登录ngrok个人账号，复制AUTHTOKEN，并执行<code>ngrok config add-authtoken $YOUR_AUTHTOKEN</code>命令即可完成配置。</p>
<p>配置完成后即可使用ngrok映射大模型应用，输入<code>ngrok http 8088</code>将会回显一个Forwarding地址，这个地址就是ngrok为我们映射的公网地址，将其替换<code>http://localhost:8088</code>即可。</p>
<p>注：对于所有HTTP请求，ngrok默认会返回一个html的警告页面，可在上述命令中添加参数<code>--request-header-add ngrok-skip-browser-warning:true</code>跳过此警告。</p>
<p>除此之外，还可以通过修改<code>%HOMEPATH%\AppData\Local\ngrok</code>目录下的ngrok.yml配置文件来实现。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">agent:</span></span><br><span class="line">    <span class="attr">authtoken:</span> <span class="string">&#x27;your-authtoken&#x27;</span></span><br><span class="line"><span class="attr">tunnels:</span></span><br><span class="line">  <span class="attr">example:</span></span><br><span class="line">    <span class="attr">proto:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">addr:</span> <span class="number">8088</span></span><br><span class="line">    <span class="attr">request_header:</span></span><br><span class="line">      <span class="attr">add:</span> [<span class="string">&quot;ngrok-skip-browser-warning: true&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>修改完成后使用命令<code>ngrok start --all</code>即可启动服务。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://github.com/ollama/ollama/blob/main/docs/api.md" >Ollama API文档参考<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://maxkb.cn/docs/v2/installation/offline_installtion/" >MaxKB官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://ngrok.com/docs" >ngrok官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Artificial-Intelligence</category>
      </categories>
      <tags>
        <tag>Ollama</tag>
        <tag>MaxKB</tag>
        <tag>RAG</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 实现定时后台任务</title>
    <url>/Hexo-Blog/2025/01/06/background-service/</url>
    <content><![CDATA[<p>.NET Core实现定时后台任务的几种方法。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发应用时，定时任务是一个常见的需求。它可以自动化周期性的操作，例如定期同步数据、定时清理缓存、发送通知等。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>数据处理<ul>
<li>数据同步：定时从外部数据源（如数据库、API等）同步数据到本地系统</li>
<li>数据备份：定期备份数据库或文件系统中的数据，以防止数据丢失</li>
</ul>
</li>
<li>系统维护<ul>
<li>缓存更新：定时刷新缓存数据，确保缓存中的数据是最新的</li>
<li>日志清理：定时清理日志文件，防止日志文件占用过多磁盘空间</li>
</ul>
</li>
<li>任务调度<ul>
<li>定时任务调度：根据预设的时间表或条件，自动执行特定的任务。例如，每天凌晨自动执行数据备份任务</li>
<li>任务队列处理：定时从任务队列中取出任务并执行，适用于需要异步处理的场景</li>
</ul>
</li>
<li>用户交互<ul>
<li>定时通知：定时向用户发送通知或提醒，例如发送邮件、短信或应用内通知</li>
</ul>
</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="基于IHostedService接口实现自定义后台服务"><a href="#基于IHostedService接口实现自定义后台服务" class="headerlink" title="基于IHostedService接口实现自定义后台服务"></a>基于IHostedService接口实现自定义后台服务</h3><p>定时后台任务使用System.Threading.Timer类。在StartAsync上使用计时器执行DoWork任务，在StopAsync上禁用计时器，并在Dispose上处置服务容器时处置计时器。</p>
<p>Timer不等待先前的DoWork执行完成。使用Interlocked.Increment以原子操作的形式将执行计数器递增，这可确保多个线程不会并行更新executionCount。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>首先创建自定义的后台服务类，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimedHostedService</span> : <span class="title">IHostedService</span>, <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> executionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;TimedHostedService&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> Timer _timer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimedHostedService</span>(<span class="params">ILogger&lt;TimedHostedService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">&quot;Timed Hosted Service running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        _timer = <span class="keyword">new</span> Timer(DoWork, <span class="literal">null</span>, TimeSpan.Zero,</span><br><span class="line">            TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> count = Interlocked.Increment(<span class="keyword">ref</span> executionCount);</span><br><span class="line"></span><br><span class="line">        _logger.LogInformation(</span><br><span class="line">            <span class="string">&quot;Timed Hosted Service is working. Count: &#123;Count&#125;&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">&quot;Timed Hosted Service is stopping.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        _timer?.Change(Timeout.Infinite, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _timer?.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Startup中注册服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddHostedService&lt;TimedHostedService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用BackgroundService"><a href="#使用BackgroundService" class="headerlink" title="使用BackgroundService"></a>使用BackgroundService</h3><p>BackgroundService是用于实现长时间运行的IHostedService的基类，是IHostedService的一个简单实现。</p>
<p>StartAsync应仅限于短期任务，因为托管服务是按顺序运行的，在StartAsync运行完成之前不会启动其他服务。长期任务应放置在ExecuteAsync中。</p>
<h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>首先创建服务类，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WorkService</span> : <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> executionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WorkService&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> DateTime nextDateTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkService</span>(<span class="params">ILogger&lt;WorkService&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> StartHour = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> StartMinute = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> StartSecond = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> IntervalMinute = <span class="number">1440</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算下一个时间节点</span></span><br><span class="line">            <span class="keyword">var</span> now = DateTime.Now;</span><br><span class="line">            <span class="keyword">var</span> firstDateTime = <span class="keyword">new</span> DateTime(now.Year, now.Month, now.Day, StartHour, StartMinute, StartSecond);</span><br><span class="line">            <span class="keyword">if</span>(executionCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = firstDateTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = nextDateTime.AddMinutes(IntervalMinute);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nextDateTime &lt; now)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime.AddDays(<span class="number">1</span>) - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">                <span class="keyword">await</span> DoWork();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> count = Interlocked.Increment(<span class="keyword">ref</span> executionCount);</span><br><span class="line">                _logger.LogInformation(<span class="string">&quot;Timed Hosted Service is working. Count: &#123;Count&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DoWork</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建后台服务调用类，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomBackgroundService</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _services;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomBackgroundService</span>(<span class="params">IServiceProvider services</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _services = services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> scope = _services.CreateScope();</span><br><span class="line">        <span class="comment">//获取服务类</span></span><br><span class="line">        <span class="keyword">var</span> taskWorkService = scope.ServiceProvider.GetRequiredService&lt;IWorkService&gt;();</span><br><span class="line">        <span class="comment">//执行服务类的定时任务</span></span><br><span class="line">        <span class="keyword">await</span> taskWorkService.TaskWorkAsync(stoppingToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在Startup中注册后台服务，并添加主机服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddScoped&lt;IWorkService, WorkService&gt;();</span><br><span class="line">    services.AddHostedService&lt;CustomBackgroundService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/timer-service" >如何实现IHostedService接口<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&tabs=visual-studio" >如何在ASP.NET Core中使用托管服务实现后台任务<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>ASP.NET Core</tag>
        <tag>BackgroundJob</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成、交付与部署CI/CD及Jenkins</title>
    <url>/Hexo-Blog/2024/08/25/ci-and-cd/</url>
    <content><![CDATA[<p>持续集成、交付与部署CI&#x2F;CD基本概念、流程，以及使用Jenkins实现自动化部署。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CI&#x2F;CD是持续集成(Continuous Integration，CI)、持续交付(Continuous Delivery，CD)与持续部署(Continuous Deployment，CD)的简称。</p>
<p>CI&#x2F;CD是实现敏捷开发和Devops理念的一种方法，可让持续自动化和持续监控贯穿于应用的整个生命周期。这些关联的事务通常被统称为CI&#x2F;CD管道(Pipeline)，由开发(RD)、测试(QA)、运维(OP)团队以敏捷方式协同支持。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><img   src="/Hexo-Blog/2024/08/25/ci-and-cd/ci_step.png"  class="" title="持续集成流程图">

<p>持续集成(CI)指的是高频率地将代码合入主干，在合入之前触发单元测试去验证代码的改动，确保改动不会对应用造成破坏。</p>
<p>持续集成强调开发人员提交了新的代码后，立刻进行构建、(单元)测试。根据测试结果，我们可以确定新代码能否和原代码正确地集成在一起。</p>
<h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><img   src="/Hexo-Blog/2024/08/25/ci-and-cd/cd_step.png"  class="" title="持续交付流程图">

<p>持续交付(CD)指的是频繁地将软件的新版本，交付给质量团队或者用户、以供评审。如果评审通过，代码就会进入生产阶段。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p>
<p>持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的类生产环境中。比如完成单元测试后，可以将代码部署到连接数据库的Staging环境中进行更多的(集成)测试。如果代码没有问题，可以继续手动部署到生产环境中。</p>
<h3 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><img   src="/Hexo-Blog/2024/08/25/ci-and-cd/cd_step_2.png"  class="" title="持续部署流程图">

<p>持续部署(CD)是持续交付的下一步，指的是代码通过评审后，自动部署到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的自动化测试。</p>
<h2 id="CI-CD流程"><a href="#CI-CD流程" class="headerlink" title="CI&#x2F;CD流程"></a>CI&#x2F;CD流程</h2><p>根据CI&#x2F;CD的设计，代码从提交到生产，有以下几个步骤：</p>
<ul>
<li>提交：开发者向代码仓库提交一次代码</li>
<li>测试(第一轮)：代码仓库对commit操作配置了hook，只要提交了代码或者合并到主分支，就会跑自动化测试。测试的种类分为：<ul>
<li>单元测试(针对函数或模块的测试)</li>
<li>集成测试(针对产品的某个功能的测试)</li>
<li>端到端测试(从用户界面直达数据库的全链路测试)</li>
</ul>
</li>
<li>构建：将源码转换为可以运行的实际代码，如安装依赖、配置各种资源等。常用的构建工具有：<ul>
<li>Jenkins</li>
<li>Travis CI</li>
<li>GitLab CI&#x2F;CD</li>
</ul>
</li>
<li>测试(第二轮)：对第一轮测试的补充，可省略</li>
<li>部署：将可部署的版本中的所有文件打包到生产服务器上，生产服务器将打包文件解包成本地目录，再将运行路径符号链接指向这个目录，然后重新启动应用。</li>
<li>回滚：一但当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法是修改链接符号，指向上一个版本的目录</li>
</ul>
<h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>Jenkins是一个开源的实现持续集成的工具。Jenkins能实时监控集成中的存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式展示项目构建的趋势和稳定性。</p>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><p>使用Docker下载Jenkins镜像</p>
<p><code>docker pull jenkins/jekins:lts</code></p>
<p>创建目录并更改权限</p>
<p><code>mkdir -p /mydata/jenkins_home</code></p>
<p><code>chmod 777 /mydata/jenkins_home</code></p>
<p>运行Jenkins容器</p>
<p><code>docker run -di --name=jenkins -p [host-port]:[container-port] -v /mydata/jenkins_home/:/var/jenkins_home/ jenkins/jekins:lts</code></p>
<p>查看Jenkins运行是否成功</p>
<p><code>docker ps -a</code></p>
<h3 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h3><p>通过docker启动日志获取Jenkins控制台解锁密码</p>
<p><code>docker logs jenkins</code></p>
<p>输入解锁密码后填写信息创建一个管理员用户。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>可通过Jenkins控制台的系统管理&gt;插件管理在线安装插件，也可到官网下载hpi插件文件然后上传使用。</p>
<h3 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h3><p>可通过Jenkins控制台的系统管理&gt;全局工具配置，配置JDK、Git、Maven等运行环境。</p>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><ul>
<li>通过Jenkins控制台安装SSH插件</li>
<li>通过凭据&gt;全局添加服务器账号密码的凭据</li>
<li>通过系统管理&gt;系统配置，添加SSH remote hosts，主机名为服务器IP，端口默认22</li>
</ul>
<h3 id="创建自动构建任务"><a href="#创建自动构建任务" class="headerlink" title="创建自动构建任务"></a>创建自动构建任务</h3><p>可通过Jenkins控制台的新建任务&gt;构建一个自由风格的软件项目新建一个任务，在源码管理添加Git远程仓库(需要添加Git账号密码凭据)，构建环境选择Delete workspace before build starts，并增加构建步骤(添加执行shell，或添加使用SSH在远程服务器上执行脚本)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">app_name=[jenkinsdemo]</span><br><span class="line"><span class="built_in">cd</span> /var/lib/jenkins/workspace/<span class="variable">$&#123;app_name&#125;</span>/[project_name]</span><br><span class="line">docker container prune &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">docker container <span class="built_in">ls</span> -a | grep <span class="string">&quot;<span class="variable">$&#123;app_name&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    docker container stop <span class="variable">$&#123;app_name&#125;</span></span><br><span class="line">    docker container <span class="built_in">rm</span> <span class="variable">$&#123;app_name&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">docker image prune &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">docker build -t <span class="variable">$&#123;app_name&#125;</span> .</span><br><span class="line">docker run -d --name=<span class="variable">$&#123;app_name&#125;</span> -p [host-port]:[container-port]  <span class="variable">$&#123;app_name&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a class="link"   href="https://www.jenkins.io/zh/doc/" >Jenkins官方文档<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>Devops</tag>
        <tag>Jenkins</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>C#进阶语法</title>
    <url>/Hexo-Blog/2025/03/20/csharp-advanced-usage/</url>
    <content><![CDATA[<p>c#进阶语法，包含委托与事件、动态类型与泛型、并发访问控制等。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>c#中的一些进阶语法使用记录，包含委托(Delegate)与事件(Event)、动态类型(Dynamic Types)与泛型(Generics)、并发访问控制(信号量、并发字典)等。 </p>
<h2 id="委托与事件"><a href="#委托与事件" class="headerlink" title="委托与事件"></a>委托与事件</h2><h3 id="委托-Delegate"><a href="#委托-Delegate" class="headerlink" title="委托(Delegate)"></a>委托(Delegate)</h3><p>在C#中，委托(Delegate)是一种类型安全的函数指针，用于封装一个或多个方法。委托允许你将方法作为参数传递、存储方法引用，并支持事件和回调机制。委托是C#中实现事件驱动编程和多播委托的基础。</p>
<p>下面是一个委托定义、实例化和调用的示例:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MathOperation</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义符合委托签名的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a - b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化委托</span></span><br><span class="line">        MathOperation operation = Add;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用委托</span></span><br><span class="line">        <span class="built_in">int</span> result = operation(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Addition Result: <span class="subst">&#123;result&#125;</span>&quot;</span>); <span class="comment">// 输出: Addition Result: 15</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新指向另一个方法</span></span><br><span class="line">        operation = Subtract;</span><br><span class="line">        result = operation(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Subtraction Result: <span class="subst">&#123;result&#125;</span>&quot;</span>); <span class="comment">// 输出: Subtraction Result: 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#支持匿名方法和Lambda表达式，简化了委托的使用，上面的委托实例化可以简写为：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MathOperation operation = <span class="built_in">delegate</span>(<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// 匿名方法</span></span><br><span class="line">MathOperation operation = (a, b) =&gt; a + b; <span class="comment">// Lambda表达式</span></span><br></pre></td></tr></table></figure>

<p>委托可以指向多个方法，称为多播委托。通过+&#x3D;和-&#x3D;运算符，可以添加或移除方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义符合委托签名的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;Message: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowWarning</span>(<span class="params"><span class="built_in">string</span> message</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;Warning: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实例化多播委托</span></span><br><span class="line">        DisplayMessage display = ShowMessage;</span><br><span class="line">        display += ShowWarning; <span class="comment">// 添加第二个方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用多播委托（会依次调用所有方法）</span></span><br><span class="line">        display(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#提供了几种内置的泛型委托类型，避免了手动定义委托。</p>
<ul>
<li><p>Action: 表示没有返回值的方法，最多支持16个参数。示例：</p>
  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; print = message =&gt; Console.WriteLine(message);</span><br><span class="line">print(<span class="string">&quot;Hello, Action!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Func: 表示有返回值的方法，最后一个泛型参数是返回值类型。示例：</p>
  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt; a + b;</span><br><span class="line"><span class="built_in">int</span> result = <span class="keyword">add</span>(<span class="number">10</span>, <span class="number">5</span>); </span><br></pre></td></tr></table></figure>
</li>
<li><p>Predicate: 表示返回布尔值的方法，通常用于条件判断。</p>
  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Predicate&lt;<span class="built_in">int</span>&gt; isEven = num =&gt; num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bool</span> result = isEven(<span class="number">10</span>); </span><br></pre></td></tr></table></figure></li>
</ul>
<p>委托的应用场景有很多，例如事件处理、回调机制(将方法作为参数传递给其他方法，用于异步编程或延迟执行)、LINQ查询等。</p>
<h3 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件(Event)"></a>事件(Event)</h3><p>委托是C#事件的基础。在C#中，事件(Event)是一种特殊的委托，用于实现发布-订阅模式(观察者模式)。事件允许一个类(发布者)通知其他类(订阅者)某些事情发生了。事件的核心是委托，它定义了事件处理方法的签名。</p>
<p>下面是一个事件的定义、触发、订阅和取消的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler OnMessageReceived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Publisher: Sending message - <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        OnMessageReceived?.Invoke(message); <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Subscriber: Received message - <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建发布者和订阅者</span></span><br><span class="line">        Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.OnMessageReceived += subscriber.HandleMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布者发送消息，触发事件</span></span><br><span class="line">        publisher.SendMessage(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅事件</span></span><br><span class="line">        publisher.OnMessageReceived -= subscriber.HandleMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次发送消息，不会触发事件</span></span><br><span class="line">        publisher.SendMessage(<span class="string">&quot;This message will not be received.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#提供了标准的EventHandler委托和EventArgs类，推荐使用它们来定义事件，下面是一个使用示例(调用方式同上)：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;CustomEventArgs&gt; OnMessageReceived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Publisher: Sending message - <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        OnMessageReceived?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> CustomEventArgs &#123; Message = message &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleMessage</span>(<span class="params"><span class="built_in">object</span> sender, CustomEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Subscriber: Received message - <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件的使用场景有很多，例如用户界面事件、异步编程事件(如文件下载完成事件)、自定义通知机制(如状态更新)等。</p>
<h2 id="动态类型与泛型"><a href="#动态类型与泛型" class="headerlink" title="动态类型与泛型"></a>动态类型与泛型</h2><h3 id="动态类型-Dynamic-Types"><a href="#动态类型-Dynamic-Types" class="headerlink" title="动态类型(Dynamic Types)"></a>动态类型(Dynamic Types)</h3><p>dynamic是c#中的一个动态类型，属性的访问是在运行时解析的，因此需要确保运行时对象具有你访问的属性。</p>
<p>可以通过下面的方式创建一个dynamic对象：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> item = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Alice&quot;</span>, Age = <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>要对<code>List&lt;dynamic&gt;</code>使用Where语句，可通过反射检查属性是否存在，确保dynamic对象具有需要访问的属性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">dynamic</span>&gt; dynamicList = <span class="keyword">new</span> List&lt;<span class="built_in">dynamic</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Alice&quot;</span>, Age = <span class="number">25</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Bob&quot;</span>, Age = <span class="number">30</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Charlie&quot;</span>, Age = <span class="number">20</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dynamicList = dynamicList.Where(item =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> property = item.GetType().GetProperty(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> property != <span class="literal">null</span> &amp;&amp; (<span class="built_in">string</span>)property.GetValue(item) != <span class="string">&quot;Charlie&quot;</span>;</span><br><span class="line">&#125;).ToList();</span><br></pre></td></tr></table></figure>

<p>dynamic是提供用于在运行时指定动态行为的基类。必须继承此类；不能直接对其进行实例化。通常用到的是它的继承类ExpandoObject。</p>
<p><code>System.Dynamic.ExpandoObject</code>是一个动态对象，允许在运行时添加或删除属性。它可以像字典一样操作(实现了 <code>IDictionary&lt;string, object&gt;</code>)，也可以像普通对象一样访问属性。</p>
<p>可以通过下面的方式创建一个ExpandoObject对象：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> item = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item.Name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">item.Age = <span class="number">25</span>;</span><br><span class="line">Console.WriteLine(((IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)item)[<span class="string">&quot;Name&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>要对<code>List&lt;ExpandoObject&gt;</code>使用Where语句，通常需要将其视为<code>IDictionary&lt;string, object&gt;</code>，然后根据键值对进行过滤。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;ExpandoObject&gt; expandoList = <span class="keyword">new</span> List&lt;ExpandoObject&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> item1 = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item1.Name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">item1.Age = <span class="number">25</span>;</span><br><span class="line">expandoList.Add(item1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> item2 = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item2.Name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">item2.Age = <span class="number">30</span>;</span><br><span class="line">expandoList.Add(item2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> item3 = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">item3.Name = <span class="string">&quot;Charlie&quot;</span>;</span><br><span class="line">item3.Age = <span class="number">20</span>;</span><br><span class="line">expandoList.Add(item3);</span><br><span class="line"></span><br><span class="line">expandoList = expandoList.Where(item =&gt;</span><br><span class="line">                            ((IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)item).ContainsKey(<span class="string">&quot;Name&quot;</span>) &amp;&amp;</span><br><span class="line">                            (<span class="built_in">string</span>)((IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)item)[<span class="string">&quot;Name&quot;</span>] != <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">                        ).ToList();</span><br></pre></td></tr></table></figure>

<h3 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(Generics)</h3><p>在C#中，泛型允许你编写可以处理多种类型的代码，而无需为每种类型重复编写逻辑。泛型在编译时确定类型，并提供类型安全和性能优势。</p>
<p>泛型(Generics)和动态类型(Dynamic Types)是两种不同的特性，用于处理类型不确定的场景。它们的主要区别在于类型检查的时机、安全性、性能和使用场景等。以下是他们的主要区别：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>泛型(Generics)</th>
<th>动态类型(Dynamic Types)</th>
</tr>
</thead>
<tbody><tr>
<td>类型检查时机</td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td>类型安全</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>性能</td>
<td>高性能(避免装箱和拆箱)</td>
<td>较低(运行时解析类型)</td>
</tr>
<tr>
<td>灵活性</td>
<td>较低(类型在编译时确定)</td>
<td>高(类型在运行时确定)</td>
</tr>
<tr>
<td>适用场景</td>
<td>类型安全的通用代码、集合类、高性能场景</td>
<td>动态语言交互、未知类型处理、灵活性需求</td>
</tr>
</tbody></table>
<h2 id="并发访问控制"><a href="#并发访问控制" class="headerlink" title="并发访问控制"></a>并发访问控制</h2><h3 id="信号量Semaphore与SemaphoreSlim"><a href="#信号量Semaphore与SemaphoreSlim" class="headerlink" title="信号量Semaphore与SemaphoreSlim"></a>信号量Semaphore与SemaphoreSlim</h3><p>Semaphore和SemaphoreSlim是.NET中用于控制并发访问的同步原语，他们的主要区别如下：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>Semaphore</th>
<th>SemaphoreSlim</th>
</tr>
</thead>
<tbody><tr>
<td>跨进程支持</td>
<td>支持跨进程同步，可以用于不同进程之间的线程同步</td>
<td>仅支持单进程内的线程同步</td>
</tr>
<tr>
<td>性能</td>
<td>性能相对较低，因为它依赖于操作系统内核对象</td>
<td>性能更高，因为它完全基于.NET运行时</td>
</tr>
<tr>
<td>异步支持</td>
<td>不支持异步操作</td>
<td>支持异步操作</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于需要跨进程同步的场景</td>
<td>适用于单进程内需要高性能同步的场景</td>
</tr>
</tbody></table>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore用于限制可同时访问某一资源或资源池的线程数。下面是一个简单的使用示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个信号量，初始计数为0，最大计数为3</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">semaphore.WaitOne();</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">semaphore.Release();</span><br></pre></td></tr></table></figure>

<ul>
<li>Semaphore第一个参数是初始计数initialCount，代表未执行Release方法之前允许通过的信号量</li>
<li>Semaphore第二个参数是最大计数maximumCount，代表执行Release方法之后允许通过的最大信号量</li>
<li>释放之前的数量加上释放数量releaseCount应当不超过最大计数，即Release(releaseCount) + releaseCount &lt;&#x3D; maximumCount，其中Release(releaseCount)初始值为initialCount</li>
</ul>
<p>以下示例展示了信号量Semaphore是如何控制并发访问的：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore _semaphore;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _padding;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>(<span class="params"><span class="built_in">object</span> num</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 开始并等待进入信号量.&quot;</span>, num);</span><br><span class="line">        _semaphore.WaitOne();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> padding = Interlocked.Add(<span class="keyword">ref</span> _padding, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 进入信号量.&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">1000</span> + padding);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 从信号量中释放.&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 释放之前信号量中的可用资源数: &#123;1&#125;&quot;</span>,</span><br><span class="line">            num, _semaphore.Release());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _semaphore = <span class="keyword">new</span> Semaphore(initialCount: <span class="number">1</span>, maximumCount: <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(Worker));</span><br><span class="line"></span><br><span class="line">            t.Start(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> releaseCount = <span class="number">4</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;主线程尝试释放<span class="subst">&#123;releaseCount&#125;</span>个资源&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            _semaphore.Release(releaseCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主线程退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出内容如下：</p>
<blockquote>
<p>线程 2 开始并等待进入信号量.<br>线程 5 开始并等待进入信号量.<br>线程 3 开始并等待进入信号量.<br>线程 1 开始并等待进入信号量.<br>线程 4 开始并等待进入信号量.<br>线程 2 进入信号量.<br>主线程尝试释放4个资源<br>主线程退出<br>线程 3 进入信号量.<br>线程 5 进入信号量.<br>线程 4 进入信号量.<br>线程 1 进入信号量.<br>线程 2 从信号量中释放.<br>线程 2 释放之前信号量中的可用资源数: 0<br>线程 5 从信号量中释放.<br>线程 5 释放之前信号量中的可用资源数: 1<br>线程 1 从信号量中释放.<br>线程 1 释放之前信号量中的可用资源数: 2<br>线程 3 从信号量中释放.<br>线程 3 释放之前信号量中的可用资源数: 3<br>线程 4 从信号量中释放.<br>警告: 释放数量超过信号量最大计数！</p>
</blockquote>
<h4 id="SemaphoreSlim"><a href="#SemaphoreSlim" class="headerlink" title="SemaphoreSlim"></a>SemaphoreSlim</h4><p>SemaphoreSlim是对可同时访问资源或资源池的线程数加以限制的Semaphore的轻量替代。下面是一个简单的使用示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个信号量，初始计数为0，最大计数为3</span></span><br><span class="line">SemaphoreSlim semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">await</span> semaphoreSlim.WaitAsync();</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">semaphoreSlim.Release();</span><br></pre></td></tr></table></figure>

<p>以下示例展示了信号量SemaphoreSlim是如何控制并发访问的：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SemaphoreSlim _semaphoreSlim;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _padding;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Worker</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 开始并等待进入信号量.&quot;</span>, Task.CurrentId);</span><br><span class="line">        _semaphoreSlim.Wait();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> semaphoreCount;</span><br><span class="line"></span><br><span class="line">        Interlocked.Add(<span class="keyword">ref</span> _padding, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 进入信号量.&quot;</span>, Task.CurrentId);</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">1000</span> + _padding);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 从信号量中释放.&quot;</span>, Task.CurrentId);</span><br><span class="line">            semaphoreCount = _semaphoreSlim.Release();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;线程 &#123;0&#125; 释放之前信号量中的可用资源数: &#123;1&#125;&quot;</span>, Task.CurrentId, semaphoreCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        Task[] tasks = <span class="keyword">new</span> Task[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tasks[i] = Task.Run(Worker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> releaseCount = <span class="number">4</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;主线程尝试释放<span class="subst">&#123;releaseCount&#125;</span>个资源&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            _semaphoreSlim.Release(releaseCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SemaphoreFullException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;警告: 释放数量超过信号量最大计数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Task.WaitAll(tasks);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主线程退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出内容与Semaphore类似，此处不再展示。</p>
<p>SemaphoreSlim还可用于异步锁，避免线程阻塞，下面是一个简单示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoWork</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _semaphoreSlim.WaitAsync(); <span class="comment">// 等待锁</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        _semaphoreSlim.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发字典ConcurrentDictionary"><a href="#并发字典ConcurrentDictionary" class="headerlink" title="并发字典ConcurrentDictionary"></a>并发字典ConcurrentDictionary</h3><p>在C#中，线程安全集合是一种特殊的数据结构，能够在多线程环境下安全地访问和修改集合元素。线程安全集合通常是通过加锁或者使用其他同步机制来实现线程安全。C#中提供了多种线程安全集合，包括ConcurrentDictionary、ConcurrentQueue、ConcurrentStack、ConcurrentBag等。</p>
<p>ConcurrentDictionary是C#中用于处理多线程并发访问的线程安全字典。它的设计目标是高效地支持多个线程同时读写数据，而无需显式加锁。它的核心特性使其在高并发场景下表现出色，以下是它的主要特性：</p>
<ul>
<li>线程安全：允许多个线程同时读取和写入数据，而不会导致数据损坏或抛出异常。它通过内部锁和无锁技术(如CAS操作)来实现高效的并发访问</li>
<li>原子操作：提供了一系列原子操作方法(TryAdd、TryUpdate、TryRemove、AddOrUpdate、GetOrAdd等)，确保在多线程环境下的操作是线程安全的，避免了手动加锁的复杂性</li>
<li>高性能：针对高并发场景进行了优化，使用了分区锁(lock striping)技术，将字典分成多个段(segments)，每个段使用独立的锁。这样可以减少锁竞争，提高并发性能</li>
<li>无锁读取：大多数情况下读取操作是无锁的(lock-free)，这意味着多个线程可以同时读取数据而不会阻塞。这使得读取操作非常高效</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>ConcurrentDictionary的应用场景很多，例如缓存系统、共享数据存储、统计和聚合数据、任务调度和状态管理、并发日志记录、分布式锁或资源管理、实时数据处理等。</p>
<h5 id="统计和聚合数据"><a href="#统计和聚合数据" class="headerlink" title="统计和聚合数据"></a>统计和聚合数据</h5><p>在并发任务中，ConcurrentDictionary可以用于统计或聚合数据，例如计数、求和等。</p>
<p>下面这个示例使用了常规字典Dictionary对字符串列表进行统计，由于Dictionary是线程不安全的，统计结果将会不可预知。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="built_in">string</span>[] words = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟多线程环境</span></span><br><span class="line">Parallel.ForEach(words, word =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict.ContainsKey(word))</span><br><span class="line">    &#123;</span><br><span class="line">        dict[word] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dict[word] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> dict)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;kvp.Key&#125;</span>: <span class="subst">&#123;kvp.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行后有概率会出现以下错误提示：</p>
<blockquote>
<p>1.<code>Object reference not set to an instance of an object</code>.<br>2.<code>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection&#39;s state is no longer correct.</code></p>
</blockquote>
<p>更改非并发集合的操作必须具有独占访问权限。对非并发集合执行并发更新将会损坏其状态，集合的状态将不再正确。可以使用lock关键字手动添加互斥锁避免竞态条件，也可以直接使用ConcurrentDictionary。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> concurrentDict = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="built_in">string</span>[] words = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟多线程环境</span></span><br><span class="line">Parallel.ForEach(words, word =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    concurrentDict.AddOrUpdate(word, <span class="number">1</span>, (key, oldValue) =&gt; oldValue + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> concurrentDict)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;kvp.Key&#125;</span>: <span class="subst">&#123;kvp.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="并发日志记录"><a href="#并发日志记录" class="headerlink" title="并发日志记录"></a>并发日志记录</h5><p>在并发环境中，ConcurrentDictionary可以用于记录日志或事件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="keyword">new</span> ConcurrentDictionary&lt;DateTime, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    log.TryAdd(DateTime.Now, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟多线程环境</span></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">10</span>, i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    LogEvent(<span class="string">$&quot;Event <span class="subst">&#123;i&#125;</span> occurred&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> kvp <span class="keyword">in</span> log)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;kvp.Key&#125;</span>: <span class="subst">&#123;kvp.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码输出的日志记录个数是不确定的，因为同一时间只会记录一条记录。</p>
<h5 id="分布式锁或资源管理"><a href="#分布式锁或资源管理" class="headerlink" title="分布式锁或资源管理"></a>分布式锁或资源管理</h5><p>ConcurrentDictionary可以用于实现简单的分布式锁或资源管理。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resourceLocks = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line"><span class="keyword">var</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AccessResource</span>(<span class="params"><span class="built_in">int</span> resourceId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> resourceLock = resourceLocks.GetOrAdd(resourceId, id =&gt; <span class="keyword">new</span> <span class="built_in">object</span>());</span><br><span class="line">    <span class="keyword">lock</span>(resourceLock)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Resource <span class="subst">&#123;resourceId&#125;</span> is being accessed by thread <span class="subst">&#123;Task.CurrentId&#125;</span>&quot;</span>);</span><br><span class="line">        Task.Delay(<span class="number">1000</span>).Wait(); <span class="comment">// 模拟资源访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程访问资源</span></span><br><span class="line">Parallel.For(<span class="number">1</span>, <span class="number">10</span>, i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    AccessResource(i % <span class="number">3</span>); <span class="comment">// 重复访问相同的资源</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码对于同一资源的访问赋予了独占访问权限，若使用普通锁(将resourceLock改为lockObj)，那么某个进程访问资源池中的某个资源时，将会导致资源池中的其他资源也无法被访问。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide" >C#编程指南<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/" >.NET API参考文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/fundamentals/runtime-libraries/system-dynamic-expandoobject" >System.Dynamic.ExpandoObject类使用说明<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker虚拟化技术与容器化部署</title>
    <url>/Hexo-Blog/2024/08/15/docker-usage/</url>
    <content><![CDATA[<p>Docker基本概念、安装配置、容器化部署及常用命令。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker是一种操作系统层面的轻量级虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器(Container)。与虚拟机(VM)相比，Docker使用宿主机的操作系统，启动更快。每个容器只运行所需的应用程序和依赖项，资源消耗更少。Docker将操作系统、运行时环境、第三方软件库和依赖包、应用程序、环境变量、配置文件、启动命令等打包在一起，以便在任何环境中都能正常运行。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img   src="/Hexo-Blog/2024/08/15/docker-usage/docker_architecture.png"  class="" title="Docker架构图">

<h3 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h3><p>Docker使用Client-Server架构，Docker Clinet和Docker Daemon之间通过Socket或Restful API进行通信。</p>
<p>Docker Daemon是服务端的守护进程，负责管理Docker的各种资源，接受并处理来自客户端的请求，然后将结果返回给客户端。</p>
<h3 id="Docker镜像与容器"><a href="#Docker镜像与容器" class="headerlink" title="Docker镜像与容器"></a>Docker镜像与容器</h3><p>镜像(Images)是一个只读的容器模板，含有启动Docker容器所需的文件系统结构及内容。容器是Docker的运行实例，它提供了一个独立的可移植的环境。Docker以镜像和在镜像基础上构建的容器为基础，以容器开发、测试、发布的单元将应用相关的所有组件和环境进行封装，避免了应用在不同平台间迁移所带来的依赖问题，确保了应用在生产环境的各阶段达到高度一致的实际效果。</p>
<h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>Docker仓库(Registry)是用来集中存储和管理Docker镜像的地方。常用的有Dockerhub，用户可在此分享和下载Docker镜像，以实现镜像的共享和复用。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Docker官网在国内需要vpn才能访问，可通过国内镜像地址下载。Docker的使用可通过命令行方式，也可通过图形化工具Docker Desktop。</p>
<p>Windows系统中启动Docker Desktop的先决条件(以下二选一)</p>
<ul>
<li>安装WSL(推荐)</li>
<li>开启Hyper-V功能</li>
</ul>
<h2 id="容器化与Dockerfile"><a href="#容器化与Dockerfile" class="headerlink" title="容器化与Dockerfile"></a>容器化与Dockerfile</h2><p>Dockerfile是Docker用来构建镜像的指令文件，Docker容器化包含以下三个部分</p>
<ul>
<li><p>创建一个Dockerfile</p>
</li>
<li><p>使用Dockerfile构建镜像</p>
</li>
<li><p>使用镜像创建和构建容器</p>
</li>
</ul>
<p>例如要使用node在alpine中运行一个index.js文件，对应的Dockerfile为</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.js /index.js</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node /index.js</span></span><br></pre></td></tr></table></figure>

<p>.dockerignore是Docker镜像构建的ignore文件，通过合理配置可以减少Docker构建上下文大小，加快镜像构建速度，避免将敏感信息（如开发环境配置）打包进镜像，保持生产镜像的简洁性。</p>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。 </p>
<p>Docker Compose通过一个配置文件来管理多个Docker容器。在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用、应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p>
<p>最新的Docker已经集成了docker-compose功能，可使用<code>docker compose version</code>命令查看当前版本。</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>下面是一个Docker Compose的简单示例。</p>
<h4 id="配置文件目录结构"><a href="#配置文件目录结构" class="headerlink" title="配置文件目录结构"></a>配置文件目录结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─ etc</span><br><span class="line">   └─ docker</span><br><span class="line">       ├─ mysql</span><br><span class="line">       │   ├─ config</span><br><span class="line">       │   │    └─ my.conf</span><br><span class="line">       │   ├─ sqlScript</span><br><span class="line">       │   │    └─ createDatabase.sql</span><br><span class="line">       │   └─ Dockerfile</span><br><span class="line">       │</span><br><span class="line">       └─ redis</span><br><span class="line">            └─ conf</span><br><span class="line">                └─ redis.conf </span><br></pre></td></tr></table></figure>

<h4 id="配置文件docker-compose-yml"><a href="#配置文件docker-compose-yml" class="headerlink" title="配置文件docker-compose.yml"></a>配置文件docker-compose.yml</h4><p>Docker Compose配置文件是一个定义服务，网络和卷的YAML文件，默认文件名为docker-compose.yml。与Docker运行一样，默认情况下，Dockerfile中指定的选项（例如，CMD，EXPOSE，VOLUME，ENV）都被遵守，你不需要在docker-compose.yml中再次指定它们。</p>
<p>例如定义一个包含redis和mysql数据的容器，可使用以下配置文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span> <span class="comment"># 指定一个自定义容器名称，而不是生成的默认名称 </span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口信息。常用的简单格式：使用宿主:容器(HOST:CONTAINER)格式或者仅仅指定容器的端口(宿主将会随机选择端口)都可以。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span> <span class="comment"># 指定启动容器的镜像，可以是镜像仓库/标签或者镜像id</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 卷挂载路径设置。可以设置宿主机路径(HOST:CONTAINER)或加上访问模式(HOST:CONTAINER:ro),挂载数据卷的默认权限是读写(rw)，可以通过ro指定为只读。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./redis/datadir:/data&quot;</span> <span class="comment"># 相对于当前compose文件的相对路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./redis/conf/redis.conf:/usr/local/etc/redis/redis.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./redis/logs:/logs&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="comment"># 覆盖容器启动后默认执行的命令</span></span><br><span class="line">      <span class="string">/bin/bash</span> <span class="string">-c</span> <span class="string">&quot;redis-server /usr/local/etc/redis/redis.conf&quot;</span>      </span><br><span class="line">    </span><br><span class="line">  <span class="attr">mysql-db:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql-db</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0.1</span>                   </span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 包含命名卷(如mysql_data:/var/lib/mysql)、主机路径卷、匿名卷、只读卷和文件挂载(如./init.sql:/docker-entrypoint-initdb.d/init.sql)等 </span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span>           </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/config:/etc/mysql/conf.d&quot;</span>     </span><br><span class="line">    <span class="attr">build:</span> <span class="comment"># 指定包含构建上下文的路径</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span> <span class="comment"># 包含Dockerfile文件的目录路径，或者是git仓库的URL。当提供的值是相对路径时，它被解释为相对于当前compose文件的位置。该目录也是发送到Docker守护程序构建镜像的上下文。</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">mysql/Dockerfile</span> <span class="comment"># 备用Docker文件。Compose将使用备用文件来构建，还必须指定构建路径。</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 添加环境变量。可以使用数组或字典两种形式。只给定名称的变量会自动获取它在Compose主机上的值，可以用来防止泄露不必要的数据。(如果服务指定了build选项，那么在构建过程中通过environment定义的环境变量将不会起作用，将使用build的args子选项来定义构建时的环境变量。)</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&quot;root&quot;</span></span><br></pre></td></tr></table></figure>

<p>可使用以下命令构建并运行容器(使用-f使用自定义的配置文件，使用-d以后台方式运行)</p>
<p><code>docker-compose -f server.yml up -d</code></p>
<p>关闭或移除容器、镜像等</p>
<p><code>docker-compose -f server.yml down</code></p>
<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><img   src="/Hexo-Blog/2024/08/15/docker-usage/docker_compose_sample.png"  class="" title="Docker-Compose示例">

<p>将一个.NET+Vue+MySQL应用打包为Docker镜像的完整方案如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-app/</span><br><span class="line">├── mysql</span><br><span class="line">│   ├─ config</span><br><span class="line">│   │    └─ my.conf</span><br><span class="line">│   ├─ data</span><br><span class="line">│   ├─ sqlScript</span><br><span class="line">│   │    └─ init.sql</span><br><span class="line">│   └─ Dockerfile</span><br><span class="line">│</span><br><span class="line">├── backend/</span><br><span class="line">│   ├── ABPDemo.Web</span><br><span class="line">│   │    └── ABPDemo.Web.csproj</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── .dockerignore</span><br><span class="line">│   └── ...  </span><br><span class="line">│              </span><br><span class="line">├── frontend/</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── .dockerignore</span><br><span class="line">│   ├── nginx.conf</span><br><span class="line">│   └── ...</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── .env</span><br></pre></td></tr></table></figure>

<h4 id="配置数据库Dockerfile"><a href="#配置数据库Dockerfile" class="headerlink" title="配置数据库Dockerfile"></a>配置数据库Dockerfile</h4><p>数据库Dockerfile文件如下，</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">8.0</span>.<span class="number">1</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> mysql/sqlScript/*.sql /docker-entrypoint-initdb.d/</span></span><br></pre></td></tr></table></figure>

<p>其中init.sql数据库初始化脚本文件如下，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- init.sql</span></span><br><span class="line"><span class="comment">-- MySQL 数据库初始化脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置字符集</span></span><br><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库（如果不存在）</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `ABPDemo` </span><br><span class="line"><span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 </span><br><span class="line"><span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用新创建的数据库</span></span><br><span class="line">USE `ABPDemo`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例: 创建学生表（如果不存在）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `students` (</span><br><span class="line">	`id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数据唯一标识&#x27;</span>,</span><br><span class="line">	`name` <span class="type">varchar</span>(<span class="number">256</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (id, name) <span class="keyword">VALUES</span>(<span class="string">&#x27;3a1b6256-17fb-3551-0aed-af1436e871f1&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用外键约束</span></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>my.conf数据库配置文件如下，</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="attr">default-time-zone</span>=<span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"><span class="attr">innodb_rollback_on_timeout</span>=<span class="string">&#x27;ON&#x27;</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">500</span></span><br><span class="line"><span class="attr">innodb_lock_wait_timeout</span>=<span class="number">500</span></span><br></pre></td></tr></table></figure>

<p>注：如果MySQL容器初始化脚本未执行，可使用命令<code>cmd.exe /c &quot;docker exec -i mysql_db mysql -uroot -p[MYSQL_ROOT_PASSWORD] &lt; ./mysql/sqlScript/init.sql&quot;</code>手动执行。</p>
<h4 id="配置后端Dockerfile"><a href="#配置后端Dockerfile" class="headerlink" title="配置后端Dockerfile"></a>配置后端Dockerfile</h4><p>.NET后端Dockerfile文件如下，</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/aspnet:<span class="number">8.0</span> AS base</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">443</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/sdk:<span class="number">8.0</span> AS build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"><span class="comment"># 复制解决方案文件（如果存在）</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> *.sln .</span></span><br><span class="line"><span class="comment"># 复制项目文件进行依赖恢复</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;ABPDemo.Web/ABPDemo.Web.csproj&quot;</span>, <span class="string">&quot;ABPDemo.Web/&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;ABPDemo.HttpApi/ABPDemo.HttpApi.csproj&quot;</span>, <span class="string">&quot;ABPDemo.HttpApi/&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;ABPDemo.Application.Contracts/ABPDemo.Application.Contracts.csproj&quot;</span>, <span class="string">&quot;ABPDemo.Application.Contracts/&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;ABPDemo.Domain.Shared/ABPDemo.Domain.Shared.csproj&quot;</span>, <span class="string">&quot;ABPDemo.Domain.Shared/&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;ABPDemo.Application/ABPDemo.Application.csproj&quot;</span>, <span class="string">&quot;ABPDemo.Application/&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;ABPDemo.Domain/ABPDemo.Domain.csproj&quot;</span>, <span class="string">&quot;ABPDemo.Domain/&quot;</span>]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;ABPDemo.EntityFrameworkCore/ABPDemo.EntityFrameworkCore.csproj&quot;</span>, <span class="string">&quot;ABPDemo.EntityFrameworkCore/&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dotnet restore <span class="string">&quot;ABPDemo.Web/ABPDemo.Web.csproj&quot;</span></span></span><br><span class="line"><span class="comment"># 复制所有源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="string">&quot;/src/ABPDemo.Web&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dotnet build <span class="string">&quot;ABPDemo.Web.csproj&quot;</span> -c Release -o /app/build</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> build AS publish</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dotnet publish <span class="string">&quot;ABPDemo.Web.csproj&quot;</span> -c Release -o /app/publish</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> base AS final</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=publish /app/publish .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;ABPDemo.Web.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="配置前端Dockerfile"><a href="#配置前端Dockerfile" class="headerlink" title="配置前端Dockerfile"></a>配置前端Dockerfile</h4><p>Vue前端Dockerfile文件如下，</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建阶段</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span>-alpine AS build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="comment"># 覆写.env.production中的值</span></span><br><span class="line"><span class="keyword">ARG</span> VUE_APP_API_BASE_URL=http://localhost:<span class="number">8081</span>/</span><br><span class="line"><span class="keyword">ENV</span> VUE_APP_BASE_URL=$VUE_APP_API_BASE_URL</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build:prod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产阶段</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.27</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /app/dist /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>注：执行<code>npm install</code>需要联网环境，若要断网离线构建，应先本地构建dist，然后从宿主机复制到容器，对应的Dockfile可简化为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.27</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dist /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>其中nginx.conf的配置内容如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        root /usr/share/nginx/html;</span><br><span class="line">        index index.html;</span><br><span class="line"></span><br><span class="line">        # 处理前端路由</span><br><span class="line">        location / &#123;</span><br><span class="line">            try_files $uri $uri/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 代理 API 请求到后端</span><br><span class="line">        location /api/ &#123;</span><br><span class="line">            proxy_pass http://backend:80;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &#x27;upgrade&#x27;;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_cache_bypass $http_upgrade;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：Dockerfile中配置的后端地址<code>http://localhost:8081/</code>为代理地址(由于浏览器同源策略，必须与宿主机的前端访问地址一致)，由于宿主机的8081端口指向容器的80端口，因此容器内实际的前端地址仍然为<code>http://localhost:80/</code>。 在location中通过设置proxy_pass相对路径<code>http://backend:80</code>(Docker内置的DNS解析器会自动将backend解析为对应容器的IP地址)，将后端请求由<code>http://localhost:80/api/xxx</code>转发到<code>http://backend:80/api/xxx</code>，从而解决跨域问题。</p>
<h4 id="配置Docker-Compose"><a href="#配置Docker-Compose" class="headerlink" title="配置Docker Compose"></a>配置Docker Compose</h4><p>docker-compose.yml配置文件如下，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_db</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">$&#123;MYSQL_DATABASE&#125;</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">$&#123;MYSQL_USER&#125;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">$&#123;MYSQL_PASSWORD&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3307:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/data:/var/lib/mysql</span> <span class="comment">#mysql数据存储</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/config:/etc/mysql/conf.d</span>   <span class="comment">#mysql的配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/sqlScript:/docker-entrypoint-initdb.d</span> <span class="comment">#mysql初始化脚本  </span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-network</span></span><br><span class="line">    <span class="comment">#healthcheck:</span></span><br><span class="line">    <span class="comment">#  test: [&quot;CMD&quot;, &quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-h&quot;, &quot;localhost&quot;, &quot;-uroot&quot;, &quot;-p$&#123;MYSQL_ROOT_PASSWORD&#125;&quot;]</span></span><br><span class="line">    <span class="comment">#  timeout: 20s</span></span><br><span class="line">    <span class="comment">#  retries: 10</span></span><br><span class="line">    <span class="attr">command:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--ssl=0</span> <span class="comment"># 禁用 SSL</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dotnet_backend</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 使用&quot;SectionName__PropertyName&quot;替换appsettings.json中的数据库连接字符串</span></span><br><span class="line">      <span class="comment"># 例如：</span></span><br><span class="line">      <span class="comment"># &quot;ConnectionStrings&quot;: &#123;</span></span><br><span class="line">      <span class="comment">#   &quot;DefaultConnection&quot;: &quot;Server=127.0.0.1;port=3306;Database=ABPDemo;User=root;Password=root1234&quot;</span></span><br><span class="line">      <span class="comment"># &#125;</span></span><br><span class="line">      <span class="comment"># 对应的数据库连接字符串替换如下(mysql是docker-compose中定义的MySQL服务名称，Docker内置的DNS解析器会自动将服务名解析为对应容器的IP地址):</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ConnectionStrings__DefaultConnection=Server=mysql;Port=3306;Database=$&#123;MYSQL_DATABASE&#125;;User=$&#123;MYSQL_USER&#125;;Password=$&#123;MYSQL_PASSWORD&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ASPNETCORE_ENVIRONMENT=Production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:80&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="comment">#mysql:</span></span><br><span class="line">      <span class="comment">#  condition: service_healthy</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./frontend</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">vue_frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">app-network</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">app-network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>注：若要断网离线构建frontend，除了修改Dockfile直接使用COPY命令，也可以修改Docker Compose使用volumes挂载文件，具体配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./frontend/dist:/usr/share/nginx/html</span> <span class="comment">#前端dist部署包</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./frontend/nginx.conf:/etc/nginx/nginx.conf</span> <span class="comment">#nginx配置</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>.env配置文件如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD=root1234</span><br><span class="line">MYSQL_DATABASE=ABPDemo</span><br><span class="line">MYSQL_USER=root</span><br><span class="line">MYSQL_PASSWORD=root1234</span><br></pre></td></tr></table></figure>

<p>使用命令<code>docker-compose build</code>以构建上述所有镜像，使用命令<code>docker-compose up -d</code>启动镜像。</p>
<h4 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h4><p>管道方式打包导出所有镜像(使用此命令导出的镜像，在加载后为<code>&lt;none&gt;:&lt;none&gt;</code>未标签状态，需要手动打标签)<br><code>docker save -o all-images.tar $(docker-compose images -q)</code></p>
<p>列表方式打包导出所有镜像(列表项格式为<code>&lt;image-name&gt;:&lt;image-tag&gt;</code>)<br><code>docker save -o all-images.tar mysql:8.0.1 my-app-backend:latest my-app-frontend:latest</code></p>
<p>也可以将所有镜像罗列到image-list.txt当中，然后通过文件读取的方式导出<br><code>docker save -o all-images.tar $(cat image-list.txt)</code></p>
<blockquote>
<p>注：使用列表导出时，请检查所有Dockfile中依赖的基础镜像，例如node:18-alpine等，将他们全部添加进列表中，否则后续docker-compose构建容器时会尝试联网拉取远程基础镜像。</p>
</blockquote>
<p>导出配置<br><code>docker-compose config &gt; docker-compose-export.yml</code></p>
<p>加载镜像<br><code>docker load -i all-images.tar</code></p>
<p>根据导出配置启动服务<br><code>docker-compose -f docker-compose-export.yml up -d</code></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h3><p>拉取镜像</p>
<p><code>docker pull [image-url]</code></p>
<p>使用镜像源拉取(如轩辕镜像中mirror-url为<code>docker.xuanyuan.me</code>, path为<code>library</code>)</p>
<p><code>docker pull [mirror-url]/[path]/[image-name]:[image-version]</code></p>
<p>从本地归档文件(.tar)加载镜像到本地镜像库</p>
<p><code>docker load -i [image-name].tar</code></p>
<p>通过Shell重定向使用标准输入(stdin)加载镜像(适用于脚本或管道操作)</p>
<p><code>docker load &lt; [image-name].tar</code></p>
<p>构建镜像</p>
<p><code>docker build -t [image-name] .</code></p>
<p>根据镜像ID重命名镜像名称</p>
<p><code>docker tag [image-id] [image-name]</code></p>
<p>运行镜像(使用-d以守护进程&#x2F;后台方式运行)</p>
<p><code>docker run [image-name] .</code></p>
<p>查看所有镜像</p>
<p><code>docker image ls</code></p>
<p><code>docker images</code></p>
<p>上传镜像</p>
<p><code>docker push [image-url]</code></p>
<p>删除镜像</p>
<p><code>docker rmi [image-name] /</code></p>
<p><code>docker image rm [image-name]</code></p>
<p>从容器创建镜像</p>
<p><code>docker commit [container-name] [image-name]</code></p>
<p>保存为镜像文件</p>
<p><code>docker save -o [image-name].tar [image-name]</code></p>
<h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><p>创建容器</p>
<p><code>docker create [image-name]</code></p>
<p>启动运行并命名容器</p>
<p><code>docker run  --name [container-name] [image-name]</code></p>
<p>例如运行一个基于Ubuntu的容器，可使用以下命令</p>
<p><code>docker run --name ubuntu_demo -itd docker.xuanyuan.me/library/ubuntu</code></p>
<p>(注：-itd为组合参数，-i使容器保持交互状态，-t为容器分配一个伪终端，-d在后台运行容器)</p>
<p>进入Ubuntu容器内部</p>
<p><code>docker exec -it ubuntu_demo /bin/bash</code></p>
<p>停止容器</p>
<p><code>docker stop [container-name]</code></p>
<p>删除容器</p>
<p><code>docker rm [container-name] /</code></p>
<p><code>docker container rm [container-name]</code></p>
<p>退出容器</p>
<p><code>exit</code></p>
<h2 id="WSL配置Docker"><a href="#WSL配置Docker" class="headerlink" title="WSL配置Docker"></a>WSL配置Docker</h2><p>通过WSL使用Docker时可能会缺失一些配置文件。</p>
<h3 id="daemon-json"><a href="#daemon-json" class="headerlink" title="daemon.json"></a>daemon.json</h3><p>daemon.json是Docker引擎的配置管理文件，可以统一设置容器的网络、存储、安全、日志等选项。</p>
<p>docker安装后默认没有daemon.json这个配置文件，需要进行手动创建。在linux系统中，配置文件的默认径为：&#x2F;etc&#x2F;docker&#x2F;daemon.json。</p>
<p>可使用以下命令手动创建daemon.json</p>
<p><code>sudo mkdir -p /etc/docker</code></p>
<p><code>sudo touch /etc/docker/daemon.json</code></p>
<p><code>sudo nano /etc/docker/daemon.json</code></p>
<p>例如配置docker镜像，可添加以下配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">      <span class="string">&quot;https://&lt;your-aliyun-id&gt;.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;https://docker.xuanyuan.me&quot;</span> </span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>保存并退出后可使用以下命令重启docker</p>
<p><code>sudo systemctl restart docker</code></p>
<p>可使用<code>docker info</code>查看镜像配置是否生效，若仍未生效，可前往Docker Desktop手动设置。</p>
<p>右键点击任务栏Docker图标 → Settings → Docker Engine，修改JSON配置后点击Apply &amp; Restart等待重启完成即可。</p>
<h3 id="docker-service"><a href="#docker-service" class="headerlink" title="docker.service"></a>docker.service</h3><p>docker.service文件是用于配置和管理Docker守护进程的systemd单元文件。它定义了Docker服务的启动、停止和重启行为，以及一些关键的配置参数。</p>
<p>如果缺失这个文件，在重启docker时会报错</p>
<blockquote>
<p>Failed to start docker.service: Unit docker.service not found</p>
</blockquote>
<p>可使用以下命令手动创建docker.service</p>
<p><code>sudo nano /etc/systemd/system/docker.service</code></p>
<p>可添加以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>保存后使用以下命令重新加载systemd配置并启动服务</p>
<p><code>sudo systemctl daemon-reload</code></p>
<p><code>sudo systemctl start docker</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://docs.docker.com/" >Docker官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.docker.com/compose/" >Docker Compose官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://kontext.tech/project/aspnet-core/article/overwrite-connecting-string-via-environment-variable-for-asp-net-core-on-docker" >如何在Docker中通过环境变量覆写数据库连接字符串<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.docker.com/desktop/features/wsl/" >Docker集成WSL2<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Virtualization-Technology</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/Hexo-Blog/2024/08/11/git-usage/</url>
    <content><![CDATA[<p>协作开发时一些常用的git命令。</p>
<span id="more"></span>

<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>git变基到[branch]</p>
<p><code>git rebase [branch]</code></p>
<p>git变基后合并冲突</p>
<p><code>git rebase --cotinue</code></p>
<p>合并代码前先进行变基操作(避免多出一条和分支修改无关的commit)</p>
<p><code>git pull --rebase</code></p>
<p>git变基修改多次提交</p>
<p><code>git rebase -i [commit-id]</code> 或 <code>git rebase -i HEAD~n</code></p>
<p>git取消变基</p>
<p><code>git rebase --abort</code></p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>git重置提交到[commit-id]，并强制推送</p>
<p><code>git reset --hard [commit-id]]</code></p>
<p><code>git push -f</code></p>
<h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p>git回退到某一版本并提交</p>
<p><code>git revert [commit-id]</code></p>
<p><code>git commit -m [commit-id]</code></p>
<h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p>git获取远程分支内容</p>
<p><code>git fetch -a  origin/[branch]</code></p>
<p>本地remote分支和远程同步</p>
<p><code>git remote prune origin</code></p>
<p>将本次修改的内容合并到上一次提交中，并强制推送</p>
<p><code>git commit -a --amend</code></p>
<p><code>git push -f</code></p>
<h2 id="Git-批处理"><a href="#Git-批处理" class="headerlink" title="Git 批处理"></a>Git 批处理</h2><h3 id="filter-branch"><a href="#filter-branch" class="headerlink" title="filter-branch"></a>filter-branch</h3><p>本地git中的用户名和邮箱配置错误，会导致远程仓库提交记录中无法正确显示作者信息(用户名、头像等)，还会导致用户贡献无法统计。</p>
<p>如果只是更正单条作者信息，使用rebase即可。</p>
<p><code>git rebase -i -p [commit-id]</code></p>
<p><code>git commit --amend --author=&quot;New Name Value &lt;correct@example.com&gt;&quot; --no-edit</code></p>
<p><code>git rebase --continue</code></p>
<p>若要重写所有历史commit中的授权用户和提交用户，可以使用<code>git filter-branch</code>编写批处理脚本，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you see bash tips &quot;A previous backup already exists in refs/original/&quot;,</span></span><br><span class="line"><span class="comment"># that means you are not doing this for the first time.</span></span><br><span class="line"><span class="comment"># Just use &#x27;-f&#x27; to force to rewrite.</span></span><br><span class="line">git filter-branch --env-filter <span class="string">&#x27;</span></span><br><span class="line"><span class="string">WRONG_EMAIL=&quot;wrong@example.com&quot;</span></span><br><span class="line"><span class="string">NEW_NAME=&quot;New Name Value&quot;</span></span><br><span class="line"><span class="string">NEW_EMAIL=&quot;correct@example.com&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$WRONG_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_NAME=&quot;$NEW_NAME&quot;</span></span><br><span class="line"><span class="string">    export GIT_COMMITTER_EMAIL=&quot;$NEW_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$WRONG_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_NAME=&quot;$NEW_NAME&quot;</span></span><br><span class="line"><span class="string">    export GIT_AUTHOR_EMAIL=&quot;$NEW_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">&#x27;</span> --tag-name-filter <span class="built_in">cat</span> -- --branches --tags</span><br></pre></td></tr></table></figure>

<p>在git仓库根目录下运行后，使用<code>git push -f</code>强制推送即可。</p>
<h2 id="Git配置问题"><a href="#Git配置问题" class="headerlink" title="Git配置问题"></a>Git配置问题</h2><h3 id="文件路径过长"><a href="#文件路径过长" class="headerlink" title="文件路径过长"></a>文件路径过长</h3><p>git在拉取或提交代码时，文件路径名过长会报错”filename too long”。</p>
<p>输入<code>git config --get core.longpaths</code>，发现返回结果为false。</p>
<p>可通过<code>git config core.longpaths true</code>命令，在当前项目中启用长路径名。</p>
<p>若想全局生效，可输入<code>git config --global core.longpaths true</code>。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link"   href="https://git-scm.com/docs/git/zh_HANS-CN" >Git官方中文文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Version-Control</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET HttpClient使用详解</title>
    <url>/Hexo-Blog/2025/03/04/http-client-usage/</url>
    <content><![CDATA[<p>.NET中使用HttpClient发送HTTP请求的方式介绍。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在c#中常见发送http请求的方式有以下三种：</p>
<ul>
<li>HttpWebRequest: .NET平台原生提供，这是.NET创建者最初开发用于使用HTTP请求的标准类。使用HttpWebRequest可以让开发者控制请求&#x2F;响应流程的各个方面，如timeouts,cookies,headers,protocols</li>
<li>WebClient: .NET平台原生提供，WebClient是一种更高级别的抽象，是HttpWebRequest为了简化最常见任务而创建的，但也因此缺少了HttpWebRequest的灵活性</li>
<li>HttpClient: .NET平台原生提供，目前主流使用的Http请求工具类，直接基于Socket开发，提供了异步友好的代码编写方式，是线程安全的</li>
</ul>
<h2 id="HTTP-Content-Type"><a href="#HTTP-Content-Type" class="headerlink" title="HTTP Content-Type"></a>HTTP Content-Type</h2><p>在HTTP协议中，客户端和服务器之间通过请求和响应进行通信。在这个过程中，传输的数据有各种不同的格式类型，为了确保双方能够正确理解和处理数据，需要正确设置Content-Type。Content-Type是指示发送端内容的媒体类型的HTTP头部，广泛用于请求和响应中。</p>
<p>媒体类型(Media Type)，也称为MIME类型(Multipurpose Internet Mail Extensions)，指定了内容的格式和编码方式。常见的Content-Type有以下几种：</p>
<ul>
<li>text&#x2F;plain: 表示内容是纯文本，不包含格式化信息。通常用于简单的文本内容，没有特殊的意义标记</li>
<li>text&#x2F;html: 表示该内容是HTML文档</li>
<li>text&#x2F;xml: 表示内容是XML文档，可用于soap1.1协议。在text&#x2F;xml中，XML头指定的编码格式无效，必须在HTTP头部的Content-Type中指定才会生效</li>
<li>application&#x2F;soap+xml：表示内容是XML文档，可用于soap1.2协议</li>
<li>application&#x2F;xml: 表示内容是XML文档，可直接在XML头指定编码格式，是常规XML格式的首选类型</li>
<li>application&#x2F;octet-stream: 表示二进制流数据，可在下载文件类型未知的情况下使用</li>
<li>application&#x2F;json: 表示内容是JSON格式。JSON是一种轻量级的数据交换格式，广泛用于API的请求和响应中</li>
<li>application&#x2F;x-www-form-urlencoded: 表示数据以键值对形式进行编码，是HTML表单默认的Content-Type类型</li>
<li>multipart&#x2F;form-data: 通常用于表单数据中包含文件上传的情景。在这种类型中，数据被拆分成多个部分，每个部分包含自己独立的头部信息</li>
</ul>
<h2 id="HttpClient使用配置"><a href="#HttpClient使用配置" class="headerlink" title="HttpClient使用配置"></a>HttpClient使用配置</h2><p>当我们发送http请求时，可以使用SocketsHttpHandler处理一些事情，比如是否自动处理cookie，是否自动重定向以及最多重定向几次等。以下展示了常见的配置项：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在.net core 2.1之后，默认所有的http请求都会交给SocketsHttpHandler处理</span></span><br><span class="line"><span class="keyword">var</span> socketsHttpHandler = <span class="keyword">new</span> SocketsHttpHandler()</span><br><span class="line">&#123;</span><br><span class="line">    UseCookies = <span class="literal">false</span>, <span class="comment">//是否自动处理cookie</span></span><br><span class="line"></span><br><span class="line">    AllowAutoRedirect = <span class="literal">true</span>,<span class="comment">//是否自动重定向, 默认true</span></span><br><span class="line">    MaxAutomaticRedirections = <span class="number">50</span>,<span class="comment">//自动重定向的最大次数, 默认50</span></span><br><span class="line"></span><br><span class="line">    MaxConnectionsPerServer = <span class="number">100</span>, <span class="comment">//每个请求连接的最大数量, 默认是int.MaxValue</span></span><br><span class="line">    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(<span class="number">2</span>), <span class="comment">//连接池中TCP连接最多可以闲置多久, 默认2分钟</span></span><br><span class="line">    PooledConnectionLifetime = Timeout.InfiniteTimeSpan, <span class="comment">//连接最长的存活时间, 默认是不限制的</span></span><br><span class="line"></span><br><span class="line">    AutomaticDecompression = DecompressionMethods.GZip, <span class="comment">//是否压缩，默认是None，即不压缩</span></span><br><span class="line"></span><br><span class="line">   ConnectTimeout = Timeout.InfiniteTimeSpan,  <span class="comment">//建立TCP连接时的超时时间, 默认不限制</span></span><br><span class="line">   Expect100ContinueTimeout = TimeSpan.FromSeconds(<span class="number">1</span>), <span class="comment">//等待服务返回statusCode=100的超时时间, 默认1秒</span></span><br><span class="line"></span><br><span class="line">   MaxResponseHeadersLength = <span class="number">64</span>, <span class="comment">//响应头大小限制，单位kb</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient(socketsHttpHandler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外，可以给HttpClient设置基地址，当HttpClient发送的请求不包含前缀时，将自动拼接上，否则不予拼接。还可以设置默认的http版本、请求头。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">httpClient.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/&quot;</span>);</span><br><span class="line">httpClient.DefaultRequestVersion = HttpVersion.Version20;</span><br><span class="line">httpClient.DefaultRequestHeaders.Add(<span class="string">&quot;parameter1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="HttpClient请求方法"><a href="#HttpClient请求方法" class="headerlink" title="HttpClient请求方法"></a>HttpClient请求方法</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET请求不需要设置Content-Type，因为GET请求的参数是通过URL传递的，而不是在请求体中。通过GET请求数据的示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>?<span class="subst">&#123;parameter1&#125;</span>=<span class="subst">&#123;value1&#125;</span>&amp;<span class="subst">&#123;parameter2&#125;</span>=<span class="subst">&#123;value2&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(url);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure>

<p>若要通过GET方法下载文件，可以通过如下方式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> downloadUrl = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;srcDir&#125;</span>/<span class="subst">&#123;srcFile&#125;</span>&quot;</span>; <span class="comment">// 文件虚拟路径</span></span><br><span class="line"><span class="keyword">var</span> downloadPath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;desDir&#125;</span>\\<span class="subst">&#123;desFile&#125;</span>&quot;</span>; <span class="comment">// 下载物理路径</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(downloadUrl);</span><br><span class="line"><span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(downloadPath, FileMode.OpenOrCreate, FileAccess.Write);</span><br><span class="line"><span class="keyword">await</span> response.Content.CopyToAsync(fileStream);</span><br><span class="line">fileStream.Close();</span><br></pre></td></tr></table></figure>

<p>若要下载超过2GB的文件，则需要通过如下方式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> downloadUrl = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;srcDir&#125;</span>/<span class="subst">&#123;srcFile&#125;</span>&quot;</span>; <span class="comment">// 文件虚拟路径</span></span><br><span class="line"><span class="keyword">var</span> downloadPath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;desDir&#125;</span>\\<span class="subst">&#123;desFile&#125;</span>&quot;</span>; <span class="comment">// 下载物理路径</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(downloadUrl, HttpCompletionOption.ResponseHeadersRead); <span class="comment">// 拿到响应头就返回</span></span><br><span class="line"><span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(downloadPath, FileMode.OpenOrCreate, FileAccess.Write);</span><br><span class="line"><span class="keyword">await</span> response.Content.CopyToAsync(fileStream);</span><br><span class="line">fileStream.Close();</span><br></pre></td></tr></table></figure>

<p>若要给大文件下载添加进度提示，可以事先通过http响应头的Content-Length获取到文件大小，具体实现如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> downloadUrl = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;srcDir&#125;</span>/<span class="subst">&#123;srcFile&#125;</span>&quot;</span>; <span class="comment">// 文件虚拟路径</span></span><br><span class="line"><span class="keyword">var</span> downloadPath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;desDir&#125;</span>\\<span class="subst">&#123;desFile&#125;</span>&quot;</span>; <span class="comment">// 下载物理路径</span></span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(downloadUrl, HttpCompletionOption.ResponseHeadersRead);</span><br><span class="line"><span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(downloadPath, FileMode.OpenOrCreate, FileAccess.Write);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line"><span class="keyword">var</span> totalLength = response.Content.Headers.ContentLength;</span><br><span class="line"><span class="built_in">long</span> readLength = <span class="number">0L</span>;</span><br><span class="line"><span class="built_in">int</span> length;</span><br><span class="line"><span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">5</span> * <span class="number">1024</span>]; <span class="comment">// 5KB缓存</span></span><br><span class="line"><span class="keyword">while</span> ((length = <span class="keyword">await</span> contentStream.ReadAsync(buffer)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    readLength += length;</span><br><span class="line">    <span class="keyword">if</span> (totalLength &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;下载进度: &quot;</span> + Math.Round((<span class="built_in">double</span>)readLength / totalLength.Value * <span class="number">100</span>, <span class="number">2</span>) + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;已下载: &quot;</span> + Math.Round(readLength / <span class="number">1024.0</span>, <span class="number">2</span>) + <span class="string">&quot;KB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fileStream.Write(buffer, <span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileStream.Close();</span><br></pre></td></tr></table></figure>

<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>根据Content-Type类型，常见的请求类型有application&#x2F;json、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded等。</p>
<h4 id="application-json"><a href="#application-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h4><p>使用POST请求application&#x2F;json类型的示例如下(.NET中对应接口参数使用FromBody特性，或直接使用类接收)：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> stringContent = <span class="keyword">new</span> StringContent(JsonConvert.SerializeObject(<span class="keyword">new</span> &#123; parameter1 = <span class="string">&quot;value1&quot;</span>, parameter2 = <span class="string">&quot;value2&quot;</span> &#125;), Encoding.UTF8, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.PostAsync(url, stringContent);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure>

<h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h4><p>使用POST请求multipart&#x2F;form-data类型的示例如下(.NET中对应接口参数使用FromForm特性)：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>&quot;</span>; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> formData = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="keyword">new</span> StringContent(<span class="string">&quot;value1&quot;</span>), <span class="string">&quot;parameter1&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="keyword">new</span> StringContent(<span class="string">&quot;value2&quot;</span>), <span class="string">&quot;parameter2&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.PostAsync(url, formData);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure>

<p>若要添加文件流参数(.NET中使用IFormFile接收), 可使用以下方式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> downloadUrl = Path.Combine(<span class="keyword">new</span> DirectoryInfo(AppContext.BaseDirectory).Parent.FullName, <span class="string">&quot;Upload&quot;</span>, fileMd5);</span><br><span class="line"><span class="keyword">using</span> FileStream stream = System.IO.File.OpenRead(downloadUrl);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> memoryStream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"><span class="keyword">await</span> stream.CopyToAsync(memoryStream);</span><br><span class="line"><span class="built_in">byte</span>[] fileBytes = memoryStream.ToArray();</span><br><span class="line"></span><br><span class="line">formData.Add(<span class="keyword">new</span> ByteArrayContent(fileBytes), <span class="string">&quot;parameter3&quot;</span>, Path.GetFileName(fileName));</span><br></pre></td></tr></table></figure>

<h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h4><p>使用POST请求application&#x2F;x-www-form-urlencoded类型的示例如下(.NET中对应接口参数使用FromForm特性)：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">$&quot;<span class="subst">&#123;protocol&#125;</span>://<span class="subst">&#123;ip&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;api&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> urlEncodedContent = <span class="keyword">new</span> FormUrlEncodedContent(<span class="keyword">new</span> List&lt;KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;parameter1&quot;</span>,<span class="string">&quot;value1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;parameter2[0]&quot;</span>,<span class="string">&quot;value2&quot;</span>), <span class="comment">// parameter2为数组类型</span></span><br><span class="line">    <span class="keyword">new</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;parameter2[1]&quot;</span>,<span class="string">&quot;value3&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.PostAsync(url, urlEncodedContent);</span><br><span class="line"><span class="keyword">var</span> responseContent = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> res = JsonConvert.DeserializeObject&lt;TData&gt;(responseContent);</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://config.net.cn/tools/HttpContentType.html" >Http请求中各种Content-Type类型详解大全<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.net.http.socketshttphandler" >SocketsHttpHandler类使用参考<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/fundamentals/networking/http/httpclient" >使用HttpClient类发出HTTP请求<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Network-Protocol</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>ASP.NET Core</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法在JWT、SSH中的应用</title>
    <url>/Hexo-Blog/2024/08/27/jwt-and-ssh/</url>
    <content><![CDATA[<p>对称加密、非对称加密算法在不同场景中的应用，如使用JWT进行单点登录、使用SSH进行远程免密登录等。</p>
<span id="more"></span>


<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是一种加密和解密所使用的密钥是相同的加密算法。在对称加密中，发送方和接收方使用相同的密钥对数据进行加密和解密。常见的对称加密算法包括DES、3DES、AES等。</p>
<p>对称加密的优势在于速度快，加解密过程简单，适合用于传输大量数据。但是对称加密无法提供身份验证和数据完整性保护，即无法判断消息的发送方是否可信以及数据是否被篡改。</p>
<p>对称加密通常与其他的加密技术(如数字签名、消息认证码等)结合使用，以提供更高的安全性保护。</p>
<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>高级加密标准(Advanced Encryption Standard, 简称AES)为最常见的对称加密算法，在密码学中又称Rijndael加密法。AES算是Rijndael算法的一种特殊实现，选的分组为128bit（16字节），密钥可以使用128、192和256bit三种，而Rijndael使用的密钥和区块长度可以是32位的整数倍，以128位为下限，256比特为上限。加密过程中使用的密钥是由Rijndael密钥生成方案产生。</p>
<p>在AES加密中，密钥(key)、初始化向量(Initialization Vector, 简称IV)是两个重要的组成部分。此外，还可设置加密方式(Mode, 默认为CBC)和填充方式(Padding, 默认为PKCS7)，其中CBC模式需要有IV，ECB模式不需要IV。</p>
<ul>
<li><p>key</p>
<ul>
<li>定义：key是用于AES加密和解密的密钥，它是双方协商或生成的秘密信息，用于确保加密数据的安全性。</li>
<li>长度：AES支持多种长度的密钥，包括128位（16字节）、192位（24字节）和256位（32字节）。选择哪种长度的密钥取决于安全需求和性能考虑。</li>
<li>重要性：密钥的保密性至关重要，如果密钥被泄露，加密的数据就可能被解密，从而失去保护。</li>
</ul>
</li>
<li><p>iv</p>
<ul>
<li>定义：iv是一个随机或伪随机的值，它与密钥一起用于加密过程中的初始化。它确保了即使使用相同的密钥加密相同的明文，每次加密得到的密文也会不同，从而增强了加密的安全性。</li>
<li>长度：AES的iv长度通常是128位（16字节），这与AES的数据块长度相同。</li>
<li>重要性：iv的随机性对于防止重放攻击和统计分析攻击至关重要。使用固定的iv或可预测的iv会降低加密的安全性。</li>
</ul>
</li>
</ul>
<p>在AES加密过程中，首先会将明文分成多个128位的数据块（如果最后一个数据块不足128位，则需要进行填充，常用的填充方式包括PKCS5Padding、PKCS7Padding和ZeroPadding等）。然后，使用密钥和iv对数据进行加密。加密过程通常包括多个轮次，每轮都会执行一系列复杂的操作，如字节替换、行移位、列混合和轮密钥加等。最终，所有的数据块都被加密成密文。</p>
<p>以下是c#中AES加密与解密的实现方式，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> AES加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">AESEncrypt</span>(<span class="params"><span class="built_in">string</span> plainText, <span class="built_in">string</span> key, <span class="built_in">string</span> iv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">    <span class="built_in">byte</span>[] ivBytes = Encoding.UTF8.GetBytes(iv);</span><br><span class="line">    <span class="keyword">using</span> (Aes aesAlg = Aes.Create())</span><br><span class="line">    &#123;</span><br><span class="line">        aesAlg.Key = keyBytes;</span><br><span class="line">        aesAlg.IV = ivBytes;</span><br><span class="line">        aesAlg.Mode = CipherMode.CBC;</span><br><span class="line">        aesAlg.Padding = PaddingMode.PKCS7;</span><br><span class="line"></span><br><span class="line">        ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, encryptor, CryptoStreamMode.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(cs))</span><br><span class="line">                &#123;</span><br><span class="line">                    sw.Write(plainText);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Convert.ToBase64String(ms.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> AES加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">AESDecrypt</span>(<span class="params"><span class="built_in">string</span> cipherText, <span class="built_in">string</span> key, <span class="built_in">string</span> iv</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] keyBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">    <span class="built_in">byte</span>[] ivBytes = Encoding.UTF8.GetBytes(iv);</span><br><span class="line">    <span class="built_in">byte</span>[] cipherBytes = Convert.FromBase64String(cipherText);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Aes aesAlg = Aes.Create())</span><br><span class="line">    &#123;</span><br><span class="line">        aesAlg.Key = keyBytes;</span><br><span class="line">        aesAlg.IV = ivBytes;</span><br><span class="line">        aesAlg.Mode = CipherMode.CBC;</span><br><span class="line">        aesAlg.Padding = PaddingMode.PKCS7;</span><br><span class="line"></span><br><span class="line">        ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream(cipherBytes))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, decryptor, CryptoStreamMode.Read))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(cs))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> sr.ReadToEnd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密是一种加密算法，与对称加密不同，非对称加密使用一对不同的密钥来进行加密和解密。这对密钥中的一个被称为私钥(private key)，另一个被称为公钥(public key)。私钥只能由密钥的拥有者持有并保密，不对外公开，而公钥可以向任何人公开。常见的非对称加密算法包括RSA、ECC等。</p>
<p>在非对称加密中，加密和解密过程如下：</p>
<ol>
<li>发送方使用接收方的公钥对明文进行加密，生成密文</li>
<li>接收方使用自己的私钥对密文进行解密，恢复为明文</li>
</ol>
<p>非对称加密算法的特点是安全性高，能够提供身份验证和数据完整性保护。但是非对称加密的缺点是速度较慢，加解密过程相对复杂，适合处理少量的数据。</p>
<p>因此，通常会将对称加密和非对称加密相结合，在传输数据时使用非对称加密来交换对称加密所需的密钥，然后使用对称加密算法来加密和解密实际的数据。</p>
<h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>消息认证码(Message Authentication Code, 简称MAC)是一种确认完整性并进行认证的技术。</p>
<p>消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为MAC值。要计算MAC值必须持有共享密钥，消息认证码正是利用这一性质来完成身份认证的。此外，消息认证码通过类似单向散列函数的散列值来确保数据完整性。</p>
<p>HMAC是一种使用单向散列函数来构造消息认证码的方法。HMAC中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于HMAC，如果将来设计出新的单向散列函数，也同样可以使用。使用SHA-256、MD5、RIPEMD-160所构造的HMAC，分别称为HMAC-SHA-256、HMAC-MD5和HMAC-RlPEMD。</p>
<p>消息认证码中，由于发送者和接收者共享相同的密钥，因此会产生无法对第三方证明以及无法防止否认等问题。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名(又称公钥数字签名)是只有信息的发送者才能产生的别人无法伪造的一段数字串。数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和非对称加密是相反的，即用私钥加密相当于生成签名，而用公钥解密则相当于验证签名。通常情况下，为了提高传输效率，不会直接对原始数据进行数字签名，而是对原始数据的Hash值进行签名。</p>
<p>数字签名的过程如下：</p>
<ol>
<li><p>生成签名：</p>
<ul>
<li><p>对原始数据进行哈希运算(使用预先约定的哈希算法)，得到Hash值</p>
</li>
<li><p>使用非对称加密的私钥对Hash值加密，得到签名</p>
</li>
<li><p>发送原始数据及签名</p>
</li>
</ul>
</li>
<li><p>验证签名：</p>
<ul>
<li><p>接收原始数据及签名</p>
</li>
<li><p>对数字签名使用公钥解密, 得到Hash值</p>
</li>
<li><p>对原始数据进行哈希运算得到新的Hash值，如果两者一致，则签名验证成功；如果两者不一致，则签名验证失败</p>
</li>
</ul>
</li>
</ol>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT(JSON Web Token)是目前最流行的跨域身份验证解决方案，适用于身份鉴权、授权、信息交换、单点登录等场景。JWT可以使用密钥(使用HMAC算法)或使用RSA或ECDSA的公钥&#x2F;私钥对进行签名。</p>
<p>应用程序获取JWT并用于访问API等资源的过程如下：</p>
<ol>
<li>客户端向授权服务器请求授权</li>
<li>授权服务器校验用户身份，如果校验成功，返回访问令牌(token)</li>
<li>应用程序使用访问令牌访问受保护的资源，服务端通过验证JWT的签名来确认用户的身份，通过解析JWT中的声明信息判断用户是否有权限执行特定的操作或访问特定的资源</li>
</ol>
<p>JWT由Header、Payload、Signature三部分组成：</p>
<ul>
<li><p>JWT的头部通常由两部分组成，分别是令牌类型(typ)和加密算法(alg)。一般情况下，头部会采用Base64编码。</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>JWT的载荷也称为声明信息(claims)，包含了一些有关实体(通常是用户)的信息以及其他元数据。通常包含预定义的字段，如iss(发行者)、sub(主题)、aud(受众)、exp(过期时间)、nbf(生效时间)、iat(发布时间)和jti(JWT ID)等，以及自定义字段。</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5a3cd526-caa4-4952-a5ba-f44245fe1762&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1681102951</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span> <span class="number">1681102951</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1681189351</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jocoboy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WebUser&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JWT的签名是由头部、载荷和密钥(通常为32个字节)共同生成的，用于验证JWT的真实性和完整性。使用Header里面指定的签名算法(默认是HMAC-SHA256)，按照下面的公式产生签名</p>
  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">base64UrlEncode(payload),</span><br><span class="line">secret)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>.NET使用HMAC-SHA256对称加密算法生成JWT的部分代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> key = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_authOptions.Secret));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(key, SecurityAlgorithms.HmacSha256);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> token = <span class="keyword">new</span> JwtSecurityToken(_authOptions.Issuer,</span><br><span class="line">    _authOptions.Audience,</span><br><span class="line">    claims,</span><br><span class="line">    DateTime.Now,</span><br><span class="line">    DateTime.Now.AddMinutes(_authOptions.Expiration),</span><br><span class="line">    credentials);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(token);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>安全外壳协议(Secure Shell, 简称SSH)是一种建立在应用层基础上，在不安全网络上用于安全远程登录和其他安全网络服务的协议。</p>
<p>SSH建立在非对称加密之上，建立远程连接的过程如下：</p>
<ol>
<li>远程主机(虚拟机)收到本地主机的登录请求，把自己的公钥发给本地主机</li>
<li>本地主机使用这个公钥，将登录密码加密后，发送给远程主机</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，则同意本地主机登录</li>
</ol>
<h3 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h3><p>Linux系统中以用户名username，登录远程主机remote_host的命令如下</p>
<p><code>ssh username@remote_host</code></p>
<p>初次连接会提示公钥指纹，确认指纹无误后输入密码，远程主机的公钥就会自动保存到本地主机的.ssh&#x2F;known_hosts文件中。</p>
<h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>公钥登录可以省去输入密码的步骤。用户将自己的公钥储存在远程主机上，登录时远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录。</p>
<p>在本地主机生成一对公钥和私钥，然后将公钥添加到远程主机的 ~&#x2F;.ssh&#x2F;authorized_keys文件中(Windows系统中把.ssh&#x2F;id_rsa.pub的内容复制出来，手动追加即可)</p>
<p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p>
<p><code>ssh-copy-id username@remote_host</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.security.cryptography.aes" >.NET中的AES类<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://jwt.io/introduction" >JWT官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" >Generating new SSH key<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Cyber-Security</category>
      </categories>
      <tags>
        <tag>JWT</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes核心组件与集群搭建</title>
    <url>/Hexo-Blog/2024/08/17/kubernetes-usage/</url>
    <content><![CDATA[<p>kubernetes的核心组件、架构体系、环境搭建(minikube&#x2F;k3s)，以及kubectl常用命令和可视化管理工具Portainer。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>kubernetes是一个全新的基于容器技术的分布式架构领先方案。kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><img   src="/Hexo-Blog/2024/08/17/kubernetes-usage/kubernetes_components.png"  class="" title="kubernetes部分核心组件">

<ul>
<li>node，一个物理机或虚拟机</li>
<li>pod，一个或多个应用容器的组合(如sidecar模式，应用容器与辅助容器共用一个Pod)。pod之间可通过内部ip地址访问</li>
<li>svc(service)，将一组pod封装为一个服务，可以通过一个统一的入口来访问，相当于反向代理，可以解决因pod销毁导致的内部ip地址变更问题</li>
<li>node:port，端口节点，提供内部服务对外的IP映射</li>
<li>ing(ingress)，用来管理从集群外部访问集群内部服务的入口和方式，可以配置不同的转发规则，根据不同的规则访问不同的svc，以及svc对应的pod。此外还可以配置域名、负载均衡、SSL证书等</li>
<li>cm(config map)，用来存储应用程序配置信息，实现应用程序与配置信息的解耦</li>
<li>secret，为cm中的敏感信息提供Base64加密，需要配合其他安全机制(如网络控制、访问控制、身份认证)一起使用</li>
<li>vol(volume)，可以将应用数据挂载到集群内部的本地磁盘上，或是集群外部的远程存储上，实现数据的持久化</li>
<li>deploy(deployment)，定义和管理应用程序的副本数量，是pod上的一层抽象</li>
<li>replicaset，介于pod与deploy之间，用于管理pod</li>
<li>sts(stateful set)，和deploy类似，用来管理有状态的应用(如数据库、缓存、消息队列等)</li>
</ul>
<h2 id="Master-Worker架构"><a href="#Master-Worker架构" class="headerlink" title="Master-Worker架构"></a>Master-Worker架构</h2><p>kubernetes是典型的Master-Worker架构。Master-Node负责管理整个集群，Worker-Node负责运行应用程序和服务。</p>
<img   src="/Hexo-Blog/2024/08/17/kubernetes-usage/kubernetes_architecture.png"  class="" title="kubernetes架构图">

<ul>
<li>kubelet，负责管理和维护每个node上的pod</li>
<li>kube-proxy，负责提供网络代理和负载均衡服务</li>
<li>container-runtime，负责提供容器运行时(如docker engine)</li>
<li>kube-apiserver，负责提供API接口服务</li>
<li>etcd，高可用的键值存储系统，负责存储集群中各种资源对象的状态信息</li>
<li>c-m(controller manager)，负责管理集群中各种资源对象的状态</li>
<li>sched(schedular)，负责监控集群中所有节点的资源使用情况，然后根据一些调度策略，将pod调度到合适的node上运行</li>
<li>c-c-m(cloud controller manager)，云平台控制器，负责与云平台的api交互</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h3><p>minukube是一个轻量级的kubernetes实现，可在本地计算机上创建虚拟机，并部署仅包含一个节点的简单集群。</p>
<p>kubectl是一个命令行工具，可以通过在命令行输入各种命令与MasterNode的kube-apiserver交互，从而与Kubernetes集群进行交互。</p>
<p>在windows中使用chocolatey安装minukube</p>
<p><code>choco install minkube</code></p>
<p>查看版本信息验证是否安装成功</p>
<p><code>minikube version</code></p>
<p>创建集群(选择国内镜像源并指定版本)</p>
<p><code>minikube start --image-mirror-country=&#39;cn&#39;  --kubernetes-version=v1.23.9</code></p>
<p>查看集群中的节点信息</p>
<p><code>kubectl get nodes</code></p>
<p>Docker Desktop也自带了minukube，可手动开启。</p>
<h3 id="k3s"><a href="#k3s" class="headerlink" title="k3s"></a>k3s</h3><p>k3s是一个CNCF认证的轻量级的kubernetes发行版，可以方便地搭建一个多节点集群。</p>
<h4 id="准备虚拟机环境"><a href="#准备虚拟机环境" class="headerlink" title="准备虚拟机环境"></a>准备虚拟机环境</h4><p>在windows中使用chocolatey安装multipass</p>
<p><code>choco install multipass</code></p>
<p>创建一个名为k3s的虚拟机</p>
<p><code>multipass launch --name k3s</code></p>
<p>启动虚拟机</p>
<p><code>multipass start k3s</code></p>
<p>登录到虚拟机</p>
<p><code>multipass shell k3s</code></p>
<p>通过multipass创建的虚拟机默认不允许SSH远程登录，需要额外配置。</p>
<ul>
<li>添加用户密码 <code>sudo passwd ubuntu</code></li>
<li>修改SSH配置 <code>sudo vi /etc/ssh/sshd_config</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PubkeyAuthentication yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">KbdInteractiveAuthentication yes    </span><br></pre></td></tr></table></figure></li>
<li>重启SSH服务 <code>sudo service ssh restart</code></li>
<li>使用SSH登录 <code>ssh ubuntu@ip</code></li>
</ul>
<h4 id="创建和配置Master节点"><a href="#创建和配置Master节点" class="headerlink" title="创建和配置Master节点"></a>创建和配置Master节点</h4><p>使用国内镜像安装k3s</p>
<p><code>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -</code></p>
<p>查看当前节点(Master节点)</p>
<p><code>sudo kubectl get nodes</code></p>
<h4 id="创建和配置Worker节点"><a href="#创建和配置Worker节点" class="headerlink" title="创建和配置Worker节点"></a>创建和配置Worker节点</h4><p>在Master节点上获取token，作为其它节点加入集群的凭证</p>
<p><code>sudo cat /var/lib/rancher/k3s/server/node-token</code></p>
<p>将TOKEN保存到环境变量</p>
<p><code>TOKEN=$(multipass exec k3s sudo cat /var/lib/rancher/k3s/server/node-token)</code></p>
<p>保存master节点的IP地址</p>
<p><code>MASTER_IP=$(multipass info k3s | grep IPv4 | awk &#39;&#123;print $2&#125;&#39;)</code></p>
<p>使用刚刚的TOKEN和MASTER_IP来创建两个worker节点，并把它们加入到集群中</p>
<ul>
<li><p>创建两个worker节点的虚拟机</p>
<p>  <code>multipass launch --name worker1 --cpus 2 --memory 8G --disk 10G</code></p>
<p>  <code>multipass launch --name worker2 --cpus 2 --memory 8G --disk 10G</code></p>
</li>
<li><p>在worker节点虚拟机上安装k3s</p>
<p>  <code>for f in 1 2; do   multipass exec worker$f -- bash -c &quot;curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=\&quot;https://$MASTER_IP:6443\&quot; K3S_TOKEN=\&quot;$TOKEN\&quot; sh -&quot;   done</code></p>
</li>
</ul>
<h3 id="在线环境"><a href="#在线环境" class="headerlink" title="在线环境"></a>在线环境</h3><p>k8s也可通过在线环境使用</p>
<ul>
<li><p><a class="link"   href="https://labs.play-with-k8s.com/" >labs.play-with-k8s<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://killercoda.com/" >killercoda<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h2 id="kubectl常用命令"><a href="#kubectl常用命令" class="headerlink" title="kubectl常用命令"></a>kubectl常用命令</h2><p>创建一个pod</p>
<p><code>sudo kubectl run [pod-name] --image=[image-name]</code></p>
<p>创建一个deployment，指定镜像为nginx</p>
<p><code>sudo kubectl create deployment [deployment-name] --image=[image-name]</code></p>
<p>通过配置文件创建一个deployment</p>
<p><code>vi [deployment-name].yaml</code></p>
<p><code>sudo kubectl create -f [deployment-name].yaml</code></p>
<p>修改deployment</p>
<p><code>sudo kubectl edit deployment [deployment-name]</code></p>
<p>通过配置文件修改deployment</p>
<p><code>sudo kubectl apply -f [deployment-name].yaml</code></p>
<p>删除deployment</p>
<p><code>sudo kubectl delete deployment [deployment-name]</code></p>
<p>通过配置文件删除deployment</p>
<p><code>sudo kubectl delete -f [deployment-name].yaml</code></p>
<p>查看pod或deployment</p>
<p><code>sudo kubectl get pod</code></p>
<p><code>sudo kubectl get deployment</code></p>
<p>查看pod日志</p>
<p><code>sudo kubectl logs [pod-name]</code></p>
<p>将deployment对外公开为service</p>
<p><code>sudo kubectl expose deployment [deployment-name]</code></p>
<p>查看服务详细信息</p>
<p><code>sudo kubectl describe service [deployment-name]</code></p>
<p>删除服务</p>
<p><code>sudo kubectl delete service [deployment-name]</code></p>
<p>通过配置文件创建NodePort类型的服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 使用的Kubernetes API版本，这里是v1。</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 定义资源类型为Service，表示创建一个服务。</span></span><br><span class="line"><span class="attr">metadata:</span>  <span class="comment"># 元数据部分，用于描述Service的基本信息。</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>  <span class="comment"># Service的名称为nginx-service。</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 规格部分，定义Service的规格。</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>	<span class="comment"># 指定服务类型，默认为ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span>  <span class="comment"># 选择器部分，用于指定服务应该选择哪些Pod作为后端。</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>  <span class="comment"># 选择具有标签app=nginx的Pod作为后端。</span></span><br><span class="line">  <span class="attr">ports:</span>  <span class="comment"># 端口配置，定义Service暴露的端口。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span>  <span class="comment"># 使用TCP协议。</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service暴露的端口号为80。</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span>  <span class="comment"># 转发到后端Pod的端口号也为80。</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span></span><br></pre></td></tr></table></figure>

<p><code>sudo kubectl apply -f [service-name].yaml</code></p>
<p>查看当前集群命名空间</p>
<p><code>sudo kubectl ns</code></p>
<h2 id="可视化管理工具Portainer"><a href="#可视化管理工具Portainer" class="headerlink" title="可视化管理工具Portainer"></a>可视化管理工具Portainer</h2><p>安装portainer，并将其暴露在NodePort&#x3D;30777上</p>
<p><code>kubectl apply -n portainer -f https://downloads.portainer.io/ce2-19/portainer.yaml</code></p>
<p>在集群外部输入ip地址+端口号即可访问。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://kubernetes.io/docs/home/" >kubernetes官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://minikube.sigs.k8s.io/docs/" >minukube官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://multipass.run/docs/multipass-cli-client" >multipass官方文档-常用命令<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.rancher.cn/docs/k3s/quick-start/_index/" >k3s官方文档-快速入门<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.portainer.io/" >Portainer官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/Hexo-Blog/2024/08/16/linux-usage/</url>
    <content><![CDATA[<p>Linux系统基本概念、安装配置、各级目录含义、常用命令，以及VI&#x2F;VIM、GUN nano编辑器使用方法。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux系统相比于Windows而言，开源，运行更稳定和安全。Linux系统是一个多层次的结构，包含了内核、系统库、shell以及应用程序。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h3><p>Linux发行版是Linux内核与软件包、系统工具、库文件等组成的一个完整的操作系统，它提供了一个预先配置好的Linux环境，使我们能更方便的安装、配置、使用Linux系统。常见的发型版有Redhat、CentOS、Ubuntu、Alpine等。</p>
<h2 id="安装配置Linux"><a href="#安装配置Linux" class="headerlink" title="安装配置Linux"></a>安装配置Linux</h2><p>Linux系统可通过虚拟机软件(如VMWare&#x2F;VirtualBox&#x2F;Multipass)、容器(如Docker)安装，也可通过云服务器(如AWS&#x2F;Azure&#x2F;阿里云)直接使用。</p>
<p>Windows系统中推荐使用WSL安装适用于Linux的Windows子系统，初次安装可使用命令<code>wsl --install</code>，可使用命令<code>wsl --update</code>更新至最新版。在Microsoft Store中也可直接下载Linux的发行版(如Ubuntu)。</p>
<p>此外，还可以<a href="(https://cn.ubuntu.com/download)">下载Unbuntu镜像文件</a>，然后通过VMWare安装Unbuntu。</p>
<h2 id="VI-VIM编辑器"><a href="#VI-VIM编辑器" class="headerlink" title="VI&#x2F;VIM编辑器"></a>VI&#x2F;VIM编辑器</h2><p>Linux系统中没有图形化编辑器，通常在服务器环境上需要借助VIM快速编辑修改文件配置。</p>
<p>VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器。VIM编辑器是从VI发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI编辑器完全兼容。</p>
<p>VIM包含一般模式、编辑模式、命令模式等，相应的语法详见VIM使用参考手册。</p>
<h2 id="GNU-nano编辑器"><a href="#GNU-nano编辑器" class="headerlink" title="GNU nano编辑器"></a>GNU nano编辑器</h2><p>nano是一个字符终端文本编辑器，有点像DOS下的editor程序。它比VI&#x2F;VIM要简单得多，比较适合Linux初学者使用。</p>
<p>nano命令可以打开指定文件进行编辑，默认情况下它会自动断行，可使用<code>nano -w</code>禁止自动换行。</p>
<p>像Pico一样，nano是面向键盘的，它通过Ctrl键来控制。比如Ctrl+O保存当前文件(会让你输入文件名，按下Enter即可)，Ctrl+X退出编辑器。nano在屏幕底部显示两行快捷键，列出了当前状态下能用的命令。更多用法详见nano使用参考手册。</p>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>按照修改时间逆序显示文件的详细信息</p>
<p><code>ls -ltr</code></p>
<p>查看文件内容</p>
<p><code>cat [file]</code></p>
<p>创建空文件</p>
<p><code>touch [file]</code></p>
<p>创建文件并写入文件内容</p>
<p><code>echo [content] &gt; [file]</code></p>
<p>创建硬链接文件(源文件删除不影响目标文件)</p>
<p><code>ln [target_file] [source_file]</code></p>
<p>创建软链接文件(源文件删除会影响目标文件)</p>
<p><code>ln  -s [target_file] [source_file]</code></p>
<p>删除文件</p>
<p><code>rm [file]</code></p>
<p>以索引方式删除文件(乱码文件)</p>
<p><code>ls -i</code></p>
<p><code>find -inum [index] -delete</code></p>
<p>复制文件</p>
<p><code>cp [source_file] [target_file]</code></p>
<p>重命名文件</p>
<p><code>mv [source_file] [target_file]</code></p>
<p>给文件添加权限</p>
<p><code>chmod [u/g/o/a]+[w/r/x] [file]</code></p>
<p>给文件添加最高权限</p>
<p><code>chmod 777 [file]</code></p>
<h3 id="目录和文件夹"><a href="#目录和文件夹" class="headerlink" title="目录和文件夹"></a>目录和文件夹</h3><p>Linux系统中各级目录含义如下图所示。</p>
<img   src="/Hexo-Blog/2024/08/16/linux-usage/linux_dir.png"  class="" title="Linux系统中各目录含义">

<p>查看当前目录</p>
<p><code>pwd</code></p>
<p>切换到根目录</p>
<p><code>cd /</code></p>
<p>切换到用户目录</p>
<p><code>cd -</code></p>
<p>创建目录</p>
<p><code>mkdir [dir]</code></p>
<p>创建多级目录</p>
<p><code>mkdir -p [dir1]/[dir2]/..</code></p>
<p>复制目录</p>
<p><code>cp -r [source_dir] [target_dir]</code></p>
<p>查看目录结构(文件大小)</p>
<p><code>du</code> </p>
<p><code>sudo apt install tree</code></p>
<p><code>tree</code></p>
<p>删除目录</p>
<p><code>rm -r [dir]</code></p>
<h3 id="dotnet程序包更新"><a href="#dotnet程序包更新" class="headerlink" title="dotnet程序包更新"></a>dotnet程序包更新</h3><p>切换到root用户(使用<code>su - [username]</code>返回当前用户)</p>
<p><code>sudo su -</code></p>
<p>列出系统中所有进程的详细信息</p>
<p><code>ps -ef | grep dotnet</code></p>
<p>关闭进程</p>
<p><code>sudo kill -9 [pid]</code></p>
<p>查找进程文件夹</p>
<p><code>ll /proc/[pid]</code></p>
<p>进入进程文件夹并覆盖式上传程序包</p>
<p><code>cd /opt/vhosts/...</code></p>
<p><code>rz -y</code></p>
<p>解压程序包</p>
<p><code>unzip -o [*.zip]</code></p>
<p>启动程序</p>
<p><code>nohup dotnet [app].Web.dll --urls=http://localhost:[port] &amp;</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/windows/wsl/install" >如何使用WSL在Windows上安装Linux<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://vimcdoc.sourceforge.net/doc/editing.html" >VIM使用参考手册<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.nano-editor.org/dist/latest/nano.html" >GNU nano使用参考手册<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://info-ee.surrey.ac.uk/Teaching/Unix/index.html" >Linux Tutorial for Beginners<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Operation-System</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文档型数据库MongoDB使用介绍</title>
    <url>/Hexo-Blog/2025/11/10/mongodb-usage/</url>
    <content><![CDATA[<p>MongoDB文档型NoSQL数据库中的使用特性、适用场景，以及命令行工具Mongo Shell、操作符表达式等使用介绍。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MongoDB是一个开源的、面向文档的NoSQL数据库，它在设计上与传统的关系型数据库（如 MySQL、Oracle）有很大不同。它使用类似JSON的文档模型存储数据，将数据存储为BSON（Binary JSON）格式的”文档”，而不是行和列。这种格式使得数据存储非常灵活，表达非常自然和强大。MongoDB旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<h2 id="使用特性"><a href="#使用特性" class="headerlink" title="使用特性"></a>使用特性</h2><p>MongoDB与关系型数据库的核心概念对比如下:</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>MongoDB（文档数据库）</th>
<th>关系型数据库（如 MySQL）</th>
</tr>
</thead>
<tbody><tr>
<td>数据库</td>
<td>Database</td>
<td>Database</td>
</tr>
<tr>
<td>表&#x2F;集合</td>
<td>Collection</td>
<td>Table</td>
</tr>
<tr>
<td>行&#x2F;文档</td>
<td>Document</td>
<td>Row</td>
</tr>
<tr>
<td>列&#x2F;字段</td>
<td>Field</td>
<td>Column</td>
</tr>
<tr>
<td>主键</td>
<td>_id（默认自动创建）</td>
<td>Primary Key</td>
</tr>
<tr>
<td>索引</td>
<td>index</td>
<td>index</td>
</tr>
<tr>
<td>表关联</td>
<td>引用（$lookup）或嵌入式文档</td>
<td>Join（表连接）</td>
</tr>
<tr>
<td>Schema</td>
<td>动态模式（无模式）</td>
<td>预定义，严格的模式</td>
</tr>
</tbody></table>
<p>MongoDB与传统关系型数据库相比，具有以下优势：</p>
<ul>
<li>灵活的文档模式（无模式）：同一个集合（Collection）中的文档（Document）不需要具有相同的结构（字段），每个文档可以有自己的独特字段。这对于快速迭代的开发非常友好，可以在不关闭数据库的情况下，随时为数据添加新字段，极大地提高了开发效率。</li>
<li>现代化的存储格式：文档以一种类似于JSON的格式存储，称为BSON。它支持丰富的数据类型，如字符串、数字、日期、数组，甚至嵌套的其他文档。这种格式对于现代编程语言来说非常自然，减少了数据在应用层和数据库层之间转换的复杂性。</li>
<li>强大的查询语音：MongoDB提供了丰富的查询操作符，用于执行读取、更新、删除和聚合操作。它几乎能实现SQL的所有功能，语法同样强大且直观。</li>
<li>高性能优化方案：支持多种索引（单字段、复合、多键、地理空间、全文等），可以极大地加快查询速度。支持内存映射，将内存管理工作交给操作系统，利用系统缓存来优化性能。提供强大的聚合框架，可以对数据进行复杂的转换和分析，类似于SQL中的 GROUP BY和聚合函数，但更灵活。</li>
<li>高可用性与可扩展性：MongoDB通过复制集提供高可用性。一个复制集由多个节点组成（通常一主多从），主节点故障时，从节点会自动选举出新的主节点，确保服务不中断。当数据量巨大或吞吐量要求极高时，MongoDB支持分片（横向扩展）。它将一个集合的数据分布式地存储在多台机器（分片）上，形成一个数据库集群，从而突破单机性能瓶颈。</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>MongoDB的文档模型和无模式特性适用于以下场景：</p>
<ul>
<li>内容管理系统：文章、评论、标签等数据非常适合用文档模型来存储。</li>
<li>社交网络：用户档案、动态、好友列表等，其中包含大量非结构化和半结构化数据。</li>
<li>物联网：海量的设备传感器数据，通常是以时间序列的形式写入，MongoDB能够高效地处理这种写入密集型操作。</li>
<li>实时分析：聚合管道非常适合用于生成实时报表和分析数据。</li>
<li>产品目录：不同品类的商品拥有完全不同的属性，MongoDB的无模式特性可以完美应对这种多变性。</li>
<li>移动应用：其灵活的schema非常适合快速迭代的移动应用后端。</li>
</ul>
<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>一个标准的MongoDB连接字符串格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li>本地无认证方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb://localhost:27017/?directConnection=true&amp;serverSelectionTimeoutMS=2000&amp;appName=mongosh+2.5.9</span><br></pre></td></tr></table></figure>

<ul>
<li>带认证的数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb://myUser:myPassword@localhost:27017/myAppDatabase</span><br></pre></td></tr></table></figure>

<ul>
<li>复制集（集群）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb://host1:27017,host2:27017,host3:27017/myAppDatabase?replicaSet=myReplicaSet</span><br></pre></td></tr></table></figure>

<ul>
<li>Atlas 云数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodb+srv://myUser:myPassword@cluster0.abcde.mongodb.net/myAppDatabase</span><br></pre></td></tr></table></figure>

<h3 id="GUI方式"><a href="#GUI方式" class="headerlink" title="GUI方式"></a>GUI方式</h3><p>MongoDB Compass是MongoDB官方提供的免费、图形化界面（GUI）工具，用于与MongoDB数据库进行交互。</p>
<h3 id="CLI方式"><a href="#CLI方式" class="headerlink" title="CLI方式"></a>CLI方式</h3><p>MongoDB Shell是MongoDB提供的命令行工具，允许用户与MongoDB数据库进行交互、执行命令和操作数据库。下载完MongoCompass后可前往<a class="link"   href="https://www.mongodb.com/try/download/shell" >MongoDB Shell下载地址<i class="fas fa-external-link-alt"></i></a>自行下载。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>启动Shell</p>
<p><code>mongosh</code></p>
<p>此时会连接到本地MongoDB服务器，连接成功后，可以执行各种MongoDB数据库操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">show dbs <span class="comment"># 显示数据库列表</span></span></span><br><span class="line"><span class="meta prompt_">test&gt; </span><span class="language-bash">use &lt;database_name&gt; <span class="comment"># 切换到指定数据库</span></span></span><br><span class="line">&lt;database_name&gt; &gt; db.&lt;collection_name&gt;.insertOne(&#123; ... &#125;) # 向指定集合插入文档</span><br><span class="line">&lt;database_name&gt; &gt; db.&lt;collection_name&gt;.find() # 查询指定文档</span><br><span class="line">&lt;database_name&gt; &gt; db.&lt;collection_name&gt;.updateOne(&#123; ... &#125;) # 向指定集合更新文档</span><br><span class="line">&lt;database_name&gt; &gt; db.&lt;collection_name&gt;.deleteOne(&#123; ... &#125;) # 向指定集合删除文档</span><br></pre></td></tr></table></figure>

<p>退出Shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;database_name&gt; &gt; quit</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li>插入文档</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mydatabase&gt; </span><span class="language-bash">db.mycollection.insertOne(&#123; name: <span class="string">&quot;Alice&quot;</span>, age: 30 &#125;)</span></span><br><span class="line">&#123;</span><br><span class="line">  acknowledged: true,</span><br><span class="line">  insertedId: ObjectId(&#x27;69118ecdae2964f29e63b112&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询文档</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mydatabase&gt; </span><span class="language-bash">db.mycollection.find()</span></span><br><span class="line">[</span><br><span class="line">    &#123; _id: ObjectId(&#x27;667cd8789a69705686ed70f2&#x27;), name: &#x27;Alice&#x27;, age: 31 &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>更新文档</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mydatabase&gt; </span><span class="language-bash">db.mycollection.updateOne(&#123; name: <span class="string">&quot;Alice&quot;</span> &#125;, &#123; <span class="variable">$set</span>: &#123; age: 31 &#125; &#125;)</span></span><br><span class="line">&#123;</span><br><span class="line">  acknowledged: true,</span><br><span class="line">  insertedId: null,</span><br><span class="line">  matchedCount: 1,</span><br><span class="line">  modifiedCount: 1,</span><br><span class="line">  upsertedCount: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文档</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mydatabase&gt; </span><span class="language-bash">db.mycollection.deleteOne(&#123; name: <span class="string">&quot;Alice&quot;</span> &#125;)</span></span><br><span class="line">&#123; </span><br><span class="line">    acknowledged: true, deletedCount: 1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作符表达式"><a href="#操作符表达式" class="headerlink" title="操作符表达式"></a>操作符表达式</h2><p>MongoDB的操作符表达式是其查询语言的核心，可以构建复杂且强大的查询、更新、聚合等操作。这些操作符以$符号开头。</p>
<h3 id="查询操作符"><a href="#查询操作符" class="headerlink" title="查询操作符"></a>查询操作符</h3><p>用于find()、update()等方法中，定位符合条件的文档。</p>
<ul>
<li>比较操作符：例如$eq、$gt、$lt、$in等</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.find(&#123; age: &#123; $lt: 25 &#125; &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑操作符：例如$and、$or、$not、$nor</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.find(&#123; $and: [ &#123; status: &quot;A&quot; &#125;, &#123; age: &#123; $lt: 30 &#125; &#125; ] &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>元素操作符：例如$exists(匹配具有指定字段的文档)、$type(匹配字段是指定 BSON 类型的文档)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.find(&#123; phone: &#123; $exists: true &#125; &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>数组操作符：$all(匹配包含数组中指定的所有元素的数组)、$elemMatch(匹配数组中的元素能同时满足所有指定条件的)、$size(匹配数组大小等于指定值的文档)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.find(&#123; scores: &#123; $elemMatch: &#123; $gt: 80， $lt: 90 &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a>更新操作符</h3><p>用于update()和findAndModify()等方法中，修改文档的内容。</p>
<ul>
<li>字段更新操作符：例如$set(设置字段的值)、$unset(删除指定字段)、$rename(重命名字段)、$inc(将字段的值增加指定的数量)等</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.update(&#123;&#125;, &#123; $set: &#123; status: &quot;A&quot;， modified: ISODate() &#125; &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>数组更新操作符：例如$[&lt;identifier&gt;](过滤后的位置操作符，与arrayFilters一起使用，更新所有符合过滤条件的数组元素)、$pop、$pull、$push</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.update(&#123;&#125;, &#123; $set: &#123; “grades.$[elem].score”: 100 &#125; &#125;, &#123; arrayFilters: [ &#123; “elem.score”: &#123; $lte: 80 &#125; &#125; ] &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="聚合管道操作符"><a href="#聚合管道操作符" class="headerlink" title="聚合管道操作符"></a>聚合管道操作符</h3><p>用于aggregate()方法中，对数据进行转换和计算。它们在聚合管道的各个阶段中使用。</p>
<ul>
<li><p>阶段操作符：例如$match、$group、$sort、$limit、$skip、$lookup(对同一数据库中的另一个集合执行左外连接)、$project(重塑文档流，例如添加、删除、重命名字段，类似于投影)</p>
</li>
<li><p>表达式操作符(常用于$group)：$sum、$avg、$firt、$last、$min、$max</p>
</li>
</ul>
<p>示例：获取所有用户，并列出他们发表的所有文章。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="property">users</span>.<span class="title function_">aggregate</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">$lookup</span>: &#123;</span><br><span class="line">      <span class="attr">from</span>: <span class="string">&quot;posts&quot;</span>,</span><br><span class="line">      <span class="attr">localField</span>: <span class="string">&quot;_id&quot;</span>,       <span class="comment">// users 的 _id</span></span><br><span class="line">      <span class="attr">foreignField</span>: <span class="string">&quot;authorId&quot;</span>, <span class="comment">// posts 的 authorId</span></span><br><span class="line">      <span class="attr">as</span>: <span class="string">&quot;userPosts&quot;</span>          <span class="comment">// 这个数组会包含用户的所有文章</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">$project</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">email</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;userPosts.title&quot;</span>: <span class="number">1</span>,    <span class="comment">// 只投影出文章的 title 和 date</span></span><br><span class="line">      <span class="string">&quot;userPosts.createdAt&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://www.mongodb.com/zh-cn/docs/manual/" >MongoDB官方中文文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.mongodb.com/zh-cn/docs/mongodb-shell/" >MongoDB Shell使用参考<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>基于.NET的MSBuild常用命令</title>
    <url>/Hexo-Blog/2024/12/02/msbuild/</url>
    <content><![CDATA[<p>基于.NET的MSBuild常用命令记录。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Microsoft生成引擎是一个用于生成应用程序的平台。此引擎（也称为 MSBuild）为项目文件提供了一个XML架构，用于控制生成平台处理和生成软件的方式。Visual Studio会使用MSBuild，但MSBuild不依赖于Visual Studio。通过在项目或解决方案文件中调用msbuild.exe或dotnet build，可以在未安装Visual Studio的环境中安排和生成产品。</p>
<h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>以VS 2022为例，MSBuild可执行文件路径为<code>C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin</code></p>
<h2 id="项目配置文件"><a href="#项目配置文件" class="headerlink" title="项目配置文件"></a>项目配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--回车符\r &amp;#xD; 换行符\n &amp;#xA; 双引号&quot; &amp;quot;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;PostBuild&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;PostBuildEvent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">&quot;if &#x27;$(IS_Integrated)&#x27; == &#x27;true&#x27; (<span class="symbol">&amp;#xD;</span><span class="symbol">&amp;#xA;</span>  xcopy $(TargetPath) $(SolutionDir)..\Outputs\  /R /Y<span class="symbol">&amp;#xD;</span><span class="symbol">&amp;#xA;</span>  xcopy $(TargetDir)$(TargetName).dll $(SolutionDir)..\Outputs\  /R /Y<span class="symbol">&amp;#xD;</span><span class="symbol">&amp;#xA;</span>)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;CopyDirectory&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;Build&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CopyCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27; == &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>xcopy <span class="symbol">&amp;quot;</span>$(SolutionDir)..\Outputs\*.dll<span class="symbol">&amp;quot;</span> <span class="symbol">&amp;quot;</span>$(ProjectDir)bin\$(Configuration)\netcoreapp3.1\<span class="symbol">&amp;quot;</span> /E /D /I /Y</span><br><span class="line">        <span class="tag">&lt;/<span class="name">CopyCommand</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CopyCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27; != &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>cp -r <span class="symbol">&amp;quot;</span>$(SolutionDir)..\Outputs\*.dll<span class="symbol">&amp;quot;</span> <span class="symbol">&amp;quot;</span>$(ProjectDir)bin\$(Configuration)\netcoreapp3.1\<span class="symbol">&amp;quot;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">CopyCommand</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">&quot;$(CopyCommand)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;CreateFolderIfNotExists&quot;</span> <span class="attr">AfterTargets</span>=<span class="string">&quot;Build&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uploadPath</span>&gt;</span>$(ProjectDir)bin\$(Configuration)\upload<span class="tag">&lt;/<span class="name">uploadPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CreateCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27; == &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>if not exist <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span> md <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span><span class="tag">&lt;/<span class="name">CreateCommand</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CreateCommand</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(OS)&#x27;!= &#x27;Windows_NT&#x27;&quot;</span>&gt;</span>if [! -d <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span> ]; then mkdir -p <span class="symbol">&amp;quot;</span>$(uploadPath)<span class="symbol">&amp;quot;</span>; fi<span class="tag">&lt;/<span class="name">CreateCommand</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Exec</span> <span class="attr">Command</span>=<span class="string">&quot;$(CreateCommand)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="命令行构建"><a href="#命令行构建" class="headerlink" title="命令行构建"></a>命令行构建</h2><p>对于单个dotnet项目，可使用以下命令构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">项目文件携带环境变量的情况</span></span><br><span class="line">MSBuild [project file] /p:PropertyName=Value</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">MSBuild test.csproj /p:IS_Integrated = true</span><br></pre></td></tr></table></figure>

<h2 id="批处理构建"><a href="#批处理构建" class="headerlink" title="批处理构建"></a>批处理构建</h2><p>对于模块较多的dotnet项目，可使用批处理脚本批量构建，并跟踪构建情况</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> totalCount=<span class="number">14</span></span><br><span class="line"><span class="built_in">set</span> failCount=<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> failList=&quot;&quot;</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> your/test.sln/<span class="built_in">path</span></span><br><span class="line"><span class="built_in">echo</span> 正在构建test模块[进度 <span class="number">1</span>/<span class="variable">%totalCount%</span>]...</span><br><span class="line">dotnet build test.sln  &gt; <span class="built_in">nul</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorlevel%</span> <span class="keyword">neq</span> <span class="number">0</span> (</span><br><span class="line">    <span class="built_in">echo</span> test模块构建失败</span><br><span class="line">    <span class="built_in">set</span> /a failCount=failCount + <span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span> failList=&quot;<span class="variable">%failList%</span> test&quot;</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> test模块已构建成功！</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> /a successCount=<span class="variable">%totalCount%</span> - <span class="variable">%failCount%</span></span><br><span class="line"><span class="built_in">set</span> /p DUMMY=构建成功<span class="variable">%successCount%</span>个，失败<span class="variable">%failCount%</span>个，失败的模块有[<span class="variable">%failList%</span>]，请尝试手动构建，按回车键继续...</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link"   href="https://learn.microsoft.com/zh-cn/cpp/build/reference/common-macros-for-build-commands-and-properties" >用于MSBuild命令和属性的常用宏<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/msbuild-properties" >MSBuild 属性说明<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/xcopy" >xcopy命令参数说明<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Package-Tool</category>
      </categories>
      <tags>
        <tag>MSBuild</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用CLI命令及SQL语句</title>
    <url>/Hexo-Blog/2024/11/29/mysql-usage/</url>
    <content><![CDATA[<p>MySQL 数据库中的一些常用 SQL、CLI 命令，以及配置文件。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL 采用多种存储引擎，如 InnoDB 和 MyISAM 等。InnoDB 是 MySQL 默认的存储引擎，支持事务处理、行级锁和外键约束。MyISAM 存储引擎则更侧重于性能，适合以读为主的应用场景。MySQL 在简单的查询操作和高并发的读场景下，性能表现较好，但在处理复杂的嵌套查询和大规模数据写入时，性能可能会受到一定影响。MySQL 广泛应用于互联网行业的中小型应用、网站开发和云计算环境，因为它易于安装、配置和维护，能够满足大多数网站的基本数据存储和查询需求，同时拥有庞大的用户社区和丰富的文档资源及第三方工具和插件支持。</p>
<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>.NET 项目配置文件中数据库连接字符串如下，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;MysqlConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;userid=root;password=your-password;database=your-database;port=3306;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="MySQL-常用-CLI-命令"><a href="#MySQL-常用-CLI-命令" class="headerlink" title="MySQL 常用 CLI 命令"></a>MySQL 常用 CLI 命令</h2><h3 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h3><p>mysqld，也称为 MySQL Server，是 MySQL 数据库系统中的核心组件。它是一个服务守护进程（daemon），负责管理数据库的访问和操作。在 Linux 系统中，服务通常以“d”结尾，代表守护进程。mysqld 作为服务器端程序，它处理来自客户端程序的网络连接请求，并管理对数据库的访问。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>初始化 mysql 服务，初始化数据目录，但不生成随机密码(设置数据库空密码)，同时指定运行 mysqld 服务器的用户名为 root，端口号为 3306</p>
<p><code>mysqld --initialize-insecure --user=root --port=3306 --console</code></p>
<p>安装 mysql 服务，命名为 MySQL80，并设置默认配置文件</p>
<p><code>mysqld --install MySQL80 --defaults-file=C:\Program Files\MySQL\MySQL Server 8.0\my.ini</code></p>
<p>启动 MySQL80 服务</p>
<p><code>net start ANWISE-MySQL</code></p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>my.ini 配置文件内容如下，</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="comment"># 配置免密登录 (可选)</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">password</span>=your_passowrd</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">basedir</span>=C:\Program Files\MySQL\MySQL Server <span class="number">8.0</span></span><br><span class="line"><span class="attr">datadir</span>=C:\Program Files\MySQL\MySQL Server <span class="number">8.0</span>\data</span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="attr">default-storage-engine</span>=InnoDB</span><br><span class="line"><span class="attr">log_timestamps</span>=SYSTEM</span><br><span class="line"><span class="attr">innodb_page_size</span>=<span class="number">64</span>K</span><br><span class="line"><span class="attr">max_allowed_packet</span>=<span class="number">1</span>G</span><br><span class="line"><span class="comment"># 配置sql_mode (可选)</span></span><br><span class="line"><span class="attr">sql_mode</span>=<span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>mysql 是 MySQL 自带的命令行客户端程序，用于交互式输入 SQL 语句或以批处理模式从文件执行它们。</p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><p>登录 mysql</p>
<p><code>mysql -u root -P 3306</code></p>
<p>修改 mysql 密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;your_passowrd&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">flush privileges;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">quit;</span></span><br></pre></td></tr></table></figure>

<p>查看所有数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt;</span><span class="language-bash">show databases;</span></span><br></pre></td></tr></table></figure>

<p>执行SQL文件(需要在控制台中将字符编码设置为UTF-8)</p>
<p><code>chcp 65001</code></p>
<p><code>mysql -uroot -p[your_passowrd] -D[your_databse] &lt; [your_script].sql</code></p>
<h2 id="MySQL-常用-SQL"><a href="#MySQL-常用-SQL" class="headerlink" title="MySQL 常用 SQL"></a>MySQL 常用 SQL</h2><h3 id="CREATE-GRANT"><a href="#CREATE-GRANT" class="headerlink" title="CREATE&#x2F;GRANT"></a>CREATE&#x2F;GRANT</h3><p>CREATE 可用于创建库名和用户名，配合GRANT可以在创建用户的同时赋予权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库名</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `demo` <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8mb4&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8mb4_unicode_ci&#x27;</span>;</span><br><span class="line"><span class="comment">-- 创建用户并赋予权限</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> test@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> demo.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;                </span><br></pre></td></tr></table></figure>

<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>获取数据库中所有 TRUNCATE 语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	CONCAT(<span class="string">&#x27;TRUNCATE TABLE &#x27;</span>, table_schema, <span class="string">&#x27;.&#x27;</span>, TABLE_NAME, <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	table_schema <span class="keyword">IN</span> (<span class="string">&#x27;db_name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="TRUNCATE-DROP-DELETE"><a href="#TRUNCATE-DROP-DELETE" class="headerlink" title="TRUNCATE&#x2F;DROP&#x2F;DELETE"></a>TRUNCATE&#x2F;DROP&#x2F;DELETE</h3><p>TRUNCATE 只能操作表，将表中数据全部删除，在功能上和不带 WHERE 子句的 DELETE 语句相同，但是 TRUNCATE 会释放表空间，且不能回滚事务。TRUNCATE 一般会配合禁用&#x2F;启动外键约束的语句使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 禁用外键约束</span></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [table_name]</span><br><span class="line"><span class="comment">-- 开启外键约束</span></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>DROP 将删除表的结构，以及被依赖的约束、触发器、索引。DROP 执行速度最快。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [table_name]</span><br></pre></td></tr></table></figure>

<p>DELETE 将表中数据全部删除，但是不会释放表空间，可以回滚事务。DELETE 执行速度最慢。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> [table_name]</span><br></pre></td></tr></table></figure>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>举例，对 int 类型的字段值进行转换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建存储函数</span></span><br><span class="line">DELIMITER  <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> IF <span class="keyword">EXISTS</span> convert_function <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> convert_function([var_name] <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> res <span class="type">INT</span>;</span><br><span class="line">	IF [var_name]  <span class="operator">=</span> <span class="number">100</span> <span class="keyword">THEN</span></span><br><span class="line">		<span class="keyword">SET</span> res <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">RETURN</span> res;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储函数</span></span><br><span class="line"><span class="keyword">SELECT</span> convert_function(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>mysql支持对类型为json的字段值进行操作，例如修改类型为<strong>json</strong>的字段中的某个属性值，需要调用JSON_SET和JSON_EXTRACT</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [table_name] t</span><br><span class="line"><span class="keyword">SET</span> t.json <span class="operator">=</span> JSON_SET(t.json, <span class="string">&#x27;$.myProperty&#x27;</span>, convert_function(JSON_EXTRACT(t.json, <span class="string">&#x27;$.myProperty&#x27;</span>)));</span><br></pre></td></tr></table></figure>

<p>举例，修改类型为<strong>json数组</strong>的字段中的某个属性值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> update_json_array <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_json_array()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> json_index <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> json_length <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> current_id <span class="type">char</span>(<span class="number">36</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> current_json JSON;</span><br><span class="line">    <span class="keyword">DECLARE</span> cursor_json <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">        <span class="keyword">SELECT</span> id, json <span class="keyword">FROM</span> [table_name];</span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">OPEN</span> cursor_json;</span><br><span class="line">    read_loop: LOOP</span><br><span class="line">        <span class="keyword">FETCH</span> cursor_json <span class="keyword">INTO</span> current_id, current_json;</span><br><span class="line">        IF done <span class="keyword">THEN</span></span><br><span class="line">            LEAVE read_loop;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">        <span class="keyword">SET</span> json_length <span class="operator">=</span> JSON_LENGTH(current_json);</span><br><span class="line">        WHILE json_index <span class="operator">&lt;</span> json_length DO</span><br><span class="line">            <span class="comment">-- 更新json数组中每个对象的属性值</span></span><br><span class="line">            <span class="keyword">SET</span> current_json <span class="operator">=</span> JSON_SET(current_json,</span><br><span class="line">                CONCAT(<span class="string">&#x27;$[&#x27;</span>, json_index, <span class="string">&#x27;].myProperty&#x27;</span>), convert_function(JSON_EXTRACT(current_json, CONCAT(<span class="string">&#x27;$[&#x27;</span>, json_index, <span class="string">&#x27;].myProperty&#x27;</span>))));</span><br><span class="line">            <span class="keyword">SET</span> json_index <span class="operator">=</span> json_index <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 更新表中的记录</span></span><br><span class="line">        <span class="keyword">UPDATE</span> [table_name]</span><br><span class="line">        <span class="keyword">SET</span> files <span class="operator">=</span> current_json</span><br><span class="line">        <span class="keyword">WHERE</span> id <span class="operator">=</span> current_id;</span><br><span class="line">        <span class="keyword">SET</span> json_index <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line">    <span class="keyword">CLOSE</span> cursor_json;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> update_json_array();</span><br></pre></td></tr></table></figure>

<h3 id="全局参数修改"><a href="#全局参数修改" class="headerlink" title="全局参数修改"></a>全局参数修改</h3><blockquote>
<p>Error Code: 1418. This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you <em>might</em> want to use the less safe log_bin_trust_function_creators variable)</p>
</blockquote>
<p>出现如上报错，需要修改<code>log_bin_trust_function_creators</code>的值为true，<code>log_bin_trust_function_creators</code>控制是否可以信任存储函数创建者，不会创建写入二进制日志引起不安全事件的存储函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="literal">TRUE</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a class="link"   href="https://mysql.net.cn/doc/refman/8.0/en/" >MySQL 官方中文文档<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理与负载均衡</title>
    <url>/Hexo-Blog/2024/08/16/nginx-usage/</url>
    <content><![CDATA[<p>Nginx常用命令，反向代理与负载均衡实现方法，以及HTTPS配置。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是高性能的HTTP和反向代理的web服务器，处理高并发能力是十分强大，能支持高达50,000个并发连接数。Nginx支持热部署，启动简单，可以做到7*24不间断运行，几个月都不需要重新启动。Nginx适用于各种场景，包括静态文件服务、反向代理、负载均衡等。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="正向-反向代理"><a href="#正向-反向代理" class="headerlink" title="正向&#x2F;反向代理"></a>正向&#x2F;反向代理</h3><p>正向代理代理的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过何种方式访问的。</p>
<img   src="/Hexo-Blog/2024/08/16/nginx-usage/forward_proxy.png"  class="" title="正向代理架构图">

<p>反向代理代理的是服务端，客户端对代理是无感知的，客户端不需要任何配置就可以访问。我们只需要把请求发送给反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器的地址。</p>
<img   src="/Hexo-Blog/2024/08/16/nginx-usage/reverse_proxy.png"  class="" title="反向代理架构图">

<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>proxy_pass是Nginx中一个非常重要的指令，用于将请求代理到后端服务器。它可以用于HTTP和Stream模块，分别处理HTTP请求和TCP&#x2F;UDP流量。</p>
<p>proxy_pass的基本语法如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_pass URL;</span><br></pre></td></tr></table></figure>

<p>在proxy_pass后面的URL以斜杠&#x2F;结束，表示绝对根路径。例如下面的例子中，访问<code>http://example.com/proxy/test.html</code>会被转发到<code>http://127.0.0.1/test.html</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location /proxy/ &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在proxy_pass后面的URL不以斜杠&#x2F;结束，表示相对路径。例如下面的例子中，访问<code>http://example.com/proxy/test.html</code>会被转发到<code>http://127.0.0.1/proxy/test.html</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location /proxy/ &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是指增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上。</p>
<p>Nignx提供了三种负载均衡的方式：轮询法(默认)、加权轮询、ip_hash。</p>
<p>这三种负载均衡方式可以组合使用，例如搭建三个服务器并完成反向代理，对应的配置文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 127.0.0.1:8000 weight=3;</span><br><span class="line">        server 127.0.0.1:8001;</span><br><span class="line">        server 127.0.0.1:8002;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        location /app &#123;</span><br><span class="line">            proxy_pass http://backend; </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>Nignx可通过包管理器、C语言编译、docker等方式安装。</p>
<p>Linux平台下，使用包管理器安装</p>
<p><code>sudo apt update</code></p>
<p><code>sudo apt install nginx</code></p>
<p>使用docker安装</p>
<p><code>docker pull nginx</code></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>启动nginx</p>
<p><code>nginx</code></p>
<p>查看nginx进程</p>
<p><code>ps -ef|grep nginx</code></p>
<p>查看nginx端口占用情况</p>
<p><code>lsof -i:[port]</code></p>
<p>停止nginx</p>
<p><code>nginx -s stop</code> 或 <code>nginx -s quit</code></p>
<p>重载配置文件</p>
<p><code>nginx reload</code></p>
<p>重新打开配置文件</p>
<p><code>nginx reopen</code></p>
<p>查看安装目录、编译参数、日志文件及配置文件位置</p>
<p><code>nginx -V</code></p>
<p>查看nginx配置文件</p>
<p><code>nginx -t</code></p>
<p>静态文件部署</p>
<p><code>cp -rf * [path]</code></p>
<h2 id="HTTPS配置"><a href="#HTTPS配置" class="headerlink" title="HTTPS配置"></a>HTTPS配置</h2><p>HTTPS协议需要使用SSL证书，在主流的云平台上都可以申请到免费的SSL证书，也可以通过openssl命令生成一个自签名的证书(未经过CA认证)。</p>
<h3 id="使用openssl生成证书"><a href="#使用openssl生成证书" class="headerlink" title="使用openssl生成证书"></a>使用openssl生成证书</h3><p>生成私钥文件(private key)</p>
<p><code>openssl genrsa -out private.key 2048</code></p>
<p>根据私钥生成证书签名请求文件(csr文件)</p>
<p><code>openssl req -new -key private.key -out cert.csr</code></p>
<p>使用私钥对证书申请进行签名从而生成证书文件(pem文件)</p>
<p><code>openssl x509 -req -in cert.csr -out cacert.pem -signkey private.key</code></p>
<h3 id="修改nginx配置"><a href="#修改nginx配置" class="headerlink" title="修改nginx配置"></a>修改nginx配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        listen   443 ssl;</span><br><span class="line">        server_name         localhost;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        ssl_certificate_key www.example.com.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a class="link"   href="http://nginx.org/en/docs/" >Nignx官方文档<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Web-Server</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle常用SQL、PL/SQL语句</title>
    <url>/Hexo-Blog/2024/11/29/oracle-usage/</url>
    <content><![CDATA[<p>Oracle数据库的适用场景，以及一些常用SQL、PL&#x2F;SQL语句。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Oracle是由Oracle公司开发和维护的商业数据库管理系统，使用Oracle数据库通常需要购买许可证，价格因版本、功能、用户数量等因素而异。它主要面向对数据安全、性能和稳定性要求极高的大型企业、金融机构、电信公司等，这些企业愿意为高端的数据库解决方案支付较高的成本。Oracle在数据库技术和Java之间进行了大量的技术整合，Java是Oracle生态系统中企业级应用开发的核心语言，在企业资源规划（ERP）系统、客户关系管理（CRM）系统等大型企业应用中具有重要地位。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>Oracle数据库有以下性能特点和功能特性：</p>
<ul>
<li>处理复杂查询：Oracle在处理复杂的企业级查询和大规模数据操作方面表现卓越。</li>
<li>并发处理：Oracle采用多版本并发控制（MVCC）机制来处理高并发事务，同时还具备强大的锁机制来确保数据的一致性和完整性。在高并发的 OLTP（联机事务处理）环境下，如银行的网上交易系统，大量用户同时进行账户查询、转账等操作时，Oracle 能够有效地协调并发事务，避免数据冲突。</li>
<li>数据存储和读写性能：Oracle在存储结构上有多种存储选项，如自动存储管理（ASM）等，可以根据不同的应用场景和数据类型优化存储性能。</li>
<li>数据类型和扩展性：Oracle支持丰富的内置数据类型，包括基本数据类型以及复杂的数据类型（如XMLTYPE用于处理XML数据）。在扩展性方面，Oracle 提供了诸如分区表、索引组织表等功能来提高数据管理的效率。</li>
<li>备份和恢复功能：Oracle提供了一套完整的备份和恢复解决方案，包括物理备份和逻辑备份。它还支持闪回技术，可以在一定程度上快速恢复数据到某个时间点，这在应对数据误操作等情况时非常有用。</li>
<li>安全机制：Oracle具有高度复杂的安全体系，包括用户认证、授权、角色管理、数据加密等多个层面。它可以通过细粒度的权限控制，对不同用户和角色访问不同的数据对象和操作进行严格的限制。</li>
</ul>
<h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>在Oracle数据库中，模式是一个逻辑概念，它是一组数据库对象（如表、视图、存储过程、函数、序列等）的集合。可以将模式看作是一个用户所拥有的对象的容器，每个模式都与一个数据库用户相关联。</p>
<h4 id="使用CREATE-SCHEMA语句直接创建"><a href="#使用CREATE-SCHEMA语句直接创建" class="headerlink" title="使用CREATE SCHEMA语句直接创建"></a>使用CREATE SCHEMA语句直接创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有用户</span></span><br><span class="line"><span class="keyword">SELECT</span> USERNAME, USER_ID, ACCOUNT_STATUS <span class="keyword">FROM</span> DBA_USERS;</span><br><span class="line"><span class="comment">-- 查询当前用户</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span> <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 授权创建模式的系统权限给用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> SCHEMA <span class="keyword">TO</span> test_user;</span><br><span class="line"><span class="comment">-- 创建模式并授权所有者</span></span><br><span class="line"><span class="keyword">CREATE</span> SCHEMA new_schema <span class="keyword">AUTHORIZATION</span> test_user;</span><br></pre></td></tr></table></figure>

<h4 id="通过创建用户隐式创建模式"><a href="#通过创建用户隐式创建模式" class="headerlink" title="通过创建用户隐式创建模式"></a>通过创建用户隐式创建模式</h4><p>当创建一个新用户时，如果这个用户开始创建数据库对象（如创建表、视图等），Oracle会自动为这个用户创建一个与用户同名的模式来存放这些对象。</p>
<p>在Oracle容器数据库（CDB）架构中，包含一个根容器（CDB$ROOT）和多个可插拔数据库（PDB）。公用用户是可以在CDB的公共部分或者多个PDB中访问的用户。这些用户用于管理跨越多个PDB的公共资源或执行通用的管理任务。创建公用用户的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> C##test_user IDENTIFIED <span class="keyword">BY</span> test_password;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> SESSION <span class="keyword">TO</span> C##test_user;</span><br></pre></td></tr></table></figure>

<p>创建本地用户则需要切换当前会话到指定的PDB中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在容器数据库（CDB）中查看可插拔数据库（PDB）</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> v$pdbs;</span><br><span class="line"><span class="comment">-- 换到目标 PDB</span></span><br><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> CONTAINER <span class="operator">=</span> pdb1; </span><br><span class="line"><span class="comment">-- PDB中创建本地用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> new_schema_user IDENTIFIED <span class="keyword">BY</span> schema_password;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> SESSION <span class="keyword">TO</span> new_schema_user;</span><br></pre></td></tr></table></figure>

<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间是Oracle数据库中用于存储数据库对象（如表、索引等）的逻辑存储区域，后续创建的数据库对象可以指定存放在表空间里。</p>
<h4 id="表空间操作"><a href="#表空间操作" class="headerlink" title="表空间操作"></a>表空间操作</h4><p>创建表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE tablespace_name</span><br><span class="line">DATAFILE <span class="string">&#x27;datafile_path&#x27;</span> SIZE size_value;</span><br></pre></td></tr></table></figure>

<p>例如创建名为WORKHUB的表空间，并设置大小为50M</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE &quot;WORKHUB&quot;</span><br><span class="line">DATAFILE <span class="string">&#x27;WORKHUB.dbf&#x27;</span> SIZE <span class="number">50</span>M </span><br></pre></td></tr></table></figure>

<p>修改表所在空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MOVE TABLESPACE new_tablespace_name;</span><br></pre></td></tr></table></figure>

<p>修改用户在特定表空间中的配额</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> user_name QUOTA new_quota_size <span class="keyword">ON</span> tablespace_name;</span><br></pre></td></tr></table></figure>

<p>表空间参数组合使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> schema_name.table_name (</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">TABLESPACE &quot;WORKHUB&quot; <span class="comment">-- 定义了表空间的名称为 “WORKHUB”</span></span><br><span class="line">LOGGING <span class="comment">-- 启用日志记录功能</span></span><br><span class="line">NOCOMPRESS <span class="comment">-- 数据不进行压缩存储</span></span><br><span class="line">PCTFREE <span class="number">10</span> <span class="comment">-- 每个数据块中，会预留 10% 的空间作为空闲区域</span></span><br><span class="line">INITRANS <span class="number">1</span> <span class="comment">-- 每个数据块初始分配的事务入口数量为1</span></span><br><span class="line">STORAGE ( <span class="comment">-- 表空间存储相关参数的详细设置</span></span><br><span class="line">  <span class="keyword">INITIAL</span> <span class="number">65536</span>  <span class="comment">-- 指定了表空间的初始大小为 65536 * 8KB = 512MB</span></span><br><span class="line">  NEXT <span class="number">1048576</span> <span class="comment">-- 当表空间需要扩展时，每次扩展增加的大小为1048576 * 8KB = 8GB</span></span><br><span class="line">  MINEXTENTS <span class="number">1</span> <span class="comment">-- 表示表空间最初创建时至少包含的扩展次数为1</span></span><br><span class="line">  MAXEXTENTS <span class="number">2147483645</span> <span class="comment">-- 表空间最多可以扩展的次数为无限</span></span><br><span class="line">  BUFFER_POOL <span class="keyword">DEFAULT</span> <span class="comment">-- 指定该表空间使用默认的缓冲池</span></span><br><span class="line">)</span><br><span class="line">PARALLEL <span class="number">1</span> <span class="comment">-- 表示对这个表空间中数据的并行处理程度，最多可以启用 1 个并行执行服务器来协助处理任务</span></span><br><span class="line">NOCACHE <span class="comment">-- 指定了该表空间中的数据块在被读取到内存（缓冲池）后，不会被缓存起来用于后续的重复访问</span></span><br><span class="line">DISABLE <span class="type">ROW</span> MOVEMENT <span class="comment">-- 禁止行移动功能</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>场景：表中某个字段可能有重复值出现，对于重复出现的记录，根据创建时间只选取首次出现的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME, P_ID</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> t.<span class="operator">*</span>,</span><br><span class="line">            <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> P_ID <span class="keyword">ORDER</span> <span class="keyword">BY</span> CRT_TIME) <span class="keyword">AS</span> row_num</span><br><span class="line">    <span class="keyword">FROM</span> [schema_name].[table_name] t</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> row_num <span class="operator">=</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<h2 id="PL-SQL语句"><a href="#PL-SQL语句" class="headerlink" title="PL&#x2F;SQL语句"></a>PL&#x2F;SQL语句</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>PL&#x2F;SQL（Procedural Language&#x2F;Structured Query Language）是Oracle数据库系统的过程化编程语言。它是一种块结构语言，将 SQL语句的强大数据处理能力与过程化编程语言的流程控制结构相结合。这使得开发人员可以在数据库内部编写复杂的业务逻辑，而不仅仅是执行简单的查询操作。由于PL&#x2F;SQL程序是在数据库服务器内部执行，减少了数据在客户端和服务器之间的传输，从而提高了性能。特别是对于复杂的数据库操作和大量的数据处理，这种优势更加明显。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h4 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h4><p>PL&#x2F;SQL程序由块（Block）组成，每个块都有一个声明部分、执行部分和可选的异常处理部分。声明部分用于定义变量、常量、游标等；执行部分包含了要执行的SQL语句和PL&#x2F;SQL语句，用于实现具体的业务逻辑；异常处理部分用于处理程序执行过程中可能出现的错误。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    <span class="comment">-- 声明部分，定义变量</span></span><br><span class="line">    v_count NUMBER;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 执行部分，查询并赋值</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> v_count <span class="keyword">FROM</span> employees;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;员工总数为：&#x27;</span> <span class="operator">||</span> v_count);</span><br><span class="line">EXCEPTION</span><br><span class="line">    <span class="comment">-- 异常处理部分，处理可能的错误</span></span><br><span class="line">    <span class="keyword">WHEN</span> NO_DATA_FOUND <span class="keyword">THEN</span></span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;未找到数据。&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>



<h4 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h4><p>条件语句包括IF - THEN - ELSE语句用于根据条件执行不同的代码块。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF <span class="keyword">condition</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="comment">-- 条件为真时执行的语句</span></span><br><span class="line">ELSIF another_condition <span class="keyword">THEN</span></span><br><span class="line">    <span class="comment">-- 另一个条件为真时执行的语句</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="comment">-- 所有条件为假时执行的语句</span></span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure>

<p>循环语句有LOOP、WHILE - LOOP和FOR - LOOP等多种循环结构。例如，使用FOR - LOOP来遍历一个查询结果集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name) LOOP</span><br><span class="line">    <span class="comment">-- 对每一行数据进行操作</span></span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br></pre></td></tr></table></figure>

<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程：是一组预编译的PL&#x2F;SQL语句，存储在数据库中，可以被调用以执行特定的任务。存储过程可以接受参数，并且可以包含复杂的业务逻辑和数据库操作。例如，使用存储过程向employees表中插入一条新员工记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> insert_employee(</span><br><span class="line">    p_name VARCHAR2,</span><br><span class="line">    p_salary NUMBER</span><br><span class="line">) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, salary) <span class="keyword">VALUES</span> (p_name, p_salary);</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>存储过程可以结合块结构和控制结构，实现批量插入随机数据，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 批量插入随机数据(存储过程)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> batch_insert_users(</span><br><span class="line">    total <span class="keyword">IN</span> NUMBER <span class="keyword">DEFAULT</span> <span class="number">2</span></span><br><span class="line">) <span class="keyword">AS</span></span><br><span class="line">    <span class="comment">-- 定义变量</span></span><br><span class="line">    v_id ADMIN_USER.ID<span class="operator">%</span>TYPE;</span><br><span class="line">    v_name ADMIN_USER.NAME<span class="operator">%</span>TYPE;</span><br><span class="line">    v_gender ADMIN_USER.GENDER<span class="operator">%</span>TYPE;</span><br><span class="line">    v_pid ADMIN_USER.P_ID<span class="operator">%</span>TYPE;</span><br><span class="line">    v_orgcode ADMIN_USER.ORG_CODE<span class="operator">%</span>TYPE;</span><br><span class="line"></span><br><span class="line">    gender NUMBER :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    v_counter NUMBER :<span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 循环计数器</span></span><br><span class="line">    v_max NUMBER :<span class="operator">=</span> total; <span class="comment">-- 最大插入条数</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- 循环插入数据</span></span><br><span class="line">    WHILE v_counter <span class="operator">&lt;=</span> v_max LOOP</span><br><span class="line">        v_id :<span class="operator">=</span> random_alphanum(<span class="number">6</span>); <span class="comment">-- 随机六位字符(包含大小写字母、数字)</span></span><br><span class="line">        v_name :<span class="operator">=</span> random_chinese_name(); <span class="comment">-- 随机两位或三位姓名</span></span><br><span class="line">        gender :<span class="operator">=</span> ROUND(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        v_pid :<span class="operator">=</span> simple_random_id_card(gender); <span class="comment">-- 随机身份证号</span></span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">	    <span class="keyword">CASE</span> </span><br><span class="line">	        <span class="keyword">WHEN</span> gender <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">&#x27;2&#x27;</span> </span><br><span class="line">	        <span class="keyword">ELSE</span> <span class="string">&#x27;1&#x27;</span> </span><br><span class="line">	    <span class="keyword">END</span> <span class="keyword">AS</span> res <span class="keyword">INTO</span> v_gender; <span class="comment">-- 随机性别(1男性2女性)</span></span><br><span class="line">        <span class="keyword">SELECT</span> ID <span class="keyword">INTO</span> v_orgcode  <span class="comment">-- 从现有组织代码中随机挑选一个</span></span><br><span class="line">		<span class="keyword">FROM</span> (</span><br><span class="line">		    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">		    <span class="keyword">FROM</span> ADMIN_ORG</span><br><span class="line">		    <span class="keyword">ORDER</span> <span class="keyword">BY</span> DBMS_RANDOM.VALUE <span class="comment">-- 对查询结果进行随机排序</span></span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">WHERE</span> ROWNUM <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 插入数据到表中</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> ADMIN_USER </span><br><span class="line">		(ID, NAME, P_ID, ORG_CODE, GENDER) </span><br><span class="line">		<span class="keyword">VALUES</span>(v_id, v_name, v_pid, v_orgcode, v_gender);</span><br><span class="line"></span><br><span class="line">        v_counter :<span class="operator">=</span> v_counter <span class="operator">+</span> <span class="number">1</span>; <span class="comment">-- 更新计数器</span></span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;成功插入&#x27;</span> <span class="operator">||</span> v_max <span class="operator">||</span> <span class="string">&#x27;条数据&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;                                   </span><br></pre></td></tr></table></figure>

<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数与存储过程类似，但函数必须返回一个值。函数可以用于计算并返回一个结果，这个结果可以在SQL语句中使用。例如，使用存储函数计算员工的年薪</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> calculate_annual_salary(</span><br><span class="line">    p_salary NUMBER</span><br><span class="line">) <span class="keyword">RETURN</span> NUMBER <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> p_salary <span class="operator">*</span> <span class="number">12</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>存储函数中可以使用条件语句。例如，生成随机两位或三位姓名、随机身份证号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 常见姓氏数组</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> get_random_surname <span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    TYPE surname_array <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">10</span>);</span><br><span class="line">    v_surnames surname_array :<span class="operator">=</span> surname_array(</span><br><span class="line">        <span class="string">&#x27;王&#x27;</span>, <span class="string">&#x27;李&#x27;</span>, <span class="string">&#x27;张&#x27;</span>, <span class="string">&#x27;刘&#x27;</span>, <span class="string">&#x27;陈&#x27;</span>, <span class="string">&#x27;杨&#x27;</span>, <span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;黄&#x27;</span>, <span class="string">&#x27;周&#x27;</span>, <span class="string">&#x27;吴&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;徐&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;胡&#x27;</span>, <span class="string">&#x27;朱&#x27;</span>, <span class="string">&#x27;高&#x27;</span>, <span class="string">&#x27;林&#x27;</span>, <span class="string">&#x27;何&#x27;</span>, <span class="string">&#x27;郭&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;罗&#x27;</span></span><br><span class="line">    );</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> v_surnames(TRUNC(DBMS_RANDOM.VALUE(<span class="number">1</span>, v_surnames.COUNT <span class="operator">+</span> <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 随机名字生成</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> random_chinese_name <span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    v_name VARCHAR2(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    v_name :<span class="operator">=</span> get_random_surname;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 60%概率单字名，40%双字名</span></span><br><span class="line">    IF DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">1</span>) <span class="operator">&lt;</span> <span class="number">0.6</span> <span class="keyword">THEN</span></span><br><span class="line">        v_name :<span class="operator">=</span> v_name <span class="operator">||</span> UNISTR(<span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> LPAD(TO_CHAR(<span class="number">19968</span> <span class="operator">+</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">500</span>)), <span class="string">&#x27;FMXXXX&#x27;</span>), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        v_name :<span class="operator">=</span> v_name <span class="operator">||</span> </span><br><span class="line">                 UNISTR(<span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> LPAD(TO_CHAR(<span class="number">19968</span> <span class="operator">+</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">500</span>)), <span class="string">&#x27;FMXXXX&#x27;</span>), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>)) <span class="operator">||</span></span><br><span class="line">                 UNISTR(<span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> LPAD(TO_CHAR(<span class="number">19968</span> <span class="operator">+</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">500</span>)), <span class="string">&#x27;FMXXXX&#x27;</span>), <span class="number">4</span>, <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">RETURN</span> v_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成随机身份证号</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> simple_random_id_card(gender NUMBER <span class="keyword">DEFAULT</span> <span class="number">0</span>) <span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    v_id_card VARCHAR2(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 1. 前6位行政区划代码（随机）</span></span><br><span class="line">    v_id_card :<span class="operator">=</span> LPAD(TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">999999</span>)), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 2. 中间8位出生日期（1980-2000年间）</span></span><br><span class="line">    v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> </span><br><span class="line">                TO_CHAR(TO_DATE(<span class="string">&#x27;1980-01-01&#x27;</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="operator">+</span> </span><br><span class="line">                TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">365</span><span class="operator">*</span><span class="number">20</span>)), <span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 3. 顺序号3位（最后一位奇数男，偶数女）</span></span><br><span class="line">    v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> LPAD(TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">99</span>)), <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>) <span class="operator">||</span> TRUNC(gender);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 4. 随机校验码（1位数字或X）</span></span><br><span class="line">    IF DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">1</span>) <span class="operator">&lt;</span> <span class="number">0.9</span> <span class="keyword">THEN</span></span><br><span class="line">        v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        v_id_card :<span class="operator">=</span> v_id_card <span class="operator">||</span> <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">RETURN</span> v_id_card;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>


<p>存储函数中也可以使用循环语句。例如，获取随机6位包含大小写字母、数字的字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> random_alphanum(p_length NUMBER <span class="keyword">DEFAULT</span> <span class="number">6</span>) </span><br><span class="line"><span class="keyword">RETURN</span> VARCHAR2 <span class="keyword">IS</span></span><br><span class="line">    v_chars VARCHAR2(<span class="number">62</span>) :<span class="operator">=</span> <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;</span><br><span class="line">    v_result VARCHAR2(<span class="number">4000</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    v_result :<span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.p_length LOOP</span><br><span class="line">        v_result :<span class="operator">=</span> v_result <span class="operator">||</span> SUBSTR(v_chars, </span><br><span class="line">                             <span class="built_in">MOD</span>(<span class="built_in">ABS</span>(DBMS_RANDOM.RANDOM), <span class="number">62</span>) <span class="operator">+</span> <span class="number">1</span>, </span><br><span class="line">                             <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line">    <span class="keyword">RETURN</span> v_result;</span><br><span class="line"><span class="keyword">END</span> random_alphanum;</span><br></pre></td></tr></table></figure>

<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><h3 id="SQL-Plus"><a href="#SQL-Plus" class="headerlink" title="SQL*Plus"></a>SQL*Plus</h3><p>SQL*Plus是Oracle数据库提供的一个命令行界面的工具，用于与Oracle数据库进行交互。它允许用户输入和执行SQL语句、PL&#x2F;SQL块以及执行各种数据库管理和操作任务。比如查询数据、创建表、修改数据库对象结构等。</p>
<h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>方式一：使用Easy Connection Identifier连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlplus system/root1234@&quot;localhost:1521/FREEPDB1&quot;</span><br></pre></td></tr></table></figure>

<p>方式二：使用Full Connection Identifier连接。首先需要编辑tnsnames.ora文件(以23 ai个人免费版为例，对应目录为<code>C:\app\your-username\product\23ai\dbhomeFree\network\admin</code>)，添加以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FREEPDB1 = </span><br><span class="line"> (DESCRIPTION=</span><br><span class="line">   (ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521))</span><br><span class="line">   (CONNECT_DATA=</span><br><span class="line">      (SERVICE_NAME=FREEPDB1)</span><br><span class="line">    )</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlplus system/root1234@FREEPDB1</span><br></pre></td></tr></table></figure>

<p>.NET项目配置文件中数据库连接字符串如下，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;OracleConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User Id=system;Password=your-password;Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=FREEPDB1)));&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>方式三：使用Oracle提供的外部认证方式，以操作系统管理员身份登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlplus / as sysdba</span><br></pre></td></tr></table></figure>

<h3 id="SQLcl"><a href="#SQLcl" class="headerlink" title="SQLcl"></a>SQLcl</h3><p>SQLcl是Oracle推出的一款现代化的命令行工具，它是基于Java开发的，在功能上可以看作是SQL*Plus的增强版，提供了更加简洁易用、功能丰富的交互界面，并且融入了很多新的特性来提升开发和管理数据库的效率。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>SQLcl需要Java 11及以上版本的JDK，Oracle在使用过JDK后就会将JDK的配置写到配置文件中，若是Oracle的环境变量配置在JDK的变量前时将会被Oracle的配置信息加载覆盖掉。若遇到Java版本切换不生效的问题，可将PATH路径中的<code>C:\Program Files\Common Files\Oracle\Java\javapath</code>置于JDK变量之后。</p>
<p>SQL*Plus和SQLcl可执行文件一般位于<code>%ORACLE_HOME%/bin</code>目录下，以23 ai个人免费版为例，对应目录为<code>C:\app\your-username\product\23ai\dbhomeFree\bin</code>。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/index.html" >Oracle数据库官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/index.html" >Oracle数据库SQL语法参考(23ai)<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/sql-developer-command-line/24.1/sqcug/working-sqlcl.html" >Oracle数据库命令行工具SQLcl使用参考<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.oracle.com/en/database/oracle/oracle-database/23/comsc/installing-sample-schemas.html" >Oracle数据库创建示例模式(23ai)<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://docs.oracle.com/en/error-help/db/" >Oracle数据库SQL报错帮助<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>基于PGSQL咨询锁函数实现的分布式锁</title>
    <url>/Hexo-Blog/2024/08/30/pgsql-distributed-lock/</url>
    <content><![CDATA[<p>基于PGSQL咨询锁函数实现的一个分布式锁基础设施。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostgreSQL提供了分布式锁服务，可以用于多个数据库实例(会话)之间协调访问资源。通过使用pg_advisory_lock等咨询锁函数，可以实现一个由应用定义其含义的分布式锁基础设施。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>锁的一种宏观分类方式是悲观锁和乐观锁。乐观锁和悲观锁是并发控制的一种机制，用于多线程或多进程环境下对共享资源的访问管理，以防止数据不一致或竞态条件。悲观锁与乐观锁并不是特指某个锁，而是在并发情况下的两种不同策略。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁是一种对资源持有较悲观态度的锁定方式。它假设数据在并发访问时极有可能发生冲突，因此每次访问数据时都会先加锁，以确保其他线程不能访问此数据直到锁被释放。</p>
<p>悲观锁常见的实现方式是数据库中的行级锁、表级锁或行级锁等。一旦线程获得锁，其它尝试获取锁的线程都会被阻塞，直到锁被释放。</p>
<ul>
<li>适用场景：在高并发、数据竞争激烈的场景中使用，如金融交易、库存管理等。</li>
<li>缺点：<ul>
<li>可能导致系统吞吐量降低，因为锁定机制会阻止其他线程并发访问资源</li>
<li>容易产生死锁，如果锁的持有和释放管理不当，会导致系统无法继续运行</li>
</ul>
</li>
</ul>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁则持相对乐观的态度，假设并发操作冲突的可能性较小，因此不会主动加锁，而是进行数据版本检查来决定是否提交操作。</p>
<p>乐观锁一般通过版本号或时间戳等机制来实现。在数据读取时，获取当前版本号；在数据更新时，检查版本号是否与之前读取时的一致。如果一致，表示没有其他并发操作修改过数据，可以提交；否则，操作失败回滚。 </p>
<ul>
<li>适用场景：适用于读操作多、写操作少的场景，如一些阅读类应用、CMS系统等。因为这些场景下，冲突发生的概率较低，乐观锁可以提高系统的并发性。</li>
<li>缺点：<ul>
<li>在并发冲突频繁的场景下，可能会导致大量重试操作，影响性能</li>
<li>需要开发人员显式管理版本控制机制，增加开发复杂度</li>
</ul>
</li>
</ul>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>比较并替换(Compare-and-Swap)是乐观锁实现的基础。CAS操作包括三个步骤：读取内存值、比较内存值与预期值、如果相等则更新内存值。CAS锁可以有效地解决传统锁机制中的性能问题和死锁问题，是并发编程中常用的同步手段之一。</p>
<h3 id="线程锁、进程锁与分布式锁"><a href="#线程锁、进程锁与分布式锁" class="headerlink" title="线程锁、进程锁与分布式锁"></a>线程锁、进程锁与分布式锁</h3><h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>线程锁也被称为互斥锁(Mutex)，主要用于控制同一进程中的多个线程对共享资源的访问。</p>
<p>在C#中，可以使用lock关键字来实现互斥锁。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object lockObject = <span class="keyword">new</span> Object();</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 在需要保护共享资源的代码块中使用lock</span></span><br><span class="line">    <span class="keyword">lock</span> (lockObject)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 访问和修改共享资源的代码</span></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h4><p>进程锁是用于控制同一台机器上的多个进程对共享资源的访问。进程锁可以是系统级的，如文件锁；也可以是用户级的，如信号量。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式锁是用于控制分布式系统中的多个节点对共享资源的访问。由于分布式系统中的节点可能位于不同的物理机甚至不同的地理位置，因此分布式锁的实现比线程锁和进程锁要复杂得多。分布式锁需要在网络中的多个节点之间进行协调，以保证锁的唯一性和一致性。</p>
<h3 id="PGSQL咨询锁"><a href="#PGSQL咨询锁" class="headerlink" title="PGSQL咨询锁"></a>PGSQL咨询锁</h3><p>PostgreSQL提供了一种由应用定义其含义的锁，这种锁被称为咨询锁(Advisory Lock)。咨询锁是一种悲观锁、分布式锁。咨询锁用一个long类型的数值或两个int类型的数值标识一把锁，long类型标识的锁和int类型标识的锁互相独立。</p>
<p>咨询锁有两个锁定级别：会话级和事务级。</p>
<ul>
<li>会话级锁定会持续到显式释放或会话结束，不受会话中事务的影响</li>
<li>事务级锁定不能显式释放，会持续锁定到事务结束</li>
</ul>
<p>不论哪个级别的锁定都是可重入的，即同一个线程在持有锁的情况下，可以多次获取该锁而不会造成死锁。</p>
<p>咨询锁有两种锁定模式：独占和共享。</p>
<ul>
<li>独占锁定和其它的独占锁定或共享锁定都互斥</li>
<li>共享锁定只和独占锁定互斥, 共享锁定之间不互斥</li>
</ul>
<p>锁定模式不受锁定级别影响，同一把锁的会话级独占锁定和事务级独占锁定会正确的互斥。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>PGSQL一共提供了21个咨询锁函数，抛开标识类型不谈，lock和unlock分别代表获取锁定和释放锁定。以_shared结尾的代表锁定是共享的而非独占的，带_xact_关键字代表锁定级别是事务级而非会话级的，带_try_关键字代表锁定是不可等待的。</p>
<h5 id="定义锁定模式"><a href="#定义锁定模式" class="headerlink" title="定义锁定模式"></a>定义锁定模式</h5><p>定义一个枚举作为区分锁定模式的参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 锁定模式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> LockMode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 独占</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Exclusive = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 共享</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Shared = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义咨询锁接口"><a href="#定义咨询锁接口" class="headerlink" title="定义咨询锁接口"></a>定义咨询锁接口</h5><p>会话级锁继承IDisposable接口，以便数据库连接等资源的释放。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISessionLock</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义不同标识类型、不同会话级别下的咨询锁接口。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAdvisoryLock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对long类型的数值标识的锁进行会话级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对由两个int类型的数值标识的锁进行会话级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对long类型的数值标识的锁进行事务级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对由两个int类型的数值标识的锁进行事务级别的锁定</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现会话级锁的显示释放"><a href="#实现会话级锁的显示释放" class="headerlink" title="实现会话级锁的显示释放"></a>实现会话级锁的显示释放</h5><p>由于会话级锁定会持续到显式释放或会话结束，需要实现显示释放。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PGSQLSessionLock</span> : <span class="title">ISessionLock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> DatabaseFacade database;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">long</span>? kid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>? mid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>? nid;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isShare;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLSessionLock</span>(<span class="params">DatabaseFacade database, <span class="built_in">long</span> kid, <span class="built_in">bool</span> isShare</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">        <span class="keyword">this</span>.kid = kid;</span><br><span class="line">        <span class="keyword">this</span>.isShare = isShare;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLSessionLock</span>(<span class="params">DatabaseFacade database, <span class="built_in">int</span> mid, <span class="built_in">int</span> nid, <span class="built_in">bool</span> isShare</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">        <span class="keyword">this</span>.mid = mid;</span><br><span class="line">        <span class="keyword">this</span>.nid = nid;</span><br><span class="line">        <span class="keyword">this</span>.isShare = isShare;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReleaseLock</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShare)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kid != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock_shared(&#123;0&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; kid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock_shared(&#123;0&#125;,&#123;1&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; mid.Value, nid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kid != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock(&#123;0&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; kid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                database.ExecuteSqlRaw(<span class="string">&quot;select pg_advisory_unlock(&#123;0&#125;,&#123;1&#125;)&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; mid.Value, nid.Value &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReleaseLock();</span><br><span class="line">            database = <span class="literal">null</span>;</span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~PGSQLSessionLock()</span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现咨询锁"><a href="#实现咨询锁" class="headerlink" title="实现咨询锁"></a>实现咨询锁</h5><p>实现不同锁定标识、不同锁定级别下的咨询锁函数，每个咨询锁函数定义了锁定标识、锁定模式、是否可等待参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PGSQLAdvisoryLock</span> : <span class="title">IAdvisoryLock</span>, <span class="title">ISingletonDependency</span></span><br><span class="line">&#123;</span><br><span class="line">    IDbContextProvider&lt;ABPDemoDbContext&gt; _dbContextProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PGSQLAdvisoryLock</span>(<span class="params">IDbContextProvider&lt;ABPDemoDbContext&gt; dbContextProvider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _dbContextProvider = dbContextProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> locked = <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; k &#125;, lockMode, waiting, <span class="literal">false</span>, database, cancellationToken);</span><br><span class="line"></span><br><span class="line">        ISessionLock result = locked ? <span class="keyword">new</span> PGSQLSessionLock(database, k, lockMode == LockMode.Shared) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ISessionLock&gt; <span class="title">LockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> locked = <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; m, n &#125;, lockMode, waiting, <span class="literal">false</span>, database, cancellationToken);</span><br><span class="line"></span><br><span class="line">        ISessionLock result = locked ? <span class="keyword">new</span> PGSQLSessionLock(database, m, n, lockMode == LockMode.Shared) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">long</span> k, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; k &#125;, lockMode, waiting, <span class="literal">true</span>, database, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">XactLockAsync</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n, LockMode lockMode, <span class="built_in">bool</span> waiting, CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> database = (<span class="keyword">await</span> _dbContextProvider.GetDbContextAsync()).Database;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> InternalLockAsync(<span class="keyword">new</span> <span class="built_in">object</span>[] &#123; m, n &#125;, lockMode, waiting, <span class="literal">true</span>, database, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">InternalLockAsync</span>(<span class="params"><span class="built_in">object</span>[] parameters, LockMode lockMode, <span class="built_in">bool</span> waiting, <span class="built_in">bool</span> isXact, DatabaseFacade database, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> locked;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> xact = isXact ? <span class="string">&quot;_xact&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> param = parameters.Length == <span class="number">1</span> ? <span class="string">&quot;&#123;0&#125;&quot;</span> : <span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mode = lockMode <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            LockMode.Exclusive =&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">            LockMode.Shared =&gt; <span class="string">&quot;_shared&quot;</span>,</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">$&quot;LockMode.<span class="subst">&#123;lockMode&#125;</span> is not implemented.&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waiting)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> database.ExecuteSqlRawAsync(<span class="string">$&quot;select pg_advisory<span class="subst">&#123;xact&#125;</span>_lock<span class="subst">&#123;mode&#125;</span>(<span class="subst">&#123;param&#125;</span>)&quot;</span>, parameters);</span><br><span class="line"></span><br><span class="line">            locked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            locked = (<span class="keyword">await</span> database.SqlQueryRaw&lt;<span class="built_in">bool</span>&gt;(<span class="string">$&quot;select pg_try_advisory<span class="subst">&#123;xact&#125;</span>_lock<span class="subst">&#123;mode&#125;</span>(<span class="subst">&#123;param&#125;</span>)&quot;</span>, parameters).ToListAsync()).Single();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h4><h5 id="在应用中定义和使用"><a href="#在应用中定义和使用" class="headerlink" title="在应用中定义和使用"></a>在应用中定义和使用</h5><p>首先定义一个锁枚举，具体名称由应用的功能派生，比如定义一个更新学生信息的锁StudentUpdate。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Locks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">long</span> StudentUpdate = <span class="number">10001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后置于并发操作上下文(替换操作之前)即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> IAdvisoryLock _advisoryLock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentAppService</span>(<span class="params">..., IAdvisoryLock advisoryLock</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    _advisoryLock = advisoryLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">await</span> _studentRepository.GetAsync(x =&gt; x.Name == input.Name, <span class="literal">false</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> _advisoryLock.LockAsync(Locks.StudentUpdate, LockMode.Exclusive, <span class="literal">true</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line">student.Name = input.Name;</span><br><span class="line">student.StudentLevel = input.StudentLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> _studentRepository.UpdateAsync(student, <span class="literal">false</span>, cancellationToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ObjectMapper.Map&lt;Student,StudentDto&gt;(student);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="验证锁是否生效"><a href="#验证锁是否生效" class="headerlink" title="验证锁是否生效"></a>验证锁是否生效</h5><p>在LockAsync之后打上断点，调用API命中断点之后，使用SQL语句查看锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_locks t1</span><br><span class="line"><span class="keyword">JOIN</span>  pg_stat_activity t2</span><br><span class="line"><span class="keyword">ON</span> t1.pid  <span class="operator">=</span> t2.pid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.pid;</span><br></pre></td></tr></table></figure>

<img   src="/Hexo-Blog/2024/08/30/pgsql-distributed-lock/pgsql_pg_lock.png"  class="" title="命中断点后数据库锁的情况">

<p>使用SQL语句再次获取该锁定标识对应的锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_advisory_lock(<span class="number">10001</span>);</span><br></pre></td></tr></table></figure>

<img   src="/Hexo-Blog/2024/08/30/pgsql-distributed-lock/pgsql_pg_lock_waiting.png"  class="" title="获取该锁定标识对应的锁">

<p>可以看到该锁定标识对应的资源已被阻塞，将等待直到该资源变成可用。点击继续跳过断点之后即可再次成功获取。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a class="link"   href="http://www.postgres.cn/docs/12/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS" >PGSQL中文文档-咨询锁函数<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>PostgreSQL</tag>
        <tag>Concurrency Control</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL常用SQL语句</title>
    <url>/Hexo-Blog/2024/08/12/pgsql-usage/</url>
    <content><![CDATA[<p>PostgreSQL数据库中的一些常用SQL。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PostgreSQL相较于MySQL而言，具有更强的事务处理能力，能够处理更复杂的数据操作和高并发访问。同时其提供了更丰富的索引类型，能够进行更细粒度的查询和优化。此外还支持多种数据类型和函数库，可以处理更复杂的应用程序。</p>
<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>.NET项目配置文件中数据库连接字符串如下，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;PgsqlConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Host=localhost;Database=your-database;Username=postgres;Password=your-password;Persist Security Info=True;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>备注：PGSQL默认监听的端口号为5432，因此连接字符串可以不指定端口号</p>
<h2 id="PGSQL常用语句"><a href="#PGSQL常用语句" class="headerlink" title="PGSQL常用语句"></a>PGSQL常用语句</h2><h3 id="扩展安装"><a href="#扩展安装" class="headerlink" title="扩展安装"></a>扩展安装</h3><p>安装uuid生成函数扩展</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;uuid-ossp&quot;;</span><br></pre></td></tr></table></figure>


<p>注: []标注的内容必须带双引号””</p>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>获取uuid</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> uuid_generate_v4();</span><br></pre></td></tr></table></figure>

<p>获取东八时(北京时间)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> now() <span class="keyword">AT</span> <span class="type">TIME</span> ZONE (<span class="string">&#x27;CCT&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>类型转换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--写法一</span></span><br><span class="line"><span class="keyword">SELECT</span> t.&quot;Id&quot;::<span class="type">varchar</span>;</span><br><span class="line"><span class="comment">--写法二</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">cast</span>(t.&quot;Id&quot; <span class="keyword">AS</span> <span class="type">varchar</span>);</span><br></pre></td></tr></table></figure>


<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.[table_name] </span><br><span class="line">([column_name], ...) </span><br><span class="line"><span class="keyword">VALUES</span>(column_value, ...);</span><br></pre></td></tr></table></figure>

<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> public.[table_name]  </span><br><span class="line"><span class="keyword">SET</span> [column_name]  <span class="operator">=</span> column_value</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<h4 id="FOR-UPDATE-行级锁"><a href="#FOR-UPDATE-行级锁" class="headerlink" title="FOR UPDATE(行级锁)"></a>FOR UPDATE(行级锁)</h4><p>更新表时跳过被锁定的行</p>
<p>注: <code>[column_a_id]</code>代表外键列，依赖于表a</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> public.[table_b]    </span><br><span class="line"><span class="keyword">SET</span> [column_3]  <span class="operator">=</span> column_value</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line">        	<span class="keyword">SELECT</span> b.<span class="operator">*</span>, a.[column_1]</span><br><span class="line">        	<span class="keyword">FROM</span> [table_b] b</span><br><span class="line">        	<span class="keyword">JOIN</span> [table_a] a <span class="keyword">ON</span> b.[column_a_id] <span class="operator">=</span> a.&quot;Id&quot;</span><br><span class="line">        	<span class="keyword">WHERE</span> ...</span><br><span class="line">        	<span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> </span><br><span class="line">        	(</span><br><span class="line">        		<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        		<span class="keyword">FROM</span> [table_b] b2</span><br><span class="line">        		<span class="keyword">WHERE</span> b2.[column_a_id] <span class="operator">=</span> b.[column_a_id] </span><br><span class="line">                <span class="keyword">AND</span> b2.[column_3] <span class="operator">=</span> column_value</span><br><span class="line">        	) </span><br><span class="line">        	<span class="keyword">ORDER</span> <span class="keyword">BY</span> a.[column_2]</span><br><span class="line">        	LIMIT <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> b <span class="keyword">SKIP</span> LOCKED</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">where</span>  t.&quot;Id&quot; <span class="operator">=</span> b.&quot;Id&quot;  </span><br><span class="line">returning t.[column_1]</span><br></pre></td></tr></table></figure>

<h3 id="TRUNCATE-DROP-DELETE"><a href="#TRUNCATE-DROP-DELETE" class="headerlink" title="TRUNCATE&#x2F;DROP&#x2F;DELETE"></a>TRUNCATE&#x2F;DROP&#x2F;DELETE</h3><p>TRUNCATE常用于清理数据，可重置自增键，不破坏表结构，但无法回滚也无法携带WHERE语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [table_name] CASCADE</span><br></pre></td></tr></table></figure>

<p>DROP会删除表结构及其依赖的索引、外键约束，无法回滚</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [table_name]</span><br></pre></td></tr></table></figure>

<p>DELETE可以携带WHERE语句，可以回滚，但不会重置自增键也不会释放表或索引占用的空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [table_name]</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<h3 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h3><p>更新表字段排序规则</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [table_name]  <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> [column_name] </span><br><span class="line"><span class="keyword">SET</span> DATA TYPE CHARACHTER VARING(<span class="number">50</span>) <span class="keyword">COLLATE</span> &quot;zh-x-icu&quot;</span><br></pre></td></tr></table></figure>


<h3 id="LEFT-JOIN-视图"><a href="#LEFT-JOIN-视图" class="headerlink" title="LEFT JOIN(视图)"></a>LEFT JOIN(视图)</h3><p>注: <code>[column_a_id]</code>代表外键列，依赖于表a；<code>[column_c_id]</code>代表外键列，依赖于表c</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> public.[view_name] </span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> </span><br><span class="line">	a.[column_name],</span><br><span class="line">    ...</span><br><span class="line">    c.[column_name],</span><br><span class="line">    ...</span><br><span class="line">    t.[column_name],</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">FROM</span> [table_a] a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( </span><br><span class="line">    		<span class="keyword">SELECT</span> </span><br><span class="line">    		b.[column_name],</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">FROM</span> [table_b] b</span><br><span class="line">		  ) t </span><br><span class="line"><span class="keyword">ON</span> a.&quot;Id&quot; <span class="operator">=</span> t.[column_a_id]</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [table_c] c</span><br><span class="line"><span class="keyword">ON</span> a.[column_c_id] <span class="operator">=</span> c.&quot;Id&quot;</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>c#中LINQ写法，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> l <span class="keyword">in</span> leftSet</span><br><span class="line"><span class="keyword">join</span> r <span class="keyword">in</span> rightSet <span class="keyword">on</span> l.Id <span class="keyword">equals</span> r.Id <span class="keyword">into</span> groupJoin</span><br><span class="line"><span class="keyword">from</span> r <span class="keyword">in</span> groupJoin.DefaultIfEmpty() </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">new</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数与存储过程"><a href="#函数与存储过程" class="headerlink" title="函数与存储过程"></a>函数与存储过程</h3><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>生成uuid</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> public.uuid_generate_v4()</span><br><span class="line"><span class="keyword">RETURNS</span> uuid <span class="keyword">LANGUAGE</span> c</span><br><span class="line">PARALLEL SAFE STRICT</span><br><span class="line"><span class="keyword">AS</span> <span class="string">&#x27;$libdir/uuid-ossp&#x27;</span>, </span><br><span class="line">$<span class="keyword">function</span>$uuid_generate_v4$<span class="keyword">function</span>$;</span><br></pre></td></tr></table></figure>


<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> public.[procedure_name](<span class="keyword">IN</span> column_1_variable column_1_type) <span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span> $<span class="keyword">procedure</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line">	<span class="keyword">UPDATE</span> [table_a]  a</span><br><span class="line">	<span class="keyword">SET</span> [column_2] <span class="operator">=</span> column_value,</span><br><span class="line">	<span class="keyword">WHERE</span> a.[column_1] <span class="operator">=</span> column_variable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">$<span class="keyword">procedure</span>$;</span><br></pre></td></tr></table></figure>

<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>创建自增序列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SEQUENCE task_id_seq</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span></span><br><span class="line">INCREMENT <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">NO</span> MINVALUE</span><br><span class="line"><span class="keyword">NO</span> MAXVALUE</span><br><span class="line">CACHE <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<h3 id="窗口函数和聚合函数"><a href="#窗口函数和聚合函数" class="headerlink" title="窗口函数和聚合函数"></a>窗口函数和聚合函数</h3><p>在PostgreSQL中，窗口函数（Window Functions）是对一组行进行计算的函数，比如求和、平均、排名等。它们可以用于创建复杂的分析查询，并且可以对一系列的行而不仅仅是组内的行进行操作。</p>
<p>聚合函数（Aggregate Functions）则是用于合并多个值，返回单一的值的函数，如COUNT、SUM、AVG、MIN、MAX等。</p>
<p>例如，分组计算平均值，窗口函数可以带出额外信息<code>[column_1]</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [column_1],</span><br><span class="line">    [column_2],</span><br><span class="line">    <span class="built_in">AVG</span>([column_2]) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> [column_3]) <span class="keyword">AS</span> avg_value</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    [table_a]    </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    [column_2] <span class="operator">&gt;</span> avg_value;</span><br></pre></td></tr></table></figure>

<p>而聚合函数只能操作组内成员</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [column_3]</span><br><span class="line">    <span class="built_in">AVG</span>([column_2]) <span class="keyword">AS</span> avg_value</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    [table_a]   </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    [column_3]</span><br></pre></td></tr></table></figure>

<p>组合用法，计算组内排名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    [column_1],</span><br><span class="line">    [column_2],</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> [column_3] <span class="keyword">ORDER</span> <span class="keyword">BY</span> [column_2] <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    [table_a] </span><br></pre></td></tr></table></figure>

<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>PGSQL数据库事务的隔离级别有以下四种:</p>
<ul>
<li>读未提交(READ UNCOMMITTED)</li>
<li>读已提交(READ COMMITTED)</li>
<li>重复读(REPEATABLE READ)</li>
<li>串行化(SERIALIZABLE)</li>
</ul>
<p>对于并发事务，我们不希望发生的行为如下：</p>
<ul>
<li>脏读：一个事务读取了另一个未提交的事务写入的数据</li>
<li>重复读：一个事务重新读取前面读取过的数据时，发现该数据已改变</li>
<li>幻读：当某个事务在读取某个范围内的记录时，另外一个事务中又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行</li>
</ul>
<p>对于不同事务隔离级别，脏读、重复读、幻读的可能性如下</p>
<table>
<thead>
<tr>
<th>ISOLATION LEVEL</th>
<th>脏读</th>
<th>重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ABP中配置数据库事务隔离级别为读已提交</span></span><br><span class="line">...</span><br><span class="line">Configure&lt;AbpUnitOfWorkOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.IsolationLevel = IsolationLevel.ReadCommitted;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="进程与会话"><a href="#进程与会话" class="headerlink" title="进程与会话"></a>进程与会话</h3><p>查看进程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_locks t1</span><br><span class="line"><span class="keyword">JOIN</span>  pg_stat_activity t2</span><br><span class="line"><span class="keyword">ON</span> t1.pid  <span class="operator">=</span> t2.pid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.pid;</span><br></pre></td></tr></table></figure>

<p>关闭进程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(PID);</span><br></pre></td></tr></table></figure>

<p>查看会话</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_stat_activity <span class="keyword">WHERE</span> datname <span class="operator">=</span> <span class="string">&#x27;your_database&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>关闭当前会话</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DISCARD <span class="keyword">ALL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link"   href="https://www.postgresql.org/docs/" >PGSQL官方文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ核心概念及应用场景</title>
    <url>/Hexo-Blog/2024/08/17/rabbitmq-usage/</url>
    <content><![CDATA[<p>RabbitMQ基本概念、安装配置、使用场景、消息模型，以及消息持久化、签收机制、延迟队列的实现。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ是基于AMQP(Advanced Message Queue Protocol)协议实现的消息队列，是一种应用程序之间的通信方法，在分布式系统开发中应用广泛。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img   src="/Hexo-Blog/2024/08/17/rabbitmq-usage/rabbitmq_architecture.png"  class="" title="RabbitMQ工作原理">

<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>Broker是消息队列进程，包含Exchange、Queue两个部分。</p>
<h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><p>Exchange指消费队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过滤。</p>
<p>常用类型有direct、topic、fanout、headers四种。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue指消息队列，消息打达队列后转发给指定的消费方。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producer指消息生产者，生产者发布消息的过程如下：</p>
<ul>
<li><p>生产者和broker建立Connection，并开启一个channel</p>
</li>
<li><p>生产者声明一个交换机并设置相关属性(交换机类型、是否持久化)</p>
</li>
<li><p>生产者声明一个队列并设置相关属性(是否排他、是否持久化、是否自动删除)</p>
</li>
<li><p>生产者通过routing key将交换机和队列绑定</p>
</li>
<li><p>生产者通过channel发送给broker，由交换机根据接收到的routing key匹配队列</p>
</li>
<li><p>如果找到匹配的队列则存入，否则丢弃或回传</p>
</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer指消息消费者，消费者接受消息的过程如下：</p>
<ul>
<li><p>消费者和broker建立Connection，并开启一个channel</p>
</li>
<li><p>消费者监听指定的队列，根据需要设置回调函数</p>
</li>
<li><p>当有消息到达队列时broker将消息推送给消费者</p>
</li>
<li><p>消费者确认接受到消息</p>
</li>
<li><p>broker删除队列中已经确认的消息</p>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>RabbitMQ通常有如下应用场景：</p>
<ul>
<li>高并发场景消除峰值，让并发请求在MQ中排队</li>
<li>大数据处理，将数据放入MQ，多开几个消费者处理(如日志收集)</li>
<li>服务异步和解耦，使用MQ进行异步通信后，服务之间没有直接的调用关系，生产方通过MQ与消费方通信，将应用程序进行解耦</li>
<li>FIFO排序，保证数据按顺序消费</li>
</ul>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Windows系统中RabbitMQ可通过安装包下载(需要Erlang环境)，安装目录下启动图形化界面并重启服务</p>
<p><code>rabbitmq-plugins enable rabbitmq_management</code></p>
<p><code>rabbitmq-server stop</code></p>
<p><code>rabbitmq-server start</code></p>
<p>也可通过Dokcer下载镜像</p>
<p><code>docker pull rabbitmq:3-management</code></p>
<p>下载完成后启动容器(5672是程序连接的端口，15672是可视化界面接口)</p>
<p><code>docker run -id --name=rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management</code></p>
<h2 id="消息模型与交换机类型"><a href="#消息模型与交换机类型" class="headerlink" title="消息模型与交换机类型"></a>消息模型与交换机类型</h2><p>RabbitMQ包含以下5种消息模型</p>
<ul>
<li><p>Hello World简单模型，只需一个生产者、一个队列、一个消费者</p>
</li>
<li><p>Work Queue工作队列模型，多个消费者绑定到一个队列，共同消费队列中的消息，同一个消息只会被一个消费者消费。可使用prefetch防止某个消费者消费能力偏弱导致后续的消息阻塞</p>
</li>
<li><p>Publish&#x2F;Subscribe发布订阅模型(type&#x3D;fanout)，允许一个消息向多个消费者投递</p>
</li>
<li><p>Routing路由模型(type&#x3D;direct)，不同的消息可被不同的队列消费，通过一个routing key来收发消息</p>
</li>
<li><p>Topic通配符模型(type&#x3D;topic)，一种特殊的路由模式，在绑定队列时routing key可以使用通配符</p>
</li>
</ul>
<p>注: headers类型的路由不是用routing Key进行路由匹配，而是在匹配请求头中所带的键值进行路由</p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>MQ消息在内存中进行读写，如果MQ宕机那么消息就要丢失的风险，我们需要可以通过交换机持久化、队列持久化等来防止消息丢失。</p>
<h2 id="签收机制"><a href="#签收机制" class="headerlink" title="签收机制"></a>签收机制</h2><p>RabbitMQ包含手动签收和自动签收2钟模式。</p>
<p>自动签收指MQ把消息投递给消费者后，消息默认被签收，MQ就会直接把消息删除掉。这种模式可能会导致消息丢失分享。</p>
<p>手动签收指MQ不会自动签收消息，而是把消息推送给消费者后，等到消费者自己去签收消息后，再删除队列中的消息，这种模式可以防止消息丢失。</p>
<h2 id="延迟队列和死信消息"><a href="#延迟队列和死信消息" class="headerlink" title="延迟队列和死信消息"></a>延迟队列和死信消息</h2><p>RabbitMQ可以给队列设置过期时间，也可以单独给每个消息设置过期时间，如果到了过期时间消息没被消费该消息就会标记为死信消息。根据这一特点，我们可以准备一个队列来接收死信交换机中的死信消息，然后准备一个消费者来消费该队列中的消息，这就是延迟队列。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a class="link"   href="https://www.rabbitmq.com/docs" >RabbitMQ官方文档<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库常用CLI命令及应用场景</title>
    <url>/Hexo-Blog/2024/08/14/redis-usage/</url>
    <content><![CDATA[<p>Redis数据库的使用场景、使用方法、重要概念，一些常用的CLI命令，以及应用场景。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis(Remote Dictionary Server)是一个高性能的(key&#x2F;value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，常用于数据缓存、充当消息队列等。Redis不仅仅支持简单的key-value类型的数据(如string)，同时还提供list，set，sorted set，hash等数据结构的存储。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>Redis在Mac&#x2F;Linux系统下可通过命令行直接安装，而在Windows系统下需要通过WSL安装一个Linux系统来安装Redis，或者通过Docker下载Redis镜像通过镜像运行Redis，也可以使用传统EXE安装包安装(不推荐)。Redis可通过CLI、API、GUI(如RedisInsight)三种方式使用。</p>
<h3 id="通过EXE安装包启动"><a href="#通过EXE安装包启动" class="headerlink" title="通过EXE安装包启动"></a>通过EXE安装包启动</h3><p>启动Redis</p>
<p><code>redis-server</code></p>
<p>报错</p>
<blockquote>
<p>Could not create server TCP listening socket *:6379: bind: 在一个非套接字上尝试了一个操作 。</p>
</blockquote>
<p>Redis安装目录下，依次输入</p>
<p><code>redis-cli.exe</code></p>
<p><code>shutdown</code></p>
<p><code>exit</code></p>
<p><code>redis-server.exe redis.windows.conf</code></p>
<h3 id="通过Docker启动"><a href="#通过Docker启动" class="headerlink" title="通过Docker启动"></a>通过Docker启动</h3><p>拉取Redis官方镜像</p>
<p><code>docker pull redis</code></p>
<p>启动Redis，设置端口映射(主机:容器)，设置数据持久化挂载，并启用AOF持久化</p>
<p><code>docker run --name my-redis -p 6379:6379 -v /path/to/redis/data:/data -d redis redis-server --appendonly yes</code></p>
<p>使用自定义配置文件启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name my-redis \</span><br><span class="line">  -v /path/to/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line">  -v /path/to/data:/data \</span><br><span class="line">  -d redis \</span><br><span class="line">  redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：&#x2F;path&#x2F;to&#x2F;redis.conf为主机(HOST)上的Redis配置文件路径，&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf为容器内部的默认Redis配置文件路径。容器启动时会使用主机上的配置文件替代容器内的默认配置，对主机配置文件的修改会实时生效到容器内(无需重建容器)</p>
</blockquote>
<h2 id="CLI常用命令"><a href="#CLI常用命令" class="headerlink" title="CLI常用命令"></a>CLI常用命令</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h4><p>设置键值对</p>
<p><code>SET [key] [value]</code></p>
<p>获取键值</p>
<p><code>GET [key]</code></p>
<p>删除键值对</p>
<p><code>DELETE [key]</code></p>
<p>判断键值对是否存在</p>
<p><code>EXISTS [key]</code></p>
<p>获取所有键值对</p>
<p><code>KEYS *</code></p>
<p>获取所有以xx结尾的键值对</p>
<p><code>KEYS *xx</code></p>
<p>游标方式获取所有以xx:开头的前n个键值对(非阻塞查询)</p>
<p><code>SCAN 0 MATCH xx:* COUNT n</code></p>
<p>删除所有键值对</p>
<p><code>FLUSHALL</code></p>
<p>设置键值对过期时间</p>
<p><code>EXPIRE [key] [seconds]</code></p>
<p>获取键值对过期时间</p>
<p><code>TTL [key]</code></p>
<p>设置键值对并设置过期时间</p>
<p><code>SETEX [key] [seconds] [value]</code></p>
<p>设置不存在的键值对(若已存在则忽略执行)</p>
<p><code>SETNX [key] [value]</code></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>创建列表并添加元素</p>
<p><code>LPUSH [list] [value, ...]</code></p>
<p><code>RPUSH [list] [value, ...]</code></p>
<p>获取整个列表</p>
<p><code>LRANGE [list] 0 -1</code></p>
<p>删除列表元素</p>
<p><code>LPOP [list] [count]</code></p>
<p><code>RPOP [list] [count]</code></p>
<p>获取列表长度</p>
<p><code>LLEN [list]</code></p>
<p>仅保留索引为n到m的部分列表</p>
<p><code>LTRIME [list] n m</code></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>创建集合并添加元素</p>
<p><code>SADD [set] [value, ...]</code></p>
<p>获取集合中的元素</p>
<p><code>SMEMBERS [set]</code></p>
<p>判断元素是否在集合中</p>
<p><code>SISMEMBER [set] [value]</code></p>
<p>删除集合中的元素</p>
<p><code>SREM [set] [value]</code></p>
<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><p>创建有序集合并添加元素</p>
<p><code>ZADD [sortedset] [(score value), ...]</code></p>
<p>获取有序集合全部元素</p>
<p><code>ZRANGE [sortedset] 0 -1 WITHSCORES</code></p>
<p>获取有序集合某个元素权值</p>
<p><code>ZSCORE [sortedset] [value]</code></p>
<p>获取有序集合某个元素排名</p>
<p><code>ZRANK [sortedset] [value]</code></p>
<p><code>ZREVRANK [sortedset] [value]</code></p>
<p>删除有序集合某个元素</p>
<p><code>ZREM [sortedset] [value]</code></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>创建哈希集合</p>
<p><code>HSET [hash] [key] [value]</code></p>
<p>获取哈希集合中的元素</p>
<p><code>HGET [hash] [key]</code></p>
<p>获取哈希集合中的全部元素</p>
<p><code>HGETALL [hash]</code></p>
<p>删除哈希集合中的某个元素</p>
<p><code>HDEL [hash] [key]</code></p>
<p>判断哈希集合中的某个元素是否存在</p>
<p><code>HEXISTS [hash] [key]</code></p>
<p>获取哈希集合中的键</p>
<p><code>HKEYS [hash]</code></p>
<p>获取哈希集合长度</p>
<p><code>HLEN [hash]</code></p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>订阅频道</p>
<p><code>SUBSCRIBE [channel]</code></p>
<p>发布频道消息</p>
<p><code>PUBLISH [channel] [message]</code></p>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>向消息队列中添加一条消息</p>
<p><code>XADD [stream] * [key] [value]</code></p>
<p>获取消息队列中消息数量</p>
<p><code>XLEN [stream]</code></p>
<p>获取消息队列中的所有消息</p>
<p><code>XRANGE [stream] - +</code></p>
<p>删除消息队列中的某条消息</p>
<p><code>XDEL [stream] [id]</code></p>
<p>删除消息队列中的所有消息</p>
<p><code>XTRIM [stream] MAXLEN 0</code></p>
<p>读取消息队列中索引为i开始的n条消息，如不存在阻塞x秒</p>
<p><code>XRED COUNT n BLOCK x STREAMS [stream] i</code></p>
<p>创建消费者组</p>
<p><code>XGROUP CREATE [stream] [group] [id]</code></p>
<p>获取消费者组信息</p>
<p><code>XINFO GROUPS [stream]</code></p>
<p>向消费者组中添加消费者</p>
<p><code>XGROUP CREATECONSUMER [stream] [group] [consumer]</code></p>
<p>读取消费者组中某消费者的最新n条消息，如不存在阻塞x秒</p>
<p><code>XREDGROUP [group] [consumer] COUNT n BLOCK x STREAMS [stream] &gt;</code></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>注: Redis中的事务概念与传统事务概念不同，不保证原子性</p>
<p>标记一个事务开始</p>
<p><code>MULTI</code></p>
<p>提交事务</p>
<p><code>EXEC</code></p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis有RDB(Redis Database)和AOF(Append Only File)两种数据持久化方式。</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB相当于数据快照，可在redis.confg文件中配置自动触发，例如<u>save 60 10000</u>代表60s内如果有10000次修改则触发一次快照，也可通过CLI中的save命令手动触发。</p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF相当于使用日志记录操作命令，可在redis.confg文件中配置参数<u>appendonly yes</u>自动触发。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Redis主从复制是指将Redis主节点数据复制到从节点，数据的复制是单向的。</p>
<p>假设主节点端口号为6379，从节点端口号为6380。在从节点的redis.confg文件中配置参数<u>replicaof 127.0.0.1 6379</u>启用主从复制功能。启动从节点6380服务后，使用CLI命令</p>
<p><code>redis-cli -p 6380</code></p>
<p><code>info replication</code></p>
<p>即可看到当前节点角色已从master变为slave。</p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>Redis主从复制存在一个问题，如果主节点宕机了，需要手动去将从节点设置为主节点。为了实现主节点的自动故障转移，Redis引入了一个独立的进程来监视主节点，通过发布订阅模式通知从节点变更为主节点。</p>
<p>创建配置文件sentinel.conf并配置参数<u>sentinel monitor master 127.0.0.1 6379 1</u>(1代表故障转移需要同意的哨兵的个数)，使用CLI命令</p>
<p><code>redis-sentinel sentinel.conf</code></p>
<p>即可启动哨兵进程。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="Redis分布式缓存"><a href="#Redis分布式缓存" class="headerlink" title="Redis分布式缓存"></a>Redis分布式缓存</h3><p>Redis最常用的应用场景是数据缓存。Redis将高频访问数据从磁盘(数据库)移至内存，响应时间从毫秒级降至微秒级。1个Redis实例(16GB内存)可替代数百台数据库服务器的缓存负载。Redis作为独立缓存层，可以保护后端系统免受流量冲击。</p>
<p>ABP中集成了Redis分布式缓存，下面是一个使用示例。</p>
<p>Web层WebModule配置如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConfigureRedis</span>(<span class="params">ServiceConfigurationContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> configuration = context.Services.GetConfiguration();</span><br><span class="line"></span><br><span class="line">    Configure&lt;AbpDistributedCacheOptions&gt;(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.KeyPrefix = <span class="string">&quot;ABPDemo:&quot;</span>; <span class="comment">// 可选：设置缓存键前缀</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Redis分布式缓存</span></span><br><span class="line">    context.Services.AddStackExchangeRedisCache(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.Configuration = configuration[<span class="string">&quot;Redis:Configuration&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    context.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(_ =&gt; ConnectionMultiplexer.Connect(configuration[<span class="string">&quot;Redis:Configuration&quot;</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application层中使用示例如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StudentAppService</span> : <span class="title">ABPDemoAppService</span>, <span class="title">IStudentAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache&lt;StudentCacheItem&gt; _distributeCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentAppService</span>(<span class="params">..., IDistributedCache&lt;StudentCacheItem&gt; distributedCache</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _distributeCache = distributedCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Authorize(Roles = ABPDemoRoles.Admin)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;StudentCacheItem&gt; <span class="title">GetStudentFromCacheAsync</span>(<span class="params">Guid id, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="string">$&quot;Student:<span class="subst">&#123;id&#125;</span>&quot;</span>; <span class="comment">// 缓存Key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> _distributeCache.GetOrAddAsync(</span><br><span class="line">            key, </span><br><span class="line">            <span class="keyword">async</span> () =&gt;  <span class="comment">// 如果缓存不存在，从数据库加载</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> student = <span class="keyword">await</span> _studentRepository.GetAsync(id, <span class="literal">false</span>, cancellationToken);</span><br><span class="line">                <span class="keyword">var</span> studentCacheItem = ObjectMapper.Map&lt;Student, StudentCacheItem&gt; (student);</span><br><span class="line">                <span class="keyword">return</span> studentCacheItem;</span><br><span class="line">            &#125;,</span><br><span class="line">            () =&gt; <span class="keyword">new</span> DistributedCacheEntryOptions</span><br><span class="line">            &#123;</span><br><span class="line">                AbsoluteExpiration = DateTimeOffset.Now.AddHours(<span class="number">1</span>) <span class="comment">// 1小时后过期</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="literal">null</span>, <span class="literal">false</span>, cancellationToken</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些场景需要手动清除Redis缓存，为此引入RedisCacheManager，开发环境中Redis缓存清除可以使用<code>KEYS</code>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedisCacheManager</span> :  <span class="title">ITransientDependency</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IConnectionMultiplexer _redis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCacheManager</span>(<span class="params">IConnectionMultiplexer redis</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _redis = redis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ClearByPrefixAsync</span>(<span class="params"><span class="built_in">string</span> keyPrefix</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> db = _redis.GetDatabase();</span><br><span class="line">        <span class="keyword">var</span> server = _redis.GetServer(_redis.GetEndPoints().First());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> keys = <span class="keyword">new</span> List&lt;RedisKey&gt;();</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> key <span class="keyword">in</span> server.KeysAsync(pattern: <span class="string">$&quot;<span class="subst">&#123;keyPrefix&#125;</span>*&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">           keys.Add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        批量删除</span><br><span class="line">        <span class="keyword">if</span> (keys.Count != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">await</span> db.KeyDeleteAsync(keys.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KEYS是Redis的一个命令，用于模式匹配查询键(如<code>KEYS user:*</code>)，但会阻塞整个Redis服务直到扫描完成，在生产环境中推荐使用<code>SCAN</code>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedisCacheManager</span> :  <span class="title">ITransientDependency</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IConnectionMultiplexer _redis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCacheManager</span>(<span class="params">IConnectionMultiplexer redis</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _redis = redis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ClearByPrefixAsync</span>(<span class="params"><span class="built_in">string</span> keyPrefix</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> db = _redis.GetDatabase();</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 使用 SCAN 迭代查询（避免 KEYS 阻塞）</span></span><br><span class="line">        <span class="keyword">var</span> script = <span class="string">@&quot;</span></span><br><span class="line"><span class="string">                        local keys = redis.call(&#x27;SCAN&#x27;, 0, &#x27;MATCH&#x27;, ARGV[1], &#x27;COUNT&#x27;, 1000)</span></span><br><span class="line"><span class="string">                        for i, key in ipairs(keys[2]) do</span></span><br><span class="line"><span class="string">                            redis.call(&#x27;DEL&#x27;, key)</span></span><br><span class="line"><span class="string">                        end</span></span><br><span class="line"><span class="string">                        return keys[1]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归扫描直到返回的游标为 0</span></span><br><span class="line">            <span class="built_in">long</span> cursor;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = (RedisResult[])<span class="keyword">await</span> db.ScriptEvaluateAsync(script, values: <span class="keyword">new</span> RedisValue[] &#123; <span class="string">$&quot;<span class="subst">&#123;keyPrefix&#125;</span>*&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">                cursor = (<span class="built_in">long</span>)result[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">while</span> (cursor != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><p>Redis可以作为分布式锁，替代基于数据库的锁方案。Redis拥有内存级操作和单命令原子性。Redis基于内存的原子操作(如<code>SETNX</code>)，获取&#x2F;释放锁的延迟通常在毫秒级，远优于基于数据库的锁方案。Redis的<code>SET key value NX PX 30000</code>可原子性实现「加锁+过期时间设置」，避免多命令竞态条件。</p>
<p>ABP中同样集成了Redis分布式锁，下面是一个使用示例。</p>
<p>Web层WebModule配置如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConfigureRedis</span>(<span class="params">ServiceConfigurationContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> configuration = context.Services.GetConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Redis分布式锁</span></span><br><span class="line">    context.Services.AddSingleton&lt;IDistributedLockProvider&gt;(sp =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> connection = ConnectionMultiplexer.Connect(configuration[<span class="string">&quot;Redis:Configuration&quot;</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisDistributedSynchronizationProvider(connection.GetDatabase());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application层中使用示例如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StudentAppService</span> : <span class="title">ABPDemoAppService</span>, <span class="title">IStudentAppService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IAbpDistributedLock _abpDistributedLock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentAppService</span>(<span class="params">..., IAbpDistributedLock abpDistributedLock</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _abpDistributedLock = abpDistributedLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Authorize(Roles = ABPDemoRoles.Admin)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UpdateStudentLevelWithLockAsync</span>(<span class="params">Guid id, StudentLevelType level, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义锁的名称</span></span><br><span class="line">        <span class="keyword">var</span> lockName = <span class="string">$&quot;Student:<span class="subst">&#123;id&#125;</span>:UpdateLock&quot;</span>;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">using</span> <span class="keyword">var</span> handle = <span class="keyword">await</span> _abpDistributedLock.TryAcquireAsync(lockName, TimeSpan.Zero, cancellationToken);</span><br><span class="line">        <span class="keyword">if</span> (handle != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 临界区代码</span></span><br><span class="line">            <span class="keyword">var</span> student = <span class="keyword">await</span> _studentRepository.GetAsync(id, <span class="literal">false</span>, cancellationToken);</span><br><span class="line">            student.StudentLevel = level;</span><br><span class="line">            <span class="keyword">await</span> _studentRepository.UpdateAsync(student, <span class="literal">true</span>, cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a class="link"   href="https://redis.io/docs/latest/commands/" >Redis CLI命令官方文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>ABP</tag>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET实现断点续传(上传/下载)</title>
    <url>/Hexo-Blog/2025/03/25/resumable-upload-and-download/</url>
    <content><![CDATA[<p>基于.NET实现大文件的断点续传功能，包含上传与下载。其中上传部分包括分片上传与断点续传功能，并借助WinForm实现上传进度反馈、并行上传、分片大小动态调整等辅助功能。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>断点续传基于分片上传和分片下载，包含断点续传上传与断点续传下载两部分，下面基于.NET分别对其进行功能实现。</p>
<h2 id="断点续传上传"><a href="#断点续传上传" class="headerlink" title="断点续传上传"></a>断点续传上传</h2><p>在文件上传场景中，分片上传和断点续传是处理大文件上传的重要技术。</p>
<p>除了基本的断点续传功能，大文件上传还应提供以下辅助功能：</p>
<ul>
<li>分片大小调整：根据网络状况动态调整分片大小</li>
<li>并行上传：可以并行上传多个分片以提高速度</li>
<li>完整性校验：合并文件后校验哈希值确保文件完整</li>
<li>清理机制：定期清理未完成上传的临时分片</li>
<li>进度反馈：提供上传进度信息给用户</li>
</ul>
<p>下面我们来简单实现上述功能。</p>
<h3 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h3><p>分片上传流程如下：</p>
<ul>
<li>客户端首次上传前生成文件唯一ID(通常使用文件内容哈希，此处为了演示重新上传是从0开始的，使用的是Guid)</li>
<li>客户端将文件分割为固定大小的块，每块单独上传到服务器</li>
<li>服务器接收并临时保存每个分片</li>
<li>当所有分片上传完成后，服务器合并分片为完整文件</li>
</ul>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>UploadChunk接口实现了分片的临时存储(存储的临时文件名为fileId_chunkNumber)，以及分片的最终合并。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">AllowAnonymous</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> form = <span class="keyword">await</span> Request.ReadFormAsync(cancellationToken);</span><br><span class="line">    <span class="keyword">var</span> fileId = form[<span class="string">&quot;fileId&quot;</span>].ToString();</span><br><span class="line">    <span class="keyword">var</span> chunkNumber = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkNumber&quot;</span>].ToString());</span><br><span class="line">    <span class="keyword">var</span> totalChunks = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;totalChunks&quot;</span>].ToString());</span><br><span class="line">    <span class="keyword">var</span> fileName = form[<span class="string">&quot;fileName&quot;</span>].ToString();</span><br><span class="line">    <span class="keyword">var</span> chunk = form.Files[<span class="string">&quot;chunk&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保上传目录存在</span></span><br><span class="line">    Directory.CreateDirectory(_uploadPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时保存分片</span></span><br><span class="line">    <span class="keyword">var</span> chunkPath = Path.Combine(_uploadPath, <span class="string">$&quot;<span class="subst">&#123;fileId&#125;</span>_<span class="subst">&#123;chunkNumber&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> FileStream(chunkPath, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> chunk.CopyToAsync(stream, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是最后一个分片，合并文件</span></span><br><span class="line">    <span class="keyword">if</span> (chunkNumber == totalChunks - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> MergeChunksAsync(fileId, totalChunks, fileName, cancellationToken);</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Message = <span class="string">&quot;Upload complete&quot;</span>, FileName = fileName &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Message = <span class="string">&quot;Chunk uploaded&quot;</span>, ChunkNumber = chunkNumber &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">MergeChunksAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> finalPath = Path.Combine(_uploadPath, fileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> finalStream = <span class="keyword">new</span> FileStream(finalPath, FileMode.Create))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; totalChunks; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> chunkPath = Path.Combine(_uploadPath, <span class="string">$&quot;<span class="subst">&#123;fileId&#125;</span>_<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> chunkStream = System.IO.File.OpenRead(chunkPath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> chunkStream.CopyToAsync(finalStream, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            System.IO.File.Delete(chunkPath); <span class="comment">// 合并后删除分片</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ChunkedUploadService类，用来处理本地的文件流，并调用服务端的分片上传接口。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChunkedUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> UploadChunkApiUri = <span class="string">&quot;/api/Upload/UploadChunk&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChunkedUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serviceUri = serviceUri;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadInChunksAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">        <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">        <span class="keyword">var</span> fileId = Guid.NewGuid().ToString(); <span class="comment">// 唯一文件标识</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">            <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead]; <span class="comment">// 只取实际读取的字节</span></span><br><span class="line">            Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkNumber, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, <span class="built_in">byte</span>[] chunkData, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(fileId), <span class="string">&quot;fileId&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(chunkNumber.ToString()), <span class="string">&quot;chunkNumber&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(totalChunks.ToString()), <span class="string">&quot;totalChunks&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> StringContent(fileName), <span class="string">&quot;fileName&quot;</span> &#125;,</span><br><span class="line">            &#123; <span class="keyword">new</span> ByteArrayContent(chunkData), <span class="string">&quot;chunk&quot;</span>, <span class="string">&quot;chunk.dat&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;UploadChunkApiUri&#125;</span>&quot;</span>, content, cancellationToken);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在客户端的UI线程中使用异步方式调用ChunkedUploadService类中的分片上传方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> filePath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;srcDir&#125;</span>\\<span class="subst">&#123;srcFile&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> uploader = <span class="keyword">new</span> ChunkedUploadService(serviceUri);</span><br><span class="line"><span class="keyword">await</span> uploader.UploadInChunksAsync(filePath, CancellationToken.None);</span><br></pre></td></tr></table></figure>

<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传流程如下：</p>
<ul>
<li>客户端首次上传前生成文件唯一ID</li>
<li>上传前根据文件文件唯一ID查询服务器已接收的分片，继续上传时只上传缺失的分片</li>
<li>当所有分片上传完成后合并分片</li>
</ul>
<h4 id="服务端实现-1"><a href="#服务端实现-1" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>GetUploadStatus接口根据文件标识fileId查询已上传的分片编号，UploadChunk接口的功能同上。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadController</span>: <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWebHostEnvironment _env;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uploadPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadController</span>(<span class="params">IWebHostEnvironment env</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _env = env;</span><br><span class="line">        _uploadPath = Path.Combine(_env.WebRootPath, <span class="string">&quot;uploads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetUploadStatus</span>(<span class="params"><span class="built_in">string</span> fileId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uploadedChunks = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Directory.Exists(_uploadPath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> chunkFiles = Directory.GetFiles(_uploadPath, <span class="string">$&quot;<span class="subst">&#123;fileId&#125;</span>_*&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> chunkFile <span class="keyword">in</span> chunkFiles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">int</span>.TryParse(Path.GetFileName(chunkFile).Split(<span class="string">&#x27;_&#x27;</span>).Last(), <span class="keyword">out</span> <span class="keyword">var</span> chunkNumber))</span><br><span class="line">                &#123;</span><br><span class="line">                    uploadedChunks.Add(chunkNumber);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(uploadedChunks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同分片上传</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">MergeChunksAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同分片上传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端实现-1"><a href="#客户端实现-1" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ResumableUploadService类，调用服务端的文件分片上传状态接口，对于已上传的分片跳过处理，然后调用服务端的分片上传接口继续上传，以实现断点续传功能。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> UploadChunkApiUri = <span class="string">&quot;/api/Upload/UploadChunk&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> GetUploadStatusApiUri = <span class="string">&quot;/api/Upload/GetUploadStatus&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResumableUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serviceUri = serviceUri;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadWithResumeAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">        <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">        <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">        <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uploadedChunks.Contains(chunkNumber))  <span class="keyword">continue</span>; <span class="comment">// 跳过已上传的分片</span></span><br><span class="line"></span><br><span class="line">            fileStream.Seek(chunkNumber * ChunkSize, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">            <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead];</span><br><span class="line">            Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileHash</span>(<span class="params">Stream stream, HashAlgorithmType hashAlgorithmType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hashAlgorithmType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Md5:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = MD5.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Sha256:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = SHA256.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">async</span> Task&lt;List&lt;<span class="built_in">int</span>&gt;&gt; GetUploadedChunksAsync(<span class="built_in">string</span> fileId, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.GetAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;GetUploadStatusApiUri&#125;</span>?fileId=<span class="subst">&#123;fileId&#125;</span>&quot;</span>);</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> json = <span class="keyword">await</span> response.Content.ReadAsStringAsync(cancellationToken);</span><br><span class="line">            <span class="keyword">return</span> JsonSerializer.Deserialize&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(json);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkNumber, <span class="built_in">int</span> totalChunks, <span class="built_in">string</span> fileName, <span class="built_in">byte</span>[] chunkData, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 同分片上传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在客户端的UI线程中使用异步方式调用ResumableUploadService类中的断点续传方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> filePath = <span class="string">$&quot;<span class="subst">&#123;disk&#125;</span>:\\<span class="subst">&#123;srcDir&#125;</span>\\<span class="subst">&#123;srcFile&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> uploader = <span class="keyword">new</span> ResumableUploadService(serviceUri);</span><br><span class="line"><span class="keyword">await</span> uploader.UploadWithResumeAsync(filePath, CancellationToken.None);</span><br></pre></td></tr></table></figure>

<h3 id="上传进度反馈与上传取消"><a href="#上传进度反馈与上传取消" class="headerlink" title="上传进度反馈与上传取消"></a>上传进度反馈与上传取消</h3><p>通常情况下，大文件上传时需要给用户提供上传进度信息以及取消上传的功能，下面使用WinForm简单实现上述功能。</p>
<h4 id="服务端实现-2"><a href="#服务端实现-2" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>服务端代码延用<a href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a>，不再展示。</p>
<h4 id="客户端实现-2"><a href="#客户端实现-2" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端的ResumableUploadService中的主要变化是添加了三个委托事件，分别用来更新上传百分比、状态消息、上传与取消按钮禁用状态。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; ProgressChanged; <span class="comment">// 上传百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; StatusChanged; <span class="comment">// 状态消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">bool</span>&gt; UploadCompleted; <span class="comment">// 完成状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadWithResumeAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">            <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++)</span><br><span class="line">            &#123;</span><br><span class="line">                cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (uploadedChunks.Contains(chunkNumber))</span><br><span class="line">                &#123;</span><br><span class="line">                    ProgressChanged?.Invoke((<span class="built_in">int</span>)((<span class="built_in">double</span>)chunkNumber / totalChunks * <span class="number">100</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fileStream.Seek(chunkNumber * ChunkSize, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">                <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead];</span><br><span class="line">                Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;正在上传分片 <span class="subst">&#123;chunkNumber + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;totalChunks&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)(chunkNumber + <span class="number">1</span>) / totalChunks * <span class="number">100</span>);</span><br><span class="line">                ProgressChanged?.Invoke(progress);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主窗体MainForm中分别绑定三个委托事件到相应的UI线程上，使用Invoke跨线程更新UI，实现上传过程中实时更新上传进度及状态信息。</p>
<p>Control.InvokeRequired属性指示调用方在对控件进行方法调用时是否必须调用Invoke方法，因为调用方位于创建控件所在的线程以外的线程中。Windows窗体中的控件绑定到特定线程，并且不是线程安全的。因此，如果要从其他线程调用控件的方法，则必须使用控件的调用方法之一来封送对正确线程的调用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ResumableUploadService _uploader;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cts;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _uploader = <span class="keyword">new</span> ResumableUploadService(_serviceUri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _uploader.ProgressChanged += UpdateProgress;</span><br><span class="line">        _uploader.StatusChanged += UpdateStatus;</span><br><span class="line">        _uploader.UploadCompleted += UploadCompleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateProgress</span>(<span class="params"><span class="built_in">int</span> percent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (progressBar.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">int</span>&gt;(UpdateProgress), percent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        progressBar.Value = percent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateStatus</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lblStatus.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            lblStatus.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">string</span>&gt;(UpdateStatus), message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lblStatus.Text = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UploadCompleted</span>(<span class="params"><span class="built_in">bool</span> success</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (btnUpload.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            btnUpload.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">bool</span>&gt;(UploadCompleted), success);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        btnUpload.Enabled = <span class="literal">true</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">btnUpload_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(textBox.Text) || !File.Exists(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;请选择有效的文件&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnUpload.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">true</span>;</span><br><span class="line">        progressBar.Value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        <span class="keyword">await</span> _uploader.UploadWithResumeAsync(textBox.Text,_cts.Token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnBrowse_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> openFileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">        <span class="keyword">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            textBox.Text = openFileDialog.FileName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFormClosing</span>(<span class="params">FormClosingEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">        <span class="keyword">base</span>.OnFormClosing(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行上传"><a href="#并行上传" class="headerlink" title="并行上传"></a>并行上传</h3><p>并行上传是提升大文件传输效率的有效手段，并行上传可将总时间缩短为单线程上传时间&#x2F;N(N为并行度)。并行上传适合在不稳定的网络环境(如高延迟)中使用，可充分利用间歇性网络带宽。</p>
<p>并行上传时多个分片同时上报上传进度，进度条呈现更平滑，更适合需要实时进度反馈的场景。</p>
<h4 id="服务端实现-3"><a href="#服务端实现-3" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>服务端代码延用<a href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">断点续传</a>，不再展示。</p>
<h4 id="客户端实现-3"><a href="#客户端实现-3" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端基于ResumableUploadService，创建了一个并行上传服务类ParallelUploadService，使用<code>Parallel.ForEachAsync</code>实现并行上传，并设置了最大并行度(默认为4)。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParallelUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri, <span class="built_in">int</span> maxParallelism = <span class="number">4</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ParallelUploadFileAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">var</span> totalChunks = (<span class="built_in">int</span>)Math.Ceiling((<span class="built_in">double</span>)fileInfo.Length / ChunkSize);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">            <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> chunksToUpload = Enumerable.Range(<span class="number">0</span>, totalChunks).Where(chunk =&gt; !uploadedChunks.Contains(chunk)).ToList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> progressLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">            <span class="keyword">var</span> uploadedCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> totalToUpload = chunksToUpload.Count;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;准备上传 <span class="subst">&#123;totalToUpload&#125;</span> 个分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> parallelOptions = <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cancellationToken</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> Parallel.ForEachAsync(chunksToUpload, parallelOptions, <span class="keyword">async</span> (chunkNumber, cancellationToken) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                fileStream.Seek(chunkNumber * ChunkSize, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[ChunkSize];</span><br><span class="line">                <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, ChunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> actualChunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesRead];</span><br><span class="line">                Array.Copy(chunkData, actualChunkData, bytesRead);</span><br><span class="line"></span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;正在上传分片 <span class="subst">&#123;chunkNumber + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;totalChunks&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> UploadChunkAsync(fileId, chunkNumber, totalChunks, fileInfo.Name, actualChunkData, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用锁保证进度更新的原子性</span></span><br><span class="line">                <span class="keyword">lock</span> (progressLock)</span><br><span class="line">                &#123;</span><br><span class="line">                    uploadedCount++;</span><br><span class="line">                    <span class="keyword">var</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)uploadedCount / totalToUpload * <span class="number">100</span>);</span><br><span class="line">                    ProgressChanged?.Invoke(progress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主窗体MainForm中对于ParallelUploadService服务类的调用方式与ResumableUploadService类似，不再展示。</p>
<h3 id="动态调整分片大小"><a href="#动态调整分片大小" class="headerlink" title="动态调整分片大小"></a>动态调整分片大小</h3><p>根据网络状态动态调整分片大小，可以优化分片上传效率。</p>
<h4 id="服务端实现-4"><a href="#服务端实现-4" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>由于分片的大小是动态计算得出的，存储的临时文件名由fileId_chunkNumber变更为{fileId}&#x2F;chunk_{offsetValue}。</p>
<p>服务端的分片存储结构如下：</p>
<blockquote>
<p>uploads&#x2F;<br>├── {fileId}&#x2F;          &#x2F;&#x2F; 每个文件一个独立目录<br>│   ├── chunk_{offsetValue1}        &#x2F;&#x2F; 分片文件按偏移量命名<br>│   ├── chunk_{offsetValue2}<br>│   └── …<br>└── completed&#x2F;       &#x2F;&#x2F; 最终合并的文件</p>
</blockquote>
<p>由于上传是并行的，服务端在检查分片上传完整性时，必须以所有分片大小总和等于文件大小为标志，而不能以其中某一分片的偏移量+分片大小等于文件大小为标志。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadController</span>: <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWebHostEnvironment _env;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uploadPath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;UploadController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadController</span>(<span class="params">IWebHostEnvironment env, ILogger&lt;UploadController&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _env = env;</span><br><span class="line">        _uploadPath = Path.Combine(_env.WebRootPath, <span class="string">&quot;uploads&quot;</span>);</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Ping</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(DateTime.UtcNow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetUploadStatus</span>(<span class="params"><span class="built_in">string</span> fileId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uploadDir = Path.Combine(_uploadPath, fileId);</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(uploadDir))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; UploadedChunks = Array.Empty&lt;UploadedChunk&gt;() &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> chunks = Directory.GetFiles(uploadDir, <span class="string">&quot;chunk_*&quot;</span>)</span><br><span class="line">            .Select(f =&gt; <span class="keyword">new</span> FileInfo(f))</span><br><span class="line">            .Select(f =&gt; <span class="keyword">new</span> UploadedChunk</span><br><span class="line">            &#123;</span><br><span class="line">                Offset = <span class="built_in">long</span>.Parse(f.Name.Split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">1</span>]),</span><br><span class="line">                Size = (<span class="built_in">int</span>)f.Length</span><br><span class="line">            &#125;)</span><br><span class="line">            .OrderBy(c =&gt; c.Offset)</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; UploadedChunks = chunks &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> form = <span class="keyword">await</span> Request.ReadFormAsync(cancellationToken);</span><br><span class="line">        <span class="keyword">var</span> fileId = form[<span class="string">&quot;fileId&quot;</span>].ToString();</span><br><span class="line">        <span class="keyword">var</span> chunkIndex = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkIndex&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> chunkOffset = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkOffset&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> chunkSize = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;chunkSize&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> fileSize = <span class="built_in">int</span>.Parse(form[<span class="string">&quot;fileSize&quot;</span>].ToString());</span><br><span class="line">        <span class="keyword">var</span> fileName = form[<span class="string">&quot;fileName&quot;</span>].ToString();</span><br><span class="line">        <span class="keyword">var</span> chunk = form.Files[<span class="string">&quot;chunk&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 验证分片</span></span><br><span class="line">            <span class="keyword">if</span> (chunk == <span class="literal">null</span> || chunk.Length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;无效的分片数据&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建上传目录</span></span><br><span class="line">            <span class="keyword">var</span> uploadDir = Path.Combine(_uploadPath, fileId);</span><br><span class="line">            Directory.CreateDirectory(uploadDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存分片</span></span><br><span class="line">            <span class="keyword">var</span> chunkPath = Path.Combine(uploadDir, <span class="string">$&quot;chunk_<span class="subst">&#123;chunkOffset&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> FileStream(chunkPath, FileMode.Create))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> chunk.CopyToAsync(stream, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _logger.LogInformation(<span class="string">$&quot;已接收分片 <span class="subst">&#123;chunkIndex&#125;</span> (偏移: <span class="subst">&#123;chunkOffset&#125;</span>, 大小: <span class="subst">&#123;chunk.Length&#125;</span>, 剩余大小: <span class="subst">&#123;fileSize - chunkOffset&#125;</span>)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否完成</span></span><br><span class="line">            <span class="keyword">if</span> (IsUploadComplete(fileId, fileSize))</span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogInformation(<span class="string">$&quot;文件 <span class="subst">&#123;fileName&#125;</span> 所有分片已上传&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Completed = <span class="literal">true</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="keyword">new</span> &#123; Completed = <span class="literal">false</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(OperationCanceledException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 客户端主动取消上传，最后一个分片可能未完整上传，需要进行删除，否则客户端断点续传时，在对分片信息的更新过程中会发生错误</span></span><br><span class="line">            System.IO.File.Delete(Path.Combine(Path.Combine(_uploadPath, fileId), <span class="string">$&quot;chunk_<span class="subst">&#123;chunkOffset&#125;</span>&quot;</span>));</span><br><span class="line">            <span class="keyword">var</span> errorMsg = <span class="string">$&quot;分片上传失败:<span class="subst">&#123;ex.Message&#125;</span>, 分片 chunk_<span class="subst">&#123;chunkOffset&#125;</span> 已删除！&quot;</span>;</span><br><span class="line">            _logger.LogError(errorMsg);</span><br><span class="line">            <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> errorMsg = <span class="string">$&quot;分片上传失败:<span class="subst">&#123;ex.Message&#125;</span>&quot;</span>;</span><br><span class="line">            _logger.LogError(errorMsg);</span><br><span class="line">            <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">MergeChunksAsync</span>(<span class="params">MergeFile mergeFile, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> uploadDir = Path.Combine(_uploadPath, mergeFile.FileId);</span><br><span class="line">        <span class="keyword">var</span> finalDir = Path.Combine(_uploadPath, <span class="string">&quot;completed&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> finalPath = Path.Combine(finalDir, mergeFile.FileName);</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(finalDir))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(finalDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有分片并按偏移量排序</span></span><br><span class="line">        <span class="keyword">var</span> chunkFiles = Directory.GetFiles(uploadDir, <span class="string">&quot;chunk_*&quot;</span>)</span><br><span class="line">            .Select(f =&gt; <span class="keyword">new</span></span><br><span class="line">            &#123;</span><br><span class="line">                Path = f,</span><br><span class="line">                Offset = <span class="built_in">long</span>.Parse(Path.GetFileName(f).Split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">            &#125;)</span><br><span class="line">            .OrderBy(x =&gt; x.Offset)</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并文件</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> finalStream = <span class="keyword">new</span> FileStream(finalPath, FileMode.Create))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> chunk <span class="keyword">in</span> chunkFiles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> chunkStream = System.IO.File.OpenRead(chunk.Path))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> chunkStream.CopyToAsync(finalStream, cancellationToken);</span><br><span class="line">                &#125;</span><br><span class="line">                System.IO.File.Delete(chunk.Path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理临时目录</span></span><br><span class="line">        Directory.Delete(uploadDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> stream = System.IO.File.OpenRead(finalPath);</span><br><span class="line">        <span class="keyword">var</span> mergeFileId = GetFileHash(stream, HashAlgorithmType.Sha256);</span><br><span class="line">        <span class="keyword">if</span> (!mergeFile.FileId.Equals(mergeFileId))</span><br><span class="line">        &#123;</span><br><span class="line">            stream.Close();</span><br><span class="line">            System.IO.File.Delete(finalPath);</span><br><span class="line">            <span class="keyword">var</span> errorMsg = <span class="string">$&quot;合并后的文件内容哈希不正确，文件可能已损坏，合并前内容哈希为<span class="subst">&#123;mergeFile.FileId&#125;</span>, 合并后内容哈希为<span class="subst">&#123;mergeFileId&#125;</span>, 合并后的文件已被删除，请重新上传！&quot;</span>;</span><br><span class="line">            _logger.LogError(errorMsg);</span><br><span class="line">            <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _logger.LogInformation(<span class="string">$&quot;文件合并完成: <span class="subst">&#123;finalPath&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> private methods</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileHash</span>(<span class="params">Stream stream, HashAlgorithmType hashAlgorithmType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hashAlgorithmType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Md5:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = MD5.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Sha256:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = SHA256.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsUploadComplete</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">long</span> fileSize</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> status = GetUploadStatus(fileId) <span class="keyword">as</span> OkObjectResult;</span><br><span class="line">        <span class="keyword">var</span> data = status?.Value <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">        <span class="keyword">var</span> chunks = data?.UploadedChunks <span class="keyword">as</span> IEnumerable&lt;UploadedChunk&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (chunks == <span class="literal">null</span> || !chunks.Any())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件总大小(最后一个分片的结束位置)</span></span><br><span class="line">        <span class="comment">// 请勿使用chunks.Max(c =&gt; c.Offset + c.Size), 该值在单线程环境中可以代表所有分片都已上传完毕, 但在多线程环境中是错误的</span></span><br><span class="line">        <span class="built_in">long</span> currentTotalSize = chunks.Sum(c =&gt; c.Size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否覆盖了所有字节</span></span><br><span class="line">        <span class="keyword">return</span> currentTotalSize &gt;= fileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> public class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadedChunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Offset &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MergeFile</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FileId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> FileName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用服务端上传时的日志记录如下，可以看到分片的上传是乱序的：</p>
<img   src="/Hexo-Blog/2025/03/25/resumable-upload-and-download/adaptive_resumable_upload_console.png"  class="" title="服务端日志记录输出">

<h4 id="客户端实现-4"><a href="#客户端实现-4" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>客户端实现了AdaptiveResumableUploadService服务类，在并行上传与断点续传的基础上，添加了实时更新网络指标(上行速度&#x2F;网络延迟)并动态计算当前分片大小的功能，并使用了异步锁SemaphoreSlim确保分片信息更新时的原子性。</p>
<p>注：请勿使用同步锁lock，否则会报错<code>Object synchronization method was called from an unsynchronized block of code</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdaptiveResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> UploadChunkApiUri = <span class="string">&quot;/api/Upload/UploadChunk&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> GetUploadStatusApiUri = <span class="string">&quot;/api/Upload/GetUploadStatus&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> MergeChunksApiUri = <span class="string">&quot;/api/Upload/MergeChunks&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PingApiUri = <span class="string">&quot;/api/Ping&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _minChunkSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxChunkSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _initialChunkSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络状况监测</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _averageUploadSpeedMbps = <span class="number">1.0</span>; <span class="comment">// 初始假设1Mbps</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _averageLatencyMs = <span class="number">100</span>; <span class="comment">// 初始延迟100ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _networkLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; ProgressChanged; <span class="comment">// 上传百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; StatusChanged; <span class="comment">// 状态消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">bool</span>&gt; UploadCompleted; <span class="comment">// 完成状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveResumableUploadService</span>(<span class="params"><span class="built_in">string</span> serviceUri, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> maxParallelism =  <span class="number">4</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> minChunkSize = <span class="number">256</span> * <span class="number">1024</span>,    // <span class="number">256</span>KB</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> maxChunkSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>, // <span class="number">10</span>MB</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">int</span> initialChunkSize = <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span></span>) <span class="comment">// 1MB</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        _serviceUri = serviceUri;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        _httpClient.Timeout = Timeout.InfiniteTimeSpan;</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">        _minChunkSize = minChunkSize;</span><br><span class="line">        _maxChunkSize = maxChunkSize;</span><br><span class="line">        _initialChunkSize = initialChunkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主上传方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadFileAdaptiveAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">            <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备上传任务</span></span><br><span class="line">            <span class="keyword">var</span> currentChunkSize = _initialChunkSize;</span><br><span class="line">            <span class="keyword">var</span> fileSize = fileInfo.Length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> progressLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">            <span class="built_in">long</span> totalUploaded = uploadedChunks.Values.Sum();</span><br><span class="line">            <span class="built_in">long</span> totalToUpload = fileSize - totalUploaded;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;需要上传 <span class="subst">&#123;totalToUpload&#125;</span> 字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> parallelOptions = <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cancellationToken</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> Parallel.ForEachAsync(GenerateChunks(fileSize, currentChunkSize, uploadedChunks), parallelOptions, <span class="keyword">async</span> (chunk, cancellationToken) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">bool</span> success = <span class="keyword">await</span> UploadChunkAsync(fileId, chunk.Index, chunk.Offset, chunk.Size, fileSize, fileInfo.Name, fileStream, cancellationToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (success)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 使用锁保证进度更新的原子性</span></span><br><span class="line">                    <span class="keyword">lock</span> (progressLock)</span><br><span class="line">                    &#123;</span><br><span class="line">                        totalUploaded += chunk.Size;</span><br><span class="line">                        <span class="built_in">int</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)totalUploaded / fileSize * <span class="number">100</span>);</span><br><span class="line">                        ProgressChanged?.Invoke(progress);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            ProgressChanged?.Invoke(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">await</span> MergeChunksAsync(fileId, fileInfo.Name, cancellationToken);</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">async</span> Task&lt;ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt;&gt; GetUploadedChunksAsync(<span class="built_in">string</span> fileId, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.GetAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;GetUploadStatusApiUri&#125;</span>?fileId=<span class="subst">&#123;fileId&#125;</span>&quot;</span>, cancellationToken);</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> response.Content.ReadFromJsonAsync&lt;UploadStatusResponse&gt;(cancellationToken);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt;(result.UploadedChunks.ToDictionary(x =&gt; x.Offset, x =&gt; x.Size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传单个分片</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkIndex, <span class="built_in">long</span> chunkOffset, <span class="built_in">int</span> chunkSize, <span class="built_in">long</span> fileSize,  <span class="built_in">string</span> fileName, Stream fileStream, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> stopwatch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 测量请求延迟</span></span><br><span class="line">            <span class="keyword">var</span> latencyStopwatch = Stopwatch.StartNew();</span><br><span class="line">            <span class="keyword">var</span> pingResponse = <span class="keyword">await</span> _httpClient.GetAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;PingApiUri&#125;</span>&quot;</span>, cancellationToken);</span><br><span class="line">            latencyStopwatch.Stop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备分片数据</span></span><br><span class="line">            <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[chunkSize];</span><br><span class="line">            fileStream.Seek(chunkOffset, SeekOrigin.Begin);</span><br><span class="line">            <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, chunkSize, cancellationToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">            &#123;</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(fileId), <span class="string">&quot;fileId&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(chunkIndex.ToString()), <span class="string">&quot;chunkIndex&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(chunkOffset.ToString()), <span class="string">&quot;chunkOffset&quot;</span> &#125;,                   </span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(bytesRead.ToString()), <span class="string">&quot;chunkSize&quot;</span>&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(fileSize.ToString()), <span class="string">&quot;fileSize&quot;</span>&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> StringContent(fileName), <span class="string">&quot;fileName&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> ByteArrayContent(chunkData, <span class="number">0</span>, bytesRead), <span class="string">&quot;chunk&quot;</span>, <span class="string">&quot;chunk.dat&quot;</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            <span class="keyword">var</span> uploadStopwatch = Stopwatch.StartNew();</span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;UploadChunkApiUri&#125;</span>&quot;</span>, content, cancellationToken);</span><br><span class="line">            uploadStopwatch.Stop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!response.IsSuccessStatusCode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> error = <span class="keyword">await</span> response.Content.ReadAsStringAsync(cancellationToken);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HttpRequestException(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新网络指标</span></span><br><span class="line">            UpdateNetworkMetrics(bytesRead, uploadStopwatch.Elapsed, latencyStopwatch.Elapsed);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            stopwatch.Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传完所有分片后合并分片</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">MergeChunksAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">string</span> fileName, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> stringContent = <span class="keyword">new</span> StringContent(JsonSerializer.Serialize(<span class="keyword">new</span> &#123; FileId = fileId, FileName = fileName &#125;), Encoding.UTF8, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span><span class="subst">&#123;MergeChunksApiUri&#125;</span>&quot;</span>, stringContent, cancellationToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!response.IsSuccessStatusCode)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> error = <span class="keyword">await</span> response.Content.ReadAsStringAsync(cancellationToken);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpRequestException(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetFileHash</span>(<span class="params">Stream stream, HashAlgorithmType hashAlgorithmType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hashAlgorithmType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Md5:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = MD5.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HashAlgorithmType.Sha256:</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> hashAlgorithm = SHA256.Create())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hash = hashAlgorithm.ComputeHash(stream);</span><br><span class="line">                    <span class="keyword">return</span> BitConverter.ToString(hash).Replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).ToLower();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 更新网络指标并动态计算当前分片大小</span></span><br><span class="line">    <span class="comment">// 动态计算当前分片大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">CalculateDynamicChunkSize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_networkLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 基于当前上传速度和延迟计算理想分片大小</span></span><br><span class="line">            <span class="built_in">double</span> targetUploadTimeSec = <span class="number">2.0</span>; <span class="comment">// 目标每个分片上传时间</span></span><br><span class="line">            <span class="built_in">double</span> speedFactor = _averageUploadSpeedMbps* <span class="number">125000</span>; <span class="comment">// Mbps -&gt; bytes/sec</span></span><br><span class="line">            <span class="built_in">double</span> latencyFactor = Math.Max(<span class="number">1</span>, _averageLatencyMs / <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> idealSize = (<span class="built_in">int</span>)(speedFactor * targetUploadTimeSec / latencyFactor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制在最小和最大值之间</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">int</span>)Math.Clamp(idealSize, _minChunkSize, _maxChunkSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新网络指标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateNetworkMetrics</span>(<span class="params"><span class="built_in">long</span> chunkSize, TimeSpan uploadTime, TimeSpan latency</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (_networkLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算速度 (Mbps)</span></span><br><span class="line">            <span class="built_in">double</span> speedMbps = (chunkSize * <span class="number">8</span> / uploadTime.TotalSeconds) / <span class="number">1</span>_000_000;</span><br><span class="line">            <span class="comment">// 平滑处理速度值（加权平均）</span></span><br><span class="line">            _averageUploadSpeedMbps = <span class="number">0.7</span> * _averageUploadSpeedMbps + <span class="number">0.3</span> * speedMbps;</span><br><span class="line">            <span class="comment">// 更新延迟</span></span><br><span class="line">            _averageLatencyMs = <span class="number">0.8</span> * _averageLatencyMs + <span class="number">0.2</span> * latency.TotalMilliseconds;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;网络: <span class="subst">&#123;_averageUploadSpeedMbps:F1&#125;</span>Mbps, &quot;</span> +</span><br><span class="line">                                <span class="string">$&quot;延迟: <span class="subst">&#123;_averageLatencyMs:F0&#125;</span>ms, &quot;</span> +</span><br><span class="line">                                <span class="string">$&quot;分片: <span class="subst">&#123;CalculateDynamicChunkSize() / <span class="number">1024</span>&#125;</span>KB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerable&lt;FileChunk&gt; <span class="title">GenerateChunks</span>(<span class="params"><span class="built_in">long</span> fileSize, <span class="built_in">int</span> currentChunkSize, ConcurrentDictionary&lt;<span class="built_in">long</span>, <span class="built_in">int</span>&gt; uploadedChunks</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">long</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> chunkIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (position &lt; fileSize)</span><br><span class="line">        &#123;</span><br><span class="line">            _semaphoreSlim.WaitAsync(); <span class="comment">// 使用异步锁确保分片信息更新时的原子性</span></span><br><span class="line">            <span class="keyword">if</span> (!uploadedChunks.TryGetValue(position, <span class="keyword">out</span> <span class="keyword">var</span> chunkSize))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 动态调整分片大小</span></span><br><span class="line">                currentChunkSize = CalculateDynamicChunkSize();</span><br><span class="line">                <span class="keyword">var</span> actualChunkSize = (<span class="built_in">int</span>)Math.Min(currentChunkSize, fileSize - position);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 惰性求值: 迭代器代码直到开始遍历才会执行，每次迭代时返回一个值，并保持当前执行状态(局部变量、执行位置等)</span></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> FileChunk</span><br><span class="line">                &#123;</span><br><span class="line">                    Index = chunkIndex,</span><br><span class="line">                    Offset = position,</span><br><span class="line">                    Size = actualChunkSize,</span><br><span class="line">                    RemainingSize = fileSize - (position + actualChunkSize)</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                position += actualChunkSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                position += chunkSize;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            chunkIndex++;</span><br><span class="line"></span><br><span class="line">            _semaphoreSlim.Release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> record</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">record</span> <span class="title">UploadedChunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Offset &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">record</span> <span class="title">UploadStatusResponse</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;UploadedChunk&gt; UploadedChunks &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">record</span> <span class="title">FileChunk</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Index &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Offset &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> RemainingSize &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最终实现的效果如下：</p>
<img   src="/Hexo-Blog/2025/03/25/resumable-upload-and-download/adaptive_resumable_upload_in_winform.png"  class="" title="客户端断点续传上传演示">

<h3 id="完整性校验"><a href="#完整性校验" class="headerlink" title="完整性校验"></a>完整性校验</h3><p>完整性校验包含两个方面：</p>
<ul>
<li>分片完整性校验：校验单个分片的完整性，用于检测网络传输错误(一般使用MD5校验)</li>
<li>文件完整性校验：校验合并后最终文件的完整性，确保内容安全(建议使用SHA-256校验)</li>
</ul>
<p>在计算哈希值时应当仅读取文件内容，避免隐藏的元数据差异(文件创建&#x2F;修改日期等)造成哈希值不同。</p>
<h4 id="分片完整校验"><a href="#分片完整校验" class="headerlink" title="分片完整校验"></a>分片完整校验</h4><p>以下为服务端UploadChunkAsync接口对于分片完整校验的部分代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">AllowAnonymous</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">UploadChunkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> chunkHash = form[<span class="string">&quot;chunkHash&quot;</span>].ToString();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> chunkStream = System.IO.File.OpenRead(chunkPath);</span><br><span class="line">    <span class="keyword">var</span> revievedChunkHash = GetFileHash(chunkStream, HashAlgorithmType.Md5);</span><br><span class="line">    <span class="keyword">if</span> (!chunkHash.Equals(revievedChunkHash))</span><br><span class="line">    &#123;</span><br><span class="line">        chunkStream.Close();</span><br><span class="line">        System.IO.File.Delete(chunkPath);</span><br><span class="line">        <span class="keyword">var</span> errorMsg = <span class="string">$&quot;分片完整性校验失败，原始分片哈希为<span class="subst">&#123;chunkHash&#125;</span>, 接收到的分片哈希为<span class="subst">&#123;revievedChunkHash&#125;</span>, 分片 <span class="subst">&#123;chunkIndex&#125;</span> 已被删除，请重新上传！&quot;</span>;</span><br><span class="line">        _logger.LogError(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为客户端UploadChunkAsync方法对于分片完整性校验的部分代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">UploadChunkAsync</span>(<span class="params"><span class="built_in">string</span> fileId, <span class="built_in">int</span> chunkIndex, <span class="built_in">long</span> chunkOffset, <span class="built_in">int</span> chunkSize, <span class="built_in">long</span> fileSize,  <span class="built_in">string</span> fileName, Stream fileStream, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> chunkData = <span class="keyword">new</span> <span class="built_in">byte</span>[chunkSize];</span><br><span class="line">    fileStream.Seek(chunkOffset, SeekOrigin.Begin);</span><br><span class="line">    <span class="keyword">var</span> bytesRead = <span class="keyword">await</span> fileStream.ReadAsync(chunkData, <span class="number">0</span>, chunkSize, cancellationToken);</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream(chunkData);</span><br><span class="line">    <span class="keyword">var</span> chunkHash = GetFileHash(stream, HashAlgorithmType.Md5);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> content = <span class="keyword">new</span> MultipartFormDataContent</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#123; <span class="keyword">new</span> StringContent(chunkHash.ToString()), <span class="string">&quot;chunkHash&quot;</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件完整性校验"><a href="#文件完整性校验" class="headerlink" title="文件完整性校验"></a>文件完整性校验</h4><p>以下为服务端MergeChunksAsync接口中对于文件完整性校验的部分代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">AllowAnonymous</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">MergeChunksAsync</span>(<span class="params">MergeFile mergeFile, CancellationToken cancellationToken</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> stream = System.IO.File.OpenRead(finalPath);</span><br><span class="line">    <span class="keyword">var</span> mergeFileId = GetFileHash(stream, HashAlgorithmType.Sha256);</span><br><span class="line">    <span class="keyword">if</span> (!mergeFile.FileId.Equals(mergeFileId))</span><br><span class="line">    &#123;</span><br><span class="line">        stream.Close();</span><br><span class="line">        System.IO.File.Delete(finalPath);</span><br><span class="line">        <span class="keyword">var</span> errorMsg = <span class="string">$&quot;合并后的文件内容哈希不正确，文件可能已损坏，合并前内容哈希为<span class="subst">&#123;mergeFile.FileId&#125;</span>, 合并后内容哈希为<span class="subst">&#123;mergeFileId&#125;</span>, 合并后的文件已被删除，请重新上传！&quot;</span>;</span><br><span class="line">        _logger.LogError(errorMsg);</span><br><span class="line">        <span class="keyword">return</span> BadRequest(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重传尝试"><a href="#重传尝试" class="headerlink" title="重传尝试"></a>重传尝试</h3><p>分片上传过程中存在各种不稳定的因素(如网络波动)，可以为客户端上传服务类添加重传尝试机制，在上传失败后自动重新上传。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdaptiveResumableUploadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxRetryCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveResumableUploadService</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    ...,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> maxRetryCount = <span class="number">10</span></span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _maxRetryCount = maxRetryCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主上传方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UploadFileAdaptiveAsync</span>(<span class="params"><span class="built_in">string</span> filePath, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在准备上传...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileInfo = <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = File.OpenRead(filePath);</span><br><span class="line">            <span class="keyword">var</span> fileId = GetFileHash(fileStream, HashAlgorithmType.Sha256); <span class="comment">// 基于文件内容生成唯一ID</span></span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;正在检查已上传分片...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备上传任务</span></span><br><span class="line">            <span class="keyword">var</span> currentChunkSize = _initialChunkSize;</span><br><span class="line">            <span class="keyword">var</span> fileSize = fileInfo.Length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> progressLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> parallelOptions = <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cancellationToken</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> retryCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> completed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!completed &amp;&amp; retryCount &lt; _maxRetryCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取已上传的分片信息</span></span><br><span class="line">                <span class="keyword">var</span> uploadedChunks = <span class="keyword">await</span> GetUploadedChunksAsync(fileId, cancellationToken);</span><br><span class="line">                <span class="keyword">var</span> totalUploaded = uploadedChunks.Values.Sum();</span><br><span class="line">                <span class="built_in">long</span> totalToUpload = fileSize - totalUploaded;</span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;需要上传 <span class="subst">&#123;totalToUpload&#125;</span> 字节&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> Parallel.ForEachAsync(GenerateChunks(fileSize, currentChunkSize, uploadedChunks), parallelOptions, <span class="keyword">async</span> (chunk, cancellationToken) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">bool</span> success = <span class="keyword">await</span> UploadChunkAsync(fileId, chunk.Index, chunk.Offset, chunk.Size, fileSize, fileInfo.Name, fileStream, cancellationToken);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (success)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// 使用锁保证进度更新的原子性</span></span><br><span class="line">                            <span class="keyword">lock</span> (progressLock)</span><br><span class="line">                            &#123;</span><br><span class="line">                                totalUploaded += chunk.Size;</span><br><span class="line">                                <span class="built_in">int</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)totalUploaded / fileSize * <span class="number">100</span>);</span><br><span class="line">                                ProgressChanged?.Invoke(progress);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">await</span> MergeChunksAsync(fileId, fileInfo.Name, cancellationToken);</span><br><span class="line">                    completed = <span class="literal">true</span>;</span><br><span class="line">                    ProgressChanged?.Invoke(<span class="number">100</span>);</span><br><span class="line">                    StatusChanged?.Invoke(<span class="string">&quot;上传完成！&quot;</span>);</span><br><span class="line">                    UploadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    retryCount++;</span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= _maxRetryCount) <span class="keyword">throw</span>;</span><br><span class="line">                    <span class="keyword">await</span> Task.Delay(<span class="number">100</span> * retryCount, cancellationToken);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;上传已取消&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            UploadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分片定时清理"><a href="#分片定时清理" class="headerlink" title="分片定时清理"></a>分片定时清理</h3><p>断点续传留下的分片会随着时间在服务器上越积越多，因此需要有一个分片定时清理策略。</p>
<p>首先在服务端创建一个后台任务配置类，用于读取appsettings.json中的后台任务配置项，并在Program.cs中注册配置项，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BackgroundJobOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> StartHour &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> StartMinute &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> StartSecond &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> IntervalMinute &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CleanUpDaysAgo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册配置类</span></span><br><span class="line">builder.Services.Configure&lt;BackgroundJobOptions&gt;(builder.Configuration.GetSection(<span class="string">&quot;BackgroundJobOptions&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>appsettings.json中的配置项如下所示。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;BackgroundJobOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;StartHour&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;StartMinute&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;StartSecond&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IntervalMinute&quot;</span><span class="punctuation">:</span> <span class="number">1440</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;CleanUpDaysAgo&quot;</span><span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后定义IWorkServie和WorkService，作为分片定时清理服务类。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WorkService</span> : <span class="title">IWorkService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> executionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WorkService&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> DateTime nextDateTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IWebHostEnvironment _env;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> BackgroundJobOptions _backgroundJobOptions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkService</span>(<span class="params">ILogger&lt;WorkService&gt; logger, IWebHostEnvironment env, IOptions&lt;BackgroundJobOptions&gt; backgroundJobOptions</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _env = env;</span><br><span class="line">        _backgroundJobOptions = backgroundJobOptions.Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TaskWorkAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算下一个时间节点</span></span><br><span class="line">            <span class="keyword">var</span> now = DateTime.Now;</span><br><span class="line">            <span class="keyword">var</span> firstDateTime = <span class="keyword">new</span> DateTime(now.Year, now.Month, now.Day, _backgroundJobOptions.StartHour, _backgroundJobOptions.StartMinute, _backgroundJobOptions.StartSecond);</span><br><span class="line">            <span class="keyword">if</span> (executionCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = firstDateTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nextDateTime = nextDateTime.AddMinutes(_backgroundJobOptions.IntervalMinute);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextDateTime &lt; now)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime.AddDays(<span class="number">1</span>) - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delay = nextDateTime - now;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delay, cancellationToken);</span><br><span class="line">                    CleanupOldUploads(_backgroundJobOptions.CleanUpDaysAgo);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> count = Interlocked.Increment(<span class="keyword">ref</span> executionCount);</span><br><span class="line">                _logger.LogInformation(<span class="string">&quot;已完成分片自动清理. 累计清理次数: &#123;Count&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CleanupOldUploads</span>(<span class="params"><span class="built_in">int</span> daysAgo</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cutoff = DateTime.Now.AddDays(-daysAgo);</span><br><span class="line">        <span class="keyword">var</span> uploadPath = Path.Combine(_env.WebRootPath, <span class="string">&quot;uploads&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> dir <span class="keyword">in</span> Directory.GetDirectories(uploadPath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> dirName = dir.Split(<span class="string">&#x27;\\&#x27;</span>).Last();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;completed&quot;</span>.Equals(dirName) &amp;&amp; Directory.GetCreationTime(dir) &lt; cutoff)</span><br><span class="line">            &#123;</span><br><span class="line">                Directory.Delete(dir, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个后台服务类UploadCleanupService继承BackgroundService，并调用WorkService中的分片定时清理服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UploadCleanupService</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _services;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadCleanupService</span>(<span class="params">IServiceProvider services</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _services = services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> scope = _services.CreateScope();</span><br><span class="line">        <span class="comment">//获取服务类</span></span><br><span class="line">        <span class="keyword">var</span> taskWorkService = scope.ServiceProvider.GetRequiredService&lt;IWorkService&gt;();</span><br><span class="line">        <span class="comment">//执行服务类的定时任务</span></span><br><span class="line">        <span class="keyword">await</span> taskWorkService.TaskWorkAsync(stoppingToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在Program.cs中注册后台服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册后台服务</span></span><br><span class="line">builder.Services.AddHostedService&lt;UploadCleanupService&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="断点续传下载"><a href="#断点续传下载" class="headerlink" title="断点续传下载"></a>断点续传下载</h2><p>与断点续传上传类似，断点续传下载同样包含下载进度反馈、下载取消、并行下载等辅助功能。</p>
<p>下面我们来简单实现上述功能。</p>
<h3 id="下载进度反馈与下载取消"><a href="#下载进度反馈与下载取消" class="headerlink" title="下载进度反馈与下载取消"></a>下载进度反馈与下载取消</h3><h4 id="服务端实现-5"><a href="#服务端实现-5" class="headerlink" title="服务端实现"></a>服务端实现</h4><p>由于断点续传上传中使用了wwwroot静态资源文件夹，服务端的文件可直接通过url访问。确保Program.cs中启用了静态文件服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用静态文件服务</span></span><br><span class="line">app.UseStaticFiles(); </span><br></pre></td></tr></table></figure>

<h4 id="客户端实现-5"><a href="#客户端实现-5" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ResumableDownloadService服务类，根据传入的服务器文件地址，使用Range头请求从断点处继续下载(确保服务器支持Range请求头)，并提供进度条反馈和取消下载功能。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResumableDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; ProgressChanged; <span class="comment">// 上传百分比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">string</span>&gt; StatusChanged; <span class="comment">// 状态消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">bool</span>&gt; DownloadCompleted; <span class="comment">// 完成状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResumableDownloadService</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DownloadWithResumeAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查目标文件是否已存在部分下载内容</span></span><br><span class="line">            <span class="built_in">long</span> existingLength = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir))</span><br><span class="line">            &#123;</span><br><span class="line">                Directory.CreateDirectory(destDir);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (File.Exists(destinationPath))</span><br><span class="line">            &#123;</span><br><span class="line">                existingLength = <span class="keyword">new</span> FileInfo(destinationPath).Length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 Range 头请求从断点处继续下载</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, fileUrl);</span><br><span class="line">            <span class="keyword">if</span> (existingLength &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                request.Headers.Range = <span class="keyword">new</span> RangeHeaderValue(existingLength, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);</span><br><span class="line">            <span class="keyword">if</span> (!response.IsSuccessStatusCode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (response.StatusCode == System.Net.HttpStatusCode.RequestedRangeNotSatisfiable)</span><br><span class="line">                &#123;</span><br><span class="line">                    StatusChanged?.Invoke(<span class="string">&quot;下载完成！&quot;</span>); <span class="comment">// Range头请求范围超出文件大小，视为下载完成</span></span><br><span class="line">                    ProgressChanged?.Invoke(<span class="number">100</span>);</span><br><span class="line">                    DownloadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> fileTotalLength = response.Content.Headers.ContentLength;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync(cancellationToken);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(destinationPath, existingLength &gt; <span class="number">0</span> ? FileMode.Append : FileMode.Create, FileAccess.Write, FileShare.None);</span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">8192</span>];</span><br><span class="line">            <span class="built_in">int</span> bytesRead;</span><br><span class="line">            <span class="built_in">long</span> totalRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = <span class="keyword">await</span> contentStream.ReadAsync(buffer, <span class="number">0</span>, buffer.Length, cancellationToken)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> fileStream.WriteAsync(buffer, <span class="number">0</span>, bytesRead, cancellationToken);</span><br><span class="line">                totalRead += bytesRead;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> progress = (<span class="built_in">int</span>)((<span class="built_in">double</span>)totalRead / fileTotalLength * <span class="number">100</span>);</span><br><span class="line">                ProgressChanged?.Invoke(progress);</span><br><span class="line">                StatusChanged?.Invoke(<span class="string">$&quot;当前上传进度: <span class="subst">&#123;progress&#125;</span>%&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;下载完成！&quot;</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">&quot;下载已取消&quot;</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            StatusChanged?.Invoke(<span class="string">$&quot;上传失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上传类似，主窗体MainForm中的代码如下。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ResumableDownloadService _downloader;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _downloader = <span class="keyword">new</span> ResumableDownloadService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _downloader.ProgressChanged += UpdateProgress;</span><br><span class="line">        _downloader.StatusChanged += UpdateStatus;</span><br><span class="line">        _downloader.DownloadCompleted += UploadCompleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateProgress</span>(<span class="params"><span class="built_in">int</span> percent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (progressBar.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">int</span>&gt;(UpdateProgress), percent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        progressBar.Value = percent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateStatus</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lblStatus.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            lblStatus.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">string</span>&gt;(UpdateStatus), message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lblStatus.Text = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UploadCompleted</span>(<span class="params"><span class="built_in">bool</span> success</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (btnDownload.InvokeRequired)</span><br><span class="line">        &#123;</span><br><span class="line">            btnDownload.Invoke(<span class="keyword">new</span> Action&lt;<span class="built_in">bool</span>&gt;(UploadCompleted), success);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        btnDownload.Enabled = <span class="literal">true</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">btnDownload_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(textBox.Text) || !Directory.Exists(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;请选择有效目录！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnDownload.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnCancel.Enabled = <span class="literal">true</span>;</span><br><span class="line">        progressBar.Value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        _cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        <span class="built_in">string</span> fileUrl = <span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span>/uploads/completed/test.mp4&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> destDir = textBox.Text;</span><br><span class="line">        <span class="keyword">await</span> _downloader.DownloadWithResumeAsync(fileUrl, destDir, _cts.Token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnBrowse_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> folderBrowserDialog = <span class="keyword">new</span> FolderBrowserDialog();</span><br><span class="line">        <span class="comment">// 设置对话框标题</span></span><br><span class="line">        folderBrowserDialog.Description = <span class="string">&quot;请选择保存文件的目录&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置初始目录（可选）</span></span><br><span class="line">        folderBrowserDialog.SelectedPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示对话框</span></span><br><span class="line">        <span class="keyword">if</span> (folderBrowserDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取用户选择的目录路径</span></span><br><span class="line">            textBox.Text = folderBrowserDialog.SelectedPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFormClosing</span>(<span class="params">FormClosingEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cts?.Cancel();</span><br><span class="line">        <span class="keyword">base</span>.OnFormClosing(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行下载与暂停恢复"><a href="#并行下载与暂停恢复" class="headerlink" title="并行下载与暂停恢复"></a>并行下载与暂停恢复</h3><h4 id="客户端实现-6"><a href="#客户端实现-6" class="headerlink" title="客户端实现"></a>客户端实现</h4><p>首先创建一个ParallelDownloadService服务类，默认并发下载线程数为4，并使用并发字典记录CancellationTokenSource，以便实现下载的暂停和恢复。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt; _activeDownloads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> BufferSize = <span class="number">8192</span>; <span class="comment">// 缓冲区 8KB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">long</span>, <span class="built_in">long</span>&gt; ProgressChanged; <span class="comment">// 当前下载量, 总大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; DownloadCompleted;     <span class="comment">// 下载ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>, Exception&gt; DownloadFailed; <span class="comment">// 下载ID, 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParallelDownloadService</span>(<span class="params"><span class="built_in">int</span> maxParallelism = <span class="number">4</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        _httpClient.Timeout = Timeout.InfiniteTimeSpan;</span><br><span class="line">        _activeDownloads = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt;();</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">StartParallelDownloadAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> downloadId = fileUrl.GetHashCode();</span><br><span class="line">        <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        _activeDownloads.TryAdd(downloadId, cts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取文件总大小</span></span><br><span class="line">            <span class="keyword">var</span> fileSize = <span class="keyword">await</span> GetFileSizeAsync(fileUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempDir = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\temp&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempPath = <span class="string">$&quot;<span class="subst">&#123;tempDir&#125;</span>\\<span class="subst">&#123;Path.GetFileNameWithoutExtension(destFile)&#125;</span>.tmp&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir)) Directory.CreateDirectory(destDir);</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(tempDir)) Directory.CreateDirectory(tempDir);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(tempPath, FileMode.Create, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                fs.SetLength(fileSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分片</span></span><br><span class="line">            <span class="keyword">var</span> chunks = CalculateChunks(fileSize, _maxParallelism);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并行下载</span></span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; Parallel.ForEachAsync(chunks, <span class="keyword">new</span> ParallelOptions</span><br><span class="line">            &#123;</span><br><span class="line">                MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                CancellationToken = cts.Token</span><br><span class="line">            &#125;, <span class="keyword">async</span> (chunk, ct) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _semaphoreSlim.WaitAsync();</span><br><span class="line">                <span class="keyword">await</span> DownloadChunkAsync(downloadId, fileUrl, tempPath, chunk.Start, chunk.End, fileSize, ct);</span><br><span class="line">                _semaphoreSlim.Release();</span><br><span class="line">            &#125;), cts.Token);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下载完成后重命名临时文件</span></span><br><span class="line">            File.Move(tempPath, destinationPath, <span class="literal">true</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(downloadId);</span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            DownloadFailed?.Invoke(downloadId, ex);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _activeDownloads.TryRemove(downloadId, <span class="keyword">out</span> _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PauseDownload</span>(<span class="params"><span class="built_in">int</span> downloadId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_activeDownloads.TryGetValue(downloadId, <span class="keyword">out</span> <span class="keyword">var</span> cts))</span><br><span class="line">        &#123;</span><br><span class="line">            cts.Cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadChunkAsync</span>(<span class="params"><span class="built_in">int</span> downloadId, <span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destinationPath, <span class="built_in">long</span> start, <span class="built_in">long</span> end, <span class="built_in">long</span> fileSize, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 Range 头请求从断点处继续下载</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, fileUrl);</span><br><span class="line">            request.Headers.Range = <span class="keyword">new</span> RangeHeaderValue(start, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);</span><br><span class="line"></span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(destinationPath, FileMode.Open, FileAccess.Write);</span><br><span class="line"></span><br><span class="line">            fileStream.Seek(start, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用固定大小缓冲区，避免内存问题</span></span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[BufferSize];</span><br><span class="line">            <span class="built_in">int</span> bytesRead;</span><br><span class="line">            <span class="built_in">long</span> totalRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = <span class="keyword">await</span> contentStream.ReadAsync(buffer, <span class="number">0</span>, buffer.Length, cancellationToken)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> fileStream.WriteAsync(buffer, <span class="number">0</span>, bytesRead, cancellationToken);</span><br><span class="line">                totalRead += bytesRead;</span><br><span class="line">                ProgressChanged?.Invoke(start + totalRead, fileSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;分片下载失败(<span class="subst">&#123;start&#125;</span>-<span class="subst">&#123;end&#125;</span>): <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;(<span class="built_in">long</span> Start, <span class="built_in">long</span> End)&gt; CalculateChunks(<span class="built_in">long</span> fileSize, <span class="built_in">int</span> threadCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> chunkSize = Math.Max(ChunkSize, fileSize / threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">long</span> i = <span class="number">0</span>; i &lt; fileSize; i += chunkSize + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> end = Math.Min(i + chunkSize, fileSize - <span class="number">1</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="title">return</span> (<span class="params">i, end</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">GetFileSizeAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Head, fileUrl);</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request);</span><br><span class="line"></span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">        <span class="keyword">return</span> response.Content.Headers.ContentLength ??</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;无法获取文件大小&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主窗体MainForm中的代码如下。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ParallelDownloadService _downloader;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _currentDownloadId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _downloader = <span class="keyword">new</span> ParallelDownloadService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _downloader.ProgressChanged += OnDownloadProgress;</span><br><span class="line">        _downloader.DownloadCompleted += OnDownloadComplete;</span><br><span class="line">        _downloader.DownloadFailed += OnDownloadFailed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按钮置灰</span></span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnStart_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(textBox.Text) || !Directory.Exists(textBox.Text))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;请选择有效目录！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnStart.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnPause.Enabled = <span class="literal">true</span>;</span><br><span class="line">        progressBar.Value = <span class="number">0</span>;</span><br><span class="line">        lblStatus.Text = <span class="string">&quot;下载中...&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> fileUrl = <span class="string">$&quot;<span class="subst">&#123;_serviceUri&#125;</span>/uploads/completed/test.mp4&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> destDir = textBox.Text;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始下载</span></span><br><span class="line">        _ = Task.Run(<span class="keyword">async</span> () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">                _currentDownloadId = <span class="keyword">await</span> _downloader.StartParallelDownloadAsync(fileUrl, destDir);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnPause_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _downloader.PauseDownload(_currentDownloadId);</span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">true</span>;</span><br><span class="line">        lblStatus.Text = <span class="string">&quot;已暂停&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnResume_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 重新开始下载</span></span><br><span class="line">        btnStart_Click(sender, e);</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnBrowse_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> folderBrowserDialog = <span class="keyword">new</span> FolderBrowserDialog();</span><br><span class="line">        <span class="comment">// 设置对话框标题</span></span><br><span class="line">        folderBrowserDialog.Description = <span class="string">&quot;请选择保存文件的目录&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置初始目录（可选）</span></span><br><span class="line">        folderBrowserDialog.SelectedPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示对话框</span></span><br><span class="line">        <span class="keyword">if</span> (folderBrowserDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取用户选择的目录路径</span></span><br><span class="line">            textBox.Text = folderBrowserDialog.SelectedPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDownloadProgress</span>(<span class="params"><span class="built_in">long</span> bytes, <span class="built_in">long</span> fileSize</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Maximum = (<span class="built_in">int</span>)(fileSize / <span class="number">1024</span>);</span><br><span class="line">            progressBar.Value = (<span class="built_in">int</span>)(bytes / <span class="number">1024</span>);</span><br><span class="line">            lblProgress.Text = <span class="string">$&quot;<span class="subst">&#123;bytes / <span class="number">1024</span> / <span class="number">1024</span>&#125;</span>MB / <span class="subst">&#123;fileSize / <span class="number">1024</span> / <span class="number">1024</span>&#125;</span>MB&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDownloadComplete</span>(<span class="params"><span class="built_in">int</span> downloadId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            lblStatus.Text = <span class="string">&quot;下载完成&quot;</span>;</span><br><span class="line">            ResetUI();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDownloadFailed</span>(<span class="params"><span class="built_in">int</span> downloadId, Exception ex</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">$&quot;下载失败: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            lblStatus.Text = <span class="string">&quot;下载失败&quot;</span>;</span><br><span class="line">            ResetUI();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        btnStart.Enabled = <span class="literal">true</span>;</span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下载重试"><a href="#下载重试" class="headerlink" title="下载重试"></a>下载重试</h3><p>与上传类似，断点续传下载也可以添加重试机制。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxRetryCount;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParallelDownloadService</span>(<span class="params">..., <span class="built_in">int</span> maxRetryCount = <span class="number">10</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        _maxRetryCount = maxRetryCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">StartParallelDownloadAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> downloadId = fileUrl.GetHashCode();</span><br><span class="line">        <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        _activeDownloads.TryAdd(downloadId, cts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取文件总大小</span></span><br><span class="line">            <span class="keyword">var</span> fileSize = <span class="keyword">await</span> GetFileSizeAsync(fileUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempDir = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\temp&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempPath = <span class="string">$&quot;<span class="subst">&#123;tempDir&#125;</span>\\<span class="subst">&#123;Path.GetFileNameWithoutExtension(destFile)&#125;</span>.tmp&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir)) Directory.CreateDirectory(destDir);</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(tempDir)) Directory.CreateDirectory(tempDir);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(tempPath, FileMode.Create, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                fs.SetLength(fileSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分片</span></span><br><span class="line">            <span class="keyword">var</span> chunks = CalculateChunks(fileSize, _maxParallelism);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并行下载</span></span><br><span class="line">            <span class="keyword">var</span> retryCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> completed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!completed &amp;&amp; retryCount &lt; _maxRetryCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> Task.Run(() =&gt; Parallel.ForEachAsync(chunks, <span class="keyword">new</span> ParallelOptions</span><br><span class="line">                    &#123;</span><br><span class="line">                        MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                        CancellationToken = cts.Token</span><br><span class="line">                    &#125;, <span class="keyword">async</span> (chunk, ct) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">await</span> _semaphoreSlim.WaitAsync();</span><br><span class="line">                        <span class="keyword">await</span> DownloadChunkAsync(downloadId, fileUrl, tempPath, chunk.Start, chunk.End, fileSize, ct);</span><br><span class="line">                        _semaphoreSlim.Release();</span><br><span class="line">                    &#125;), cts.Token);</span><br><span class="line"></span><br><span class="line">                    completed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    retryCount++;</span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= _maxRetryCount) <span class="keyword">throw</span>;</span><br><span class="line">                    <span class="keyword">await</span> Task.Delay(<span class="number">100</span> * retryCount); <span class="comment">// 指数退避</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下载完成后重命名临时文件</span></span><br><span class="line">            File.Move(tempPath, destinationPath, <span class="literal">true</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(downloadId);</span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            DownloadFailed?.Invoke(downloadId, ex);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _activeDownloads.TryRemove(downloadId, <span class="keyword">out</span> _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限速下载"><a href="#限速下载" class="headerlink" title="限速下载"></a>限速下载</h3><p>断点续传下载同样可以添加下载速度限制功能。下面创建一个SpeedLimitResumableDownloadService服务类，在并行下载基础上，添加限速下载功能。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpeedLimitResumableDownloadService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt; _activeDownloads;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> BufferSize = <span class="number">8192</span>; <span class="comment">// 缓冲区 8KB</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ChunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB 每块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxParallelism;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _maxRetryCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _maxSpeedKBps; <span class="comment">// 0表示不限速</span></span><br><span class="line">    <span class="keyword">private</span> Stopwatch _stopWatch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphoreSlim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度和状态事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">long</span>, <span class="built_in">long</span>&gt; ProgressChanged; <span class="comment">// 当前下载量, 总大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; DownloadCompleted;     <span class="comment">// 下载ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>, Exception&gt; DownloadFailed; <span class="comment">// 下载ID, 异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;<span class="built_in">double</span>&gt; SpeedChanged;      <span class="comment">// 下载速度(KB/s)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpeedLimitResumableDownloadService</span>(<span class="params"><span class="built_in">int</span> maxParallelism = <span class="number">4</span>, <span class="built_in">int</span> maxRetryCount = <span class="number">10</span>, <span class="built_in">int</span> maxSpeedKBps = <span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        _stopWatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        _httpClient.Timeout = Timeout.InfiniteTimeSpan;</span><br><span class="line">        _activeDownloads = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="built_in">int</span>, CancellationTokenSource&gt;();</span><br><span class="line">        _maxParallelism = maxParallelism;</span><br><span class="line">        _maxRetryCount = maxRetryCount;</span><br><span class="line">        _maxSpeedKBps = maxSpeedKBps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">StartParallelDownloadAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destDir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> downloadId = fileUrl.GetHashCode();</span><br><span class="line">        <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        _activeDownloads.TryAdd(downloadId, cts);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取文件总大小</span></span><br><span class="line">            <span class="keyword">var</span> fileSize = <span class="keyword">await</span> GetFileSizeAsync(fileUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="keyword">var</span> destFile = fileUrl.Split(<span class="string">&quot;/&quot;</span>).Last();</span><br><span class="line">            <span class="keyword">var</span> destinationPath = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\<span class="subst">&#123;destFile&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempDir = <span class="string">$&quot;<span class="subst">&#123;destDir&#125;</span>\\temp&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> tempPath = <span class="string">$&quot;<span class="subst">&#123;tempDir&#125;</span>\\<span class="subst">&#123;Path.GetFileNameWithoutExtension(destFile)&#125;</span>.tmp&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(destDir)) Directory.CreateDirectory(destDir);</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(tempDir)) Directory.CreateDirectory(tempDir);</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> fs = <span class="keyword">new</span> FileStream(tempPath, FileMode.Create, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                fs.SetLength(fileSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分片</span></span><br><span class="line">            <span class="keyword">var</span> chunks = CalculateChunks(fileSize, _maxParallelism);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 并行下载</span></span><br><span class="line">            <span class="keyword">var</span> retryCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">var</span> completed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!completed &amp;&amp; retryCount &lt; _maxRetryCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> Task.Run(() =&gt; Parallel.ForEachAsync(chunks, <span class="keyword">new</span> ParallelOptions</span><br><span class="line">                    &#123;</span><br><span class="line">                        MaxDegreeOfParallelism = _maxParallelism,</span><br><span class="line">                        CancellationToken = cts.Token</span><br><span class="line">                    &#125;, <span class="keyword">async</span> (chunk, ct) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">await</span> _semaphoreSlim.WaitAsync();</span><br><span class="line">                        <span class="keyword">await</span> DownloadChunkAsync(downloadId, fileUrl, tempPath, chunk.Start, chunk.End, fileSize, ct);</span><br><span class="line">                        _semaphoreSlim.Release();</span><br><span class="line">                    &#125;), cts.Token);</span><br><span class="line"></span><br><span class="line">                    completed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span></span><br><span class="line">                &#123;</span><br><span class="line">                    retryCount++;</span><br><span class="line">                    <span class="keyword">if</span> (retryCount &gt;= _maxRetryCount) <span class="keyword">throw</span>;</span><br><span class="line">                    <span class="keyword">await</span> Task.Delay(<span class="number">100</span> * retryCount); <span class="comment">// 指数退避</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下载完成后重命名临时文件</span></span><br><span class="line">            File.Move(tempPath, destinationPath, <span class="literal">true</span>);</span><br><span class="line">            DownloadCompleted?.Invoke(downloadId);</span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">            <span class="keyword">return</span> downloadId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            DownloadFailed?.Invoke(downloadId, ex);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _activeDownloads.TryRemove(downloadId, <span class="keyword">out</span> _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PauseDownload</span>(<span class="params"><span class="built_in">int</span> downloadId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_activeDownloads.TryGetValue(downloadId, <span class="keyword">out</span> <span class="keyword">var</span> cts))</span><br><span class="line">        &#123;</span><br><span class="line">            cts.Cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">DownloadChunkAsync</span>(<span class="params"><span class="built_in">int</span> downloadId, <span class="built_in">string</span> fileUrl, <span class="built_in">string</span> destinationPath, <span class="built_in">long</span> start, <span class="built_in">long</span> end, <span class="built_in">long</span> fileSize, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用 Range 头请求从断点处继续下载</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Get, fileUrl);</span><br><span class="line">            request.Headers.Range = <span class="keyword">new</span> RangeHeaderValue(start, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);</span><br><span class="line"></span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> contentStream = <span class="keyword">await</span> response.Content.ReadAsStreamAsync();</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> fileStream = <span class="keyword">new</span> FileStream(destinationPath, FileMode.Open, FileAccess.Write);</span><br><span class="line"></span><br><span class="line">            fileStream.Seek(start, SeekOrigin.Begin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用固定大小缓冲区，避免内存问题</span></span><br><span class="line">            <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[BufferSize];</span><br><span class="line">            <span class="built_in">int</span> bytesRead;</span><br><span class="line">            <span class="built_in">long</span> totalRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = <span class="keyword">await</span> ReadWithSpeedLimit(contentStream, buffer, cancellationToken)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> fileStream.WriteAsync(buffer, <span class="number">0</span>, bytesRead, cancellationToken);</span><br><span class="line">                <span class="comment">// 更新下载进度</span></span><br><span class="line">                totalRead += bytesRead;</span><br><span class="line">                ProgressChanged?.Invoke(start + totalRead, fileSize);</span><br><span class="line">                <span class="comment">// 更新下载速度</span></span><br><span class="line">                <span class="keyword">var</span> speed = bytesRead / <span class="number">1024.0</span> / _stopWatch.Elapsed.TotalSeconds;</span><br><span class="line">                SpeedChanged?.Invoke(speed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 正常取消，不视为错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;分片下载失败(<span class="subst">&#123;start&#125;</span>-<span class="subst">&#123;end&#125;</span>): <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _stopWatch.Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">ReadWithSpeedLimit</span>(<span class="params">Stream stream, <span class="built_in">byte</span>[] buffer, CancellationToken cancellationToken</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _stopWatch.Restart();</span><br><span class="line">        <span class="keyword">var</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (_maxSpeedKBps &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不限速</span></span><br><span class="line">            bytesRead = <span class="keyword">await</span> stream.ReadAsync(buffer, <span class="number">0</span>, buffer.Length, cancellationToken);</span><br><span class="line">            <span class="keyword">return</span> bytesRead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次读取的最大字节数</span></span><br><span class="line">        <span class="keyword">var</span> maxBytes = (<span class="built_in">int</span>)(_maxSpeedKBps * <span class="number">1024</span> * <span class="number">0.1</span>); <span class="comment">// 每100ms的限额</span></span><br><span class="line">        <span class="keyword">var</span> readSize = Math.Min(buffer.Length, maxBytes);</span><br><span class="line"></span><br><span class="line">        bytesRead = <span class="keyword">await</span> stream.ReadAsync(buffer, <span class="number">0</span>, readSize, cancellationToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 速度控制</span></span><br><span class="line">        <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span> &amp;&amp; _maxSpeedKBps &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> expectedTime = (bytesRead / <span class="number">1024.0</span>) / _maxSpeedKBps * <span class="number">1000</span>; <span class="comment">// 毫秒</span></span><br><span class="line">            <span class="keyword">var</span> actualTime = _stopWatch.ElapsedMilliseconds;</span><br><span class="line">            <span class="keyword">var</span> delayTime = (<span class="built_in">int</span>)(expectedTime - actualTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (delayTime &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(delayTime, cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytesRead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;(<span class="built_in">long</span> Start, <span class="built_in">long</span> End)&gt; CalculateChunks(<span class="built_in">long</span> fileSize, <span class="built_in">int</span> threadCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同并行下载</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">GetFileSizeAsync</span>(<span class="params"><span class="built_in">string</span> fileUrl</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 同并行下载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主窗体MainForm中的部分代码如下。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainForm</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serviceUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SpeedLimitResumableDownloadService _downloader;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _currentDownloadId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainForm</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        _serviceUri = <span class="string">&quot;http://localhost:5001&quot;</span>;</span><br><span class="line">        _downloader = <span class="keyword">new</span> SpeedLimitResumableDownloadService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定事件</span></span><br><span class="line">        _downloader.ProgressChanged += OnDownloadProgress;</span><br><span class="line">        _downloader.DownloadCompleted += OnDownloadComplete;</span><br><span class="line">        _downloader.DownloadFailed += OnDownloadFailed;</span><br><span class="line">        _downloader.SpeedChanged += OnSpeedChanged;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按钮置灰</span></span><br><span class="line">        btnPause.Enabled = <span class="literal">false</span>;</span><br><span class="line">        btnResume.Enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSpeedChanged</span>(<span class="params"><span class="built_in">double</span> speedKBps</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Invoke((Delegate)(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            lblSpeed.Text = <span class="string">$&quot;<span class="subst">&#123;speedKBps / <span class="number">1024</span>:<span class="number">0.00</span>&#125;</span> MB/s&quot;</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终实现的效果如下：</p>
<img   src="/Hexo-Blog/2025/03/25/resumable-upload-and-download/resumable_download_in_winform.png"  class="" title="客户端断点续传下载演示">

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://help.aliyun.com/zh/oss/user-guide/resumable-upload" >阿里云OSS断点续传上传操作指南<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://help.aliyun.com/zh/oss/user-guide/oss-resumable-download" >阿里云OSS断点续传下载操作指南<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.forms.control.invokerequired" >Control.InvokeRequired属性参考文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>ASP.NET Core</tag>
        <tag>WinForm</tag>
      </tags>
  </entry>
  <entry>
    <title>安全扫描技术及其应用场景</title>
    <url>/Hexo-Blog/2024/12/13/security-scan/</url>
    <content><![CDATA[<p>三种常用的安全扫描技术原理、相关工具及应用场景。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安全扫描技术是网络安全领域中用于检测系统、网络和应用程序中潜在安全漏洞的重要手段，分为端口扫描技术、漏洞扫描技术、Web应用扫描技术等，其中漏洞扫描技术分为基于网络的漏洞扫描和基于主机的漏洞扫描。其工作流程分为信息收集、扫描执行、结果分析、漏洞报告四个部分。</p>
<h2 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过向目标主机的一系列端口发送数据包，根据目标主机的响应来判断端口是开放还是关闭的。例如，TCP 连接扫描（全连接扫描）会尝试与目标端口建立完整的 TCP 三次握手。如果能够成功完成三次握手，说明端口是开放的；如果在握手过程中收到复位（RST）信号，则表示端口是关闭的。</p>
<h3 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h3><p>Nmap是一款非常著名的端口扫描工具。它可以快速扫描目标主机上大量端口，并且能够识别端口对应的服务。例如，使用命令<code>nmap -p 1 - 1000 &lt;target_ip_address&gt;</code>可以扫描目标主机上1到1000号端口的开放情况。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="SSL-TLS协议信息泄露漏洞（CVE-2016-2183）"><a href="#SSL-TLS协议信息泄露漏洞（CVE-2016-2183）" class="headerlink" title="SSL&#x2F;TLS协议信息泄露漏洞（CVE-2016-2183）"></a>SSL&#x2F;TLS协议信息泄露漏洞（CVE-2016-2183）</h4><p>Windows系统下使用DES、3DES、IDEA等弱加密算法会引发SSL&#x2F;TLS协议信息泄露漏洞。</p>
<p>首先下载<a class="link"   href="https://nmap.org/download#windows" >nmap<i class="fas fa-external-link-alt"></i></a>，下载完成后打开命令行输入以下命令(端口以443为例)，查看套件中是否存在DES&#x2F;3DES加密套件</p>
<p><code>nmap -p 443 --script ssl-enum-ciphers localhost</code></p>
<p>确认漏洞存在后，下载<a class="link"   href="https://www.nartac.com/Products/IISCrypto/Download" >IISCrypto<i class="fas fa-external-link-alt"></i></a>禁用加密套件。安装完成后点击左下角推荐设置Best Practices，再取消勾选Ciphers框里的Triple DES 168，即可点击Apply并重启，此时使用nmap复查发现DES&#x2F;3DES加密套件已消失，漏洞修复完成。</p>
<h2 id="基于网络的漏洞扫描技术"><a href="#基于网络的漏洞扫描技术" class="headerlink" title="基于网络的漏洞扫描技术"></a>基于网络的漏洞扫描技术</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>通过网络向目标系统发送特定的探测数据包，模拟黑客攻击行为，检查目标系统是否存在已知的安全漏洞。这些扫描器通常拥有一个庞大的漏洞数据库，其中包含各种软件、操作系统和网络设备的已知漏洞信息。</p>
<h3 id="相关工具-1"><a href="#相关工具-1" class="headerlink" title="相关工具"></a>相关工具</h3><p>OpenVAS是一个开源的漏洞扫描器，它能够扫描网络中的各种设备，包括服务器、防火墙等，检测诸如操作系统漏洞、Web 应用漏洞等多种类型的漏洞。</p>
<h2 id="基于主机的漏洞扫描技术"><a href="#基于主机的漏洞扫描技术" class="headerlink" title="基于主机的漏洞扫描技术"></a>基于主机的漏洞扫描技术</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>在目标主机本地安装扫描软件，对主机系统本身进行扫描，检查系统配置、文件权限、安装的软件等方面是否存在安全隐患。它主要关注主机内部的安全状态，例如检查是否存在弱口令、未及时更新的软件等。</p>
<h3 id="相关工具-2"><a href="#相关工具-2" class="headerlink" title="相关工具"></a>相关工具</h3><p>MBSA（Microsoft Baseline Security Analyzer）是一款针对Windows系统的漏洞扫描工具，可以检测Windows操作系统以及微软的其他软件（如 IIS、SQL Server 等）是否存在安全漏洞，包括安全更新缺失、账户策略不安全等问题。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="IIS隐藏Server信息"><a href="#IIS隐藏Server信息" class="headerlink" title="IIS隐藏Server信息"></a>IIS隐藏Server信息</h4><p>IIS服务器端返回信息中包含有软件版本等详细信息，攻击者利用这些信息可以实现更有目的性的攻击。因此隐藏server版本信息，在一定程度上能够提高服务器的安全性。</p>
<p>可通过下载<a class="link"   href="https://www.iis.net/downloads/microsoft/url-rewrite" >Rewrite插件<i class="fas fa-external-link-alt"></i></a>，然后修改<code>C:\Windows\System32\inetsrv\config\applicationHost.config</code>配置文件来实现，配置必须写在system.webServer节点内。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rewrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">allowedServerVariables</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">&quot;REMOTE_ADDR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">allowedServerVariables</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;<span class="name">outboundRules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">&quot;REMOVE_RESPONSE_SERVER&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">match</span> <span class="attr">serverVariable</span>=<span class="string">&quot;RESPONSE_SERVER&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;.*&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">type</span>=<span class="string">&quot;Rewrite&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">outboundRules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rewrite</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Web应用扫描技术"><a href="#Web应用扫描技术" class="headerlink" title="Web应用扫描技术"></a>Web应用扫描技术</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>主要用于检测Web应用程序中的安全漏洞，如SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等。扫描器会对Web应用的页面、表单、链接等进行分析，发送各种特制的请求来测试应用程序的安全性。</p>
<h3 id="相关工具-3"><a href="#相关工具-3" class="headerlink" title="相关工具"></a>相关工具</h3><p>Acunetix是一款专业的Web应用安全扫描工具，它能够自动检测多种Web漏洞。例如，在扫描一个包含用户登录功能的Web页面时，它可以检测输入框是否容易受到SQL注入攻击，以及登录后的页面是否存在 XSS 漏洞等。</p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="URL参数安全防护"><a href="#URL参数安全防护" class="headerlink" title="URL参数安全防护"></a>URL参数安全防护</h4><p>对所有用户输入进行严格的验证和过滤是防范XSS攻击的关键，当应用程序将用户输入的数据嵌入到HTML页面中时，必须对数据进行适当的编码，确保只接受预期的字符集和格式。</p>
<p>例如，可将请求参数放到Headers中，并按指定的字符集(如ISO8859-1)进行编码。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Login</span>(<span class="params">[FromBody] LoginInput input</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringValues para = <span class="keyword">new</span> StringValues();</span><br><span class="line">    <span class="keyword">if</span> (Request.Headers.TryGetValue(<span class="string">&quot;username&quot;</span>, <span class="keyword">out</span> <span class="keyword">var</span> headerValues) &amp;&amp; headerValues.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        para = headerValues[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound(<span class="string">&quot;参数username不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> strs = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> bytes = Encoding.GetEncoding(<span class="string">&quot;ISO8859-1&quot;</span>).GetBytes(para);</span><br><span class="line">        strs = Encoding.GetEncoding(<span class="string">&quot;ISO8859-1&quot;</span>).GetString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ArgumentException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">$&quot;编码转换异常: <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置Cookie的HTTPOnly属性"><a href="#设置Cookie的HTTPOnly属性" class="headerlink" title="设置Cookie的HTTPOnly属性"></a>设置Cookie的HTTPOnly属性</h4><p>Session和Cookie是两种常用的客户端存储技术，它们在Web开发中用于存储和管理用户状态，以下是二者的区别：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td>存储位置</td>
<td>存储在客户端浏览器中，以键值对的形式存在</td>
<td>存储在服务器端，每个用户会话对应一个唯一的Session对象</td>
</tr>
<tr>
<td>存储方式</td>
<td>通过HTTP响应头发送给客户端，并保存在浏览器中</td>
<td>通过Session ID（通常存储在Cookie中）在服务器端进行标识和存储</td>
</tr>
<tr>
<td>存储容量</td>
<td>4KB</td>
<td>无限制</td>
</tr>
<tr>
<td>安全性</td>
<td>容易受到XSS和CSRF等攻击，可以通过设置HttpOnly、Secure和SameSite属性来提高安全性</td>
<td>存储在服务器端，相对来说更安全，但也需要注意Session劫持和修复等安全问题</td>
</tr>
<tr>
<td>生命周期</td>
<td>可以设置过期时间，到期后浏览器会自动删除</td>
<td>依赖于服务器设置的超时时间，用户不活跃超过这个时间后，Session会失效</td>
</tr>
<tr>
<td>跨域问题</td>
<td>可以通过设置Domain属性实现跨域访问</td>
<td>通常与特定的域绑定，不支持跨域访问</td>
</tr>
<tr>
<td>访问方式</td>
<td>可以通过JavaScript的document.cookie属性直接访问和修改</td>
<td>需要通过服务器端代码来访问和修改</td>
</tr>
<tr>
<td>传输</td>
<td>每次HTTP请求都会自动发送到服务器，增加了请求的负载</td>
<td>不需要在每次请求中发送，只在建立Session和通过Session ID获取Session数据时与服务器交互</td>
</tr>
<tr>
<td>用途</td>
<td>常用于保存用户的偏好设置、会话标识等</td>
<td>用于跟踪用户的状态，如登录状态、购物车内容等</td>
</tr>
</tbody></table>
<p>WWW服务依赖于Http协议实现，Http是无状态的协议，所以为了在各个会话之间传递信息，就需要使用Cookie来标记访问者的状态，以便服务器端识别用户信息。Cookie由变量名与值组成，其属性里有标准的cookie变量，也有用户自定义的属性。Cookie保存在浏览器的document对象中，对于存在XSS漏洞的网站，入侵者可以插入简单的XSS语句执行任意的JS脚本，以XSS攻击的手段获取网站其余用户的Cookie。</p>
<p>为了防止用户Cookie被JS脚本恶意读取，可以在服务端设置HTTP - only属性，NET Core下可通过中间件添加到应用程序管道来实现。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HttpOnlyCookieMiddleware.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpOnlyCookieMiddleware</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">HttpOnlyCookieMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         _next = next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 在响应发送之前设置Cookie选项</span></span><br><span class="line">         context.Response.OnStarting(() =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">var</span> cookies = context.Response.Cookies;</span><br><span class="line">             <span class="keyword">var</span> options = <span class="keyword">new</span> CookieOptions</span><br><span class="line">             &#123;</span><br><span class="line">                 HttpOnly = <span class="literal">true</span></span><br><span class="line">             &#125;;</span><br><span class="line">             <span class="keyword">var</span> authToken = context.Request.Cookies[<span class="string">&quot;AuthToken&quot;</span>];</span><br><span class="line">             <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(authToken))</span><br><span class="line">             &#123;</span><br><span class="line">                 cookies.Append(<span class="string">&quot;AuthToken&quot;</span>, authToken, options);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="keyword">await</span> _next(context);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HttpOnlyCookieMiddlewareExtensions</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">UseHttpOnlyCookieMiddleware</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder builder</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> builder.UseMiddleware&lt;HttpOnlyCookieMiddleware&gt;();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Startup.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    app.UseHttpOnlyCookieMiddleware();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://www.toolhelper.cn/EncodeDecode/EncodeDecode" >字符串编码和解码在线工具<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/iis/get-started/planning-your-iis-architecture/introduction-to-applicationhostconfig" >ApplicationHost.config简介<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/aspnet/core/migration/http-modules" >.NET Core中间件使用参考<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Cyber-Security</category>
      </categories>
      <tags>
        <tag>Security-Scan</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server常用SQL、T-SQL语句</title>
    <url>/Hexo-Blog/2024/12/04/sqlserver-usage/</url>
    <content><![CDATA[<p>SQL Server数据库的适用场景，以及一些常用SQL、T-SQL语句。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Microsoft SQL Server(又称 MS SQL)是一种关系数据库管理系统(RDBMS)。应用程序和工具连接到SQL Server实例或数据库，并使用Transact-SQL(T-SQL)进行通信。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>与MySQL相比，SQL Server数据库有以下优势：</p>
<ul>
<li>高可用性解决方案：SQL Server提供了一套成熟的高可用性解决方案，如Always - On可用性组。它允许数据库管理员在不同的服务器之间配置数据库副本，实现自动故障转移。</li>
<li>强大的查询优化器：SQL Server拥有一个先进的查询优化器，它能够根据查询的复杂程度、数据分布以及索引情况自动生成高效的执行计划。例如，在处理包含多个表连接、子查询和复杂条件的大型企业级查询时，SQL Server的查询优化器能够通过多种优化策略（如选择合适的连接算法、索引使用等）来减少查询响应时间。</li>
<li>集成的身份认证和权限管理：SQL Server支持Windows身份认证和SQL Server身份认证两种方式。在企业环境中，Windows身份认证可以与企业的活动目录集成，方便用户管理和权限控制。</li>
<li>数据加密功能：SQL Server提供了透明数据加密（TDE）功能，可以对整个数据库进行加密，包括数据文件和日志文件。这在数据存储和传输过程中，有效保护了数据的安全性。</li>
<li>与.NET集成：SQL Server与.NET 框架配合紧密，通过ADO.NET等技术，开发人员可以轻松地在各种.NET应用程序中访问和操作数据库。这种紧密的集成使得企业在构建基于微软技术栈的应用系统时，选择SQL Server能够减少技术整合的复杂性。</li>
</ul>
<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>.NET项目配置文件中数据库连接字符串如下，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;SqlserverConnection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Data Source=DESKTOP-Q4ORSFH\\SQLEXPRESS;Initial Catalog=your-database;Persist Security Info=True;User ID=sa;Password=your-password&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>备注：SQL Server默认监听的端口号为1433，因此连接字符串可以不指定端口号</p>
<h3 id="GUI方式"><a href="#GUI方式" class="headerlink" title="GUI方式"></a>GUI方式</h3><p>SQL Server Management Studio（SSMS）是微软为SQL Server数据库提供的一款功能强大、集成度高的管理工具。以免费版为例，选择SQL Server身份认证方式登录，默认登录名为sa。</p>
<h3 id="CLI方式"><a href="#CLI方式" class="headerlink" title="CLI方式"></a>CLI方式</h3><p>sqlcmd是SQL Server自带的命令行工具，它允许用户在命令提示符或批处理文件中执行T-SQL语句和脚本。通过sqlcmd可以连接到本地或远程的SQL Server实例，执行数据库操作，如查询数据、创建数据库对象、执行存储过程等。</p>
<p>以SQL Server身份认证方式连接到数据库，</p>
<p><code>sqlcmd -S localhost -U sa -P your-password -d your-database</code></p>
<p>以Windows身份认证方式连接到数据库，</p>
<p><code>sqlcmd -S localhost -E -d your-database</code> </p>
<p><code>sqlcmd -S localhost -T -d your-database</code></p>
<h2 id="T-SQL"><a href="#T-SQL" class="headerlink" title="T-SQL"></a>T-SQL</h2><p>T - SQL（Transact - SQL）是微软为SQL Server数据库管理系统开发的一种编程语言。它是SQL的扩展，用于在SQL Server环境中进行数据定义、数据操纵、数据控制以及事务处理等操作。T - SQL不仅包含了标准SQL的命令，还增加了许多用于增强功能和编程便利性的扩展语法。</p>
<h3 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h3><h4 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h4><p>创建数据库表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [dbo].[table_name] (</span><br><span class="line">    Id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    [column_name] <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h4><p>在表中添加新的列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">ADD</span> [column_name] <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h4 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [dbo].[table_name];</span><br></pre></td></tr></table></figure>

<h3 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h3><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p>在表中插入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [dbo].[table_name] ([column_name]) <span class="keyword">VALUES</span> (<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><p>更新表中数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">SET</span> [column_name] <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [dbo].[table_name]</span><br></pre></td></tr></table></figure>

<h3 id="数据查询语言（DQL）"><a href="#数据查询语言（DQL）" class="headerlink" title="数据查询语言（DQL）"></a>数据查询语言（DQL）</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [column_name] <span class="keyword">FROM</span> [dbo].[table_name]</span><br></pre></td></tr></table></figure>

<h3 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h3><h4 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="用户权限管理"></a>用户权限管理</h4><p>授予用户查询权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> [dbo].[table_name] <span class="keyword">TO</span> [user_name];</span><br></pre></td></tr></table></figure>

<p>撤销用户查询权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> [dbo].[table_name] <span class="keyword">TO</span> [user_name];</span><br></pre></td></tr></table></figure>

<h4 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h4><p>可以使用BEGIN TRANSACTION、COMMIT TRANSACTION和ROLLBACK TRANSACTION语句来控制事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">SET</span> [column_name] <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [dbo].[table_name]</span><br><span class="line"><span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION;</span><br></pre></td></tr></table></figure>

<h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>T - SQL支持存储过程的创建和调用。存储过程是一组预编译的T - SQLx语句，可以在数据库中存储并反复调用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [dbo].[GetAllInfos]</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> [dbo].[table_name];</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">EXEC</span> [dbo].[GetAllInfos];</span><br></pre></td></tr></table></figure>

<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>用户自定义函数可以返回一个值，并且可以在查询语句中使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> [dbo].[AddNumbers](<span class="variable">@num1</span> <span class="type">INT</span>, <span class="variable">@num2</span> <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="variable">@num1</span> <span class="operator">+</span> <span class="variable">@num2</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行函数</span></span><br><span class="line"><span class="keyword">SELECT</span> [dbo].[AddNumbers](<span class="number">3</span>, <span class="number">5</span>) <span class="keyword">AS</span> <span class="keyword">Result</span>;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>T - SQL 包含多种流程控制语句，用于编写复杂的程序逻辑。</p>
<h4 id="IF-ELSE"><a href="#IF-ELSE" class="headerlink" title="IF ELSE"></a>IF ELSE</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@Variable</span> <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@Variable</span> <span class="operator">=</span> [column_name] <span class="keyword">FROM</span> [dbo].[table_name] <span class="keyword">WHERE</span> Id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">IF <span class="variable">@Variable</span> <span class="operator">&gt;</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h4 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@Index</span> <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@Index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">WHILE <span class="variable">@Index</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 执行一些更新操作</span></span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@Index</span> <span class="operator">=</span> <span class="variable">@Index</span> <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/sql/sql-server" >SQL Server官方中文文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/sql/tools/sqlcmd/sqlcmd-utility" >sqlcmd使用参考<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>SQL Server</tag>
      </tags>
  </entry>
  <entry>
    <title>常用UML图特点及应用场景</title>
    <url>/Hexo-Blog/2025/06/12/uml-diagrams/</url>
    <content><![CDATA[<p>常用UML图类型介绍，以及不同UML图的特点及用法。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>UML(Unified Modeling Language)统一建模语言，又称标准建模语言。是用来对软件密集系统进行可视化建模的一种语言。UML的定义包括UML语义和UML表示法两个元素。</p>
<p>UML是在开发阶段，说明、可视化、构建和书写一个面向对象软件密集系统的制品的开放方法。最佳的应用是工程实践，对大规模，复杂系统进行建模方面，特别是在软件架构层次，已经被验证有效。统一建模语言(UML)是一种模型化语言。模型大多以图表的方式表现出来。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。这些虽简单却非常重要，在UML规则中相互联系和扩展。</p>
<h2 id="UML的特点及应用场景"><a href="#UML的特点及应用场景" class="headerlink" title="UML的特点及应用场景"></a>UML的特点及应用场景</h2><p>UML具有以下特点：</p>
<ul>
<li><p>UML统一了各种方法对不同类型的系统、不同开发阶段以及不同内部概念的不同观点，从而有效的消除了各种建模语言之间不必要的差异。它实际上是一种通用的建模语言，可以为许多面向对象建模方法的用户广泛使用。</p>
</li>
<li><p>UML建模能力比其它面向对象建模方法更强。它不仅适合于一般系统的开发，而且对并行、分布式系统的建模尤为适宜。</p>
</li>
<li><p>UML是一种建模语言，而不是一个开发过程。</p>
</li>
</ul>
<p>UML的目标是以面向对象图的方式来描述任何类型的系统，具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML是一个通用的标准建模语言，可以对任何具有静态结构和动态行为的系统进行建模，而且适用于系统开发的不同阶段，从需求规格描述直至系统完成后的测试和维护。</p>
<h2 id="UML图类型"><a href="#UML图类型" class="headerlink" title="UML图类型"></a>UML图类型</h2><h3 id="结构行为图"><a href="#结构行为图" class="headerlink" title="结构行为图"></a>结构行为图</h3><h4 id="用例图-use-case-diagram"><a href="#用例图-use-case-diagram" class="headerlink" title="用例图(use case diagram)"></a>用例图(use case diagram)</h4><p>用例图捕捉了模拟系统中的动态行为，并且描述了用户、需求以及系统功能单元之间的关系，展示了一个外部用户能够观察到的系统功能模型图。用例图由主角，用例和它们之间的关系组成。</p>
<p>用例图的目的是捕捉到一个系统的动态方面，获取系统的外观图。用例图通常用来收集系统的要求，包括内部和外部的影响。这些要求大多是设计要求。所以，分析一个系统时要收集其功能用例和确定参与者。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>下面是一个用例图示例，代表订单管理系统。图中使用了三个用例(订单、特殊订单和正常订单)和一个参与者(顾客)。另外很重要的一点是确定系统边界，用例位于系统边界内，行为者位于系统边界外。关联线显示了用例和行为者之间的关系。</p>
<img   src="/Hexo-Blog/2025/06/12/uml-diagrams/use_case_diagram.png"  class="" title="用例图示例">

<h4 id="对象模型图-object-model-diagram"><a href="#对象模型图-object-model-diagram" class="headerlink" title="对象模型图(object model diagram)"></a>对象模型图(object model diagram)</h4><p>对象模型图(OMDS)指定了系统中类的结构和静态关系。对象模型图包含类图和对象图。如UML中所规定，它们显示了系统中的类、对象、接口和属性，以及它们之间的静态关系。</p>
<h5 id="类图-class-diagram"><a href="#类图-class-diagram" class="headerlink" title="类图(class diagram)"></a>类图(class diagram)</h5><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图不仅用于可视化描述和记录系统的不同方面，也为构建可执行代码的软件应用程序。<br>类图描述一类的属性和操作，也对系统的约束。被广泛应用于类图的建模的面向对象的系统中，因为它们是唯一的，可以直接映射到面向对象语言的UML图。</p>
<p>在UML类图中，常见的有以下几种关系: 泛化(Generalization), 实现(Realization)，关联(Association)，聚合(Aggregation)，组合(Composition)，依赖(Dependency)。<br>各种关系的强弱顺序： 泛化 &#x3D; 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
<ul>
<li>泛化是一种继承关系，表示一般与特殊的关系，它指定了子类如何继承父类的所有特征和行为。<strong>泛化使用带空心三角箭头的实线表示</strong>。</li>
<li>实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。<strong>实现使用带空心三角箭头的虚线表示</strong>。</li>
<li>关联是一种拥有的关系，它使一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。<strong>双向的关联使用一根实线或者带双向箭头的实线表示，单向的关联使用一根带单向箭头的实线表示</strong>。</li>
<li>聚合是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<strong>聚合使用带空心菱形箭头的实线表示</strong>。</li>
<li>组合是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。<strong>组合使用带实心菱形箭头的实线表示</strong>。</li>
<li>依赖是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖。<strong>依赖使用带箭头的虚线表示</strong>。</li>
</ul>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/class_diagram_complex.png"  class="" title="复杂类图示例">

<h5 id="对象图-object-diagram"><a href="#对象图-object-diagram" class="headerlink" title="对象图(object diagram)"></a>对象图(object diagram)</h5><p>对象图和类图一样反映系统的静态过程，但它是从实际的或原型化的情景来表达的。对象图显示某时刻对象和对象之间的关系，可看成一个类图的特殊用例，实例和类可在其中显示。<br>对象图是类图的实例，几乎使用与类图完全相同的标识。由于对象存在生命周期，因此对象图只能在系统某一时间段存在。</p>
<h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><p>假设一个订单管理系统的类图如下。</p>
<img   src="/Hexo-Blog/2025/06/12/uml-diagrams/class_diagram_simple.png"  class="" title="简单类图示例">

<p>其某一时刻对应的对象图如下。</p>
<img   src="/Hexo-Blog/2025/06/12/uml-diagrams/object_diagram.png"  class="" title="对象图示例">

<h4 id="组件图-component-diagram"><a href="#组件图-component-diagram" class="headerlink" title="组件图(component diagram)"></a>组件图(component diagram)</h4><p>组件图又称为组件图，由组件、接口和组件之间联系构成，他描述的是在软件系统中遵从并实现一组接口的物理的、可替换的软件模块。<br>组件图是用来表示系统中组件与组件之间，类或接口与组件之间的关系图。其中，组件之间的关系表现为依赖关系，定义的类或接口与类之间的关系表现为依赖关系或实现关系。<br>组件图的组成元素: 组件、接口、关系、端口、连接器。</p>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/component_diagram.png"  class="" title="组件图示例">

<h4 id="部署图-deployment-diagram"><a href="#部署图-deployment-diagram" class="headerlink" title="部署图(deployment diagram)"></a>部署图(deployment diagram)</h4><p>部署图由节点以及节点之间的关系组成，描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。部署图通常用来帮助理解分布式系统，一个系统模型只有一个部署图。</p>
<p>部署图与组件图密切相关，部署图是用来描述软件组件部署的硬件组件；而组件图是用来描述组件和显示了它们是如何在硬件中部署。</p>
<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/deployment_diagram.png"  class="" title="部署图示例">

<h3 id="动态行为图"><a href="#动态行为图" class="headerlink" title="动态行为图"></a>动态行为图</h3><h4 id="交互图-interaction-diagram"><a href="#交互图-interaction-diagram" class="headerlink" title="交互图(interaction diagram)"></a>交互图(interaction diagram)</h4><h5 id="序列图-sequence-diagram"><a href="#序列图-sequence-diagram" class="headerlink" title="序列图(sequence diagram)"></a>序列图(sequence diagram)</h5><p>序列图又称时序图，是交互图的一种。它通过描写叙述对象之间发送消息的时间顺序，显示多个对象之间的动态协作。它能够表示用例的行为顺序，当运行一个用例行为时，序列图中的每条消息响应了一个类操作或状态机中引起转换的触发事件。<br>序列图展示对象之间的交互，这些交互是指在场景或用例的时间流中发生的，序列图属于动态建模。序列图的重点在消息序列上，也就是说，描写叙述消息是怎样在对象间发送和接收的，表示对象之间传送消息的时间顺序。<br>序列图的组成元素：对象、生命线、激活、消息。</p>
<h6 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h6><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/sequence_diagram.png"  class="" title="序列图示例">

<h5 id="协作图-collaboration-diagram"><a href="#协作图-collaboration-diagram" class="headerlink" title="协作图(collaboration diagram)"></a>协作图(collaboration diagram)</h5><p>协作图，与序列图类似，显示对象、它们的消息以及它们在特定场景或用例中的关系。序列图强调消息流，可以指示发送或接收的消息的时间顺序，而协作图强调对象之间的关系。</p>
<p>协作图显示了通过关联角色传递的消息。消息通常是类操作的实例，它们被编号以表示顺序，也可以用子编号(例如，la.，1b.，1.1.2,1.1.3,2.3a.1.，2.3a.2.，等等)以表示同时发生的任务或实现更大任务的子任务。</p>
<h6 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h6><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/collaboration_diagram.png"  class="" title="协作图示例">

<h4 id="状态图-statechart-diagram"><a href="#状态图-statechart-diagram" class="headerlink" title="状态图(statechart diagram)"></a>状态图(statechart diagram)</h4><p>状态图是对类图的补充。状态图描述了一个实体基于事件反映的动态行为，显示了该实体是如何根据当前所处的状态对不同的事件作出反应的。<br>一个状态图应该连接到所有具有清晰的可标志状态和复杂行为的类。状态图可以确定类的行为以及该行为如何根据当前的状态而变化，也可以展示哪些事件将会改变类的对象的状态。<br>状态图可以捕获对象、子系统和系统的生命周期，可以告知一个对象可以拥有的状态，并且事件(如消息的接收，时间的流逝、错误、条件为真等)会怎样随着时间的推移来影响这些状态。状态图主要是为了模拟响应系统。</p>
<p>一个状态图本质上就是一个状态机，或者是状态机的特殊情况，它基本上是一个状态机中元素的一个投影，这也就意味着状态图包括状态机的所有特征。<br>在UML中，状态图由表示状态的节点和表示状态之间转换的带箭头的直线组成。状态的转换由事件触发，状态和状态之间由转换箭头连接。每一个状态图都有一个初始状态（实心圆），用来表示状态机的开始。还有一个中止状态（半实心圆），用来表示状态机的终止。<br>状态图主要由元素状态、转换、初始状态、中止状态和判定等组成。</p>
<h5 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/statechart_diagram.png"  class="" title="状态图示例">

<h4 id="活动图-activity-diagram"><a href="#活动图-activity-diagram" class="headerlink" title="活动图(activity diagram)"></a>活动图(activity diagram)</h4><p>活动图是一种特殊的状态图，它对于系统的功能建模特别重要，强调对象间的控制流程。与状态图不同，当行为不是由事件驱动时，活动图更为合适。</p>
<p>一个类(用例&#x2F;操作)可以有一个活动图或一个状态图，但不能同时拥有两者。然而，一个类、对象或用例可能有一个以上的活动图，其中一个图被指定为主要行为。</p>
<h5 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h5><img   src="/Hexo-Blog/2025/06/12/uml-diagrams/activity_diagram.png"  class="" title="活动图示例">

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://www.w3cschool.cn/uml_tutorial/uml_tutorial-c1gf28pd.html" >UML概述中文版<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.tutorialspoint.com/uml/uml_overview.htm" >UML概述英文版<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Service远程调用技术</title>
    <url>/Hexo-Blog/2024/08/18/web-service-and-rpc/</url>
    <content><![CDATA[<p>Web Service远程调用技术(RPC)的基本概念及实现方式。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web Service即web服务，是一种跨编程语言和跨操作系统平台的远程调用技术。Web服务包含了一套标准,例如HTTP、XML、SOAP、WSDL、UDDI等，定义了应用程序如何在Web上实现互操作，可以在任何支持这些标准的平台（如Windows、Linux）中使用。</p>
<p>Web Service与Web API相比，更加适合端到端的应用场景(C&#x2F;S架构)，适合作为内部服务使用。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><p>SOAP即简单对象访问协议(Simple Object Access Protocol)，是Web Service的通信协议，基于XML文件并绑定在HTTP协议上传递。SOAP消息包括Envelope、Header和Body元素。</p>
<p>一条SOAP消息就是一个普通的XML文档，文档包括下列元素：</p>
<ul>
<li>Envelope元素，必选，可把此XML文档标识为一条SOAP消息</li>
<li>Header元素，可选，包含头部信息</li>
<li>Body元素，必选，包含所有的调用和响应信息</li>
</ul>
<p>目前WebSerivce的协议主要有SOAP1.1与SOAP1.2，二者的区别如下：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>SOAP1.1</th>
<th>SOAP1.2</th>
</tr>
</thead>
<tbody><tr>
<td>命名空间</td>
<td><code>http://schemas.xmlsoap.org/soap/envelope/</code></td>
<td><code>http://www.w3.org/2003/05/soap-envelope</code></td>
</tr>
<tr>
<td>请求与响应</td>
<td>请求头包含SOAPAction，且请求与响应的Content-Type为text&#x2F;xml，以soap作为前缀</td>
<td>请求头不包含SOAPAction，且请求与响应的Content-Type为application&#x2F;soap+xml，以soap12作为前缀</td>
</tr>
<tr>
<td>错误处理</td>
<td>使用SOAP Fault元素，包含faultcode, faultstring, faultactor, detail</td>
<td>使用Code和Reason元素，提供更结构化的错误信息</td>
</tr>
<tr>
<td>协议绑定</td>
<td>主要支持HTTP绑定</td>
<td>支持更多协议绑定，如SMTP、FTP等</td>
</tr>
<tr>
<td>数据模型</td>
<td>数据模型较为简单</td>
<td>引入了更复杂的数据模型，支持更多数据类型和编码方式</td>
</tr>
<tr>
<td>处理规则</td>
<td>处理规则较为宽松</td>
<td>处理规则更严格，要求必须忽略未知的SOAP头元素</td>
</tr>
<tr>
<td>规范文档</td>
<td>由W3C提交，非正式推荐标准</td>
<td>由W3C正式推荐，文档更详细</td>
</tr>
<tr>
<td>扩展性</td>
<td>扩展性有限</td>
<td>扩展性更强，支持更多扩展机制</td>
</tr>
<tr>
<td>安全性</td>
<td>安全性较弱</td>
<td>安全性增强，支持更多安全机制</td>
</tr>
<tr>
<td>兼容性</td>
<td>兼容性较好，广泛支持</td>
<td>兼容性稍差，部分旧系统可能不支持</td>
</tr>
</tbody></table>
<h3 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h3><p>Web Service描述语言(WebService Definition Language，简称WSDL)就是用机器能阅读的方式提供的一个正式描述文档而基于XML的语言，用于描述Web Service及其函数、参数和返回值。</p>
<p>在WSDL说明书中，描述了</p>
<ul>
<li>对外发布的服务名称（类）</li>
<li>接口方法名称（方法）</li>
<li>接口参数（方法参数）</li>
<li>​服务返回的数据类型（方法返回值）</li>
</ul>
<p>WSDL目前有1.1和2.0两个版本，它们在语法、结构和功能上有显著差异，二者的区别如下：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>WSDL1.1</th>
<th>WSDL2.0</th>
</tr>
</thead>
<tbody><tr>
<td>命名空间</td>
<td><code>http://schemas.xmlsoap.org/wsdl/</code></td>
<td><code>http://www.w3.org/ns/wsdl</code></td>
</tr>
<tr>
<td>文档结构</td>
<td>根元素为<code>&lt;wsdl:definitions&gt;</code>，主要部分包括<code>&lt;wsdl:types&gt;</code>、<code>&lt;wsdl:message&gt;</code>、<code>&lt;wsdl:portType&gt;</code>、<code>&lt;wsdl:binding&gt;</code>、<code>&lt;wsdl:service&gt;</code></td>
<td>根元素为<code>&lt;wsdl:description&gt;</code>，使用<code>&lt;wsdl:interface&gt;</code>替代<code>&lt;wsdl:portType&gt;</code></td>
</tr>
<tr>
<td>操作定义</td>
<td>使用<code>&lt;wsdl:portType&gt;</code>定义操作，操作类型包括One-way、Request-response、Solicit-response、Notification</td>
<td>使用<code>&lt;wsdl:interface&gt;</code>定义操作，操作类型包括One-way、Request-response、Robust In-only、In-out</td>
</tr>
<tr>
<td>消息定义</td>
<td>使用<code>&lt;wsdl:message&gt;</code>定义消息，消息由<code>&lt;wsdl:part&gt;</code>组成，每个部分可以引用类型或元素</td>
<td>取消了 <code>&lt;wsdl:message&gt;</code>和<code>&lt;wsdl:part&gt;</code>，直接在操作中定义输入和输出消息的类型</td>
</tr>
<tr>
<td>绑定支持</td>
<td>主要支持SOAP1.1绑定，支持HTTP GET&#x2F;POST和MIME绑定，但使用较少</td>
<td>支持SOAP1.1和SOAP1.2绑定，增强了对HTTP GET&#x2F;POST和MIME绑定的支持，支持更多协议绑定（如JMS、SMTP等）</td>
</tr>
<tr>
<td>错误处理</td>
<td>错误处理依赖于SOAP的Fault消息</td>
<td>引入了<code>&lt;wsdl:fault&gt;</code>元素，直接在操作中定义错误消息</td>
</tr>
<tr>
<td>模块化</td>
<td>模块化支持较弱，主要通过<code>&lt;wsdl:import&gt;</code>引入外部WSDL或XSD文件</td>
<td>增强了模块化支持，允许更灵活地组合和重用 WSDL文档</td>
</tr>
<tr>
<td>扩展性</td>
<td>扩展性较差，主要通过<code>&lt;wsdl:documentation&gt;</code>和<code>&lt;wsdl:extensibility&gt;</code>实现</td>
<td>增强了扩展性，支持更多的自定义元素和属性</td>
</tr>
<tr>
<td>标准化</td>
<td>未被正式标准化，但被广泛使用</td>
<td>是WSDL1.1的改进和标准化版本</td>
</tr>
</tbody></table>
<h3 id="UDDI"><a href="#UDDI" class="headerlink" title="UDDI"></a>UDDI</h3><p>UDDI(Universal Description，Discovery and Integration)，也就是通用的描述、发现以及整合，是一套基于Web的、分布式的、为WebService提供的、信息注册中心的实现标准规范。用户可以通过UDDI来注册和搜索Web服务。</p>
<h2 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h2><p>面向服务架构(Service Oriented Architecture，简称SOA)，是一个组件模型，它将应用程序的不同功能单元(服务)通过预先定义的接口和契约联系起来。接口是采用中立的方式进行定义的，独立于实现服务的硬件平台、操作系统和编程语言，构建在系统中的服务以一种统一和通用的方式进行交互。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>注: 以下项目基于.NET Framework，.NET中无法使用</p>
<h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>使用ASP.NET Web应用程序(.NET Framework)创建一个Web服务(asmx文件)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Web.Services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplicationDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">WebService(Namespace = <span class="string">&quot;http://tempuri.org/&quot;</span>)</span>] <span class="comment">// 定义命名空间</span></span><br><span class="line">    [<span class="meta">WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)</span>] <span class="comment">// 绑定规范</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebServiceTest</span> : <span class="title">WebService</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">WebMethod(Description = <span class="string">&quot;测试方法&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h2><h3 id="静态引用"><a href="#静态引用" class="headerlink" title="静态引用"></a>静态引用</h3><p>根据提供的Web Service地址，通过Connected Services添加WCF Web服务引用，生成cs文件，然后直接调用。</p>
<p>以下是在控制台程序以及ASP.NET Web API项目中的调用方式。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WebServiceTestSoapClient client = <span class="keyword">new</span> WebServiceTestSoapClient();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = client.SumAsync(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(res.Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/Test&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Get</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建 HTTP 绑定对象</span></span><br><span class="line">        <span class="keyword">var</span> binding = <span class="keyword">new</span> BasicHttpBinding();</span><br><span class="line">        <span class="comment">//根据 WebService 的 URL 构建终端点对象，参数是提供的WebService地址</span></span><br><span class="line">        <span class="keyword">var</span> endpoint = <span class="keyword">new</span> EndpointAddress(<span class="string">@&quot;http://localhost:8083/WebServiceTest.asmx&quot;</span>);</span><br><span class="line">        <span class="comment">//创建调用接口的工厂，注意这里泛型只能传入接口 泛型接口里面的参数是WebService里面定义的类名+Soap</span></span><br><span class="line">        <span class="keyword">var</span> factory = <span class="keyword">new</span> ChannelFactory&lt;WebServiceTestSoap&gt;(binding, endpoint);</span><br><span class="line">        <span class="comment">//从工厂获取具体的调用实例</span></span><br><span class="line">        <span class="keyword">var</span> callClient = factory.CreateChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> task = callClient.SumAsync(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">var</span> res = task.Result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;WebService中Sum方法返回结果为<span class="subst">&#123;res&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h3><p>将Web Service地址存放到配置文件中，通过读取地址生成代理类，动态在项目中生成代理类文件，然后通过反射调用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> res = (<span class="built_in">int</span>)WebServiceProxy.InvokeWebService(<span class="string">&quot;https://localhost:44319/WebServiceTest.asmx&quot;</span>, <span class="string">&quot;WebServiceTest&quot;</span>, <span class="string">&quot;Sum&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 反射代理类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebServiceProxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">InvokeWebService</span>(<span class="params"><span class="built_in">string</span> url,<span class="built_in">string</span> ns, <span class="built_in">string</span> methodname, <span class="built_in">object</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取WSDL</span></span><br><span class="line">            WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">            Stream stream = wc.OpenRead(url + <span class="string">&quot;?WSDL&quot;</span>);</span><br><span class="line">            ServiceDescription sd = ServiceDescription.Read(stream);</span><br><span class="line">            <span class="built_in">string</span> classname = sd.Services[<span class="number">0</span>].Name;</span><br><span class="line">            ServiceDescriptionImporter sdi = <span class="keyword">new</span> ServiceDescriptionImporter();</span><br><span class="line">            sdi.AddServiceDescription(sd, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            CodeNamespace cn = <span class="keyword">new</span> CodeNamespace(ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成客户端代理类代码</span></span><br><span class="line">            CodeCompileUnit ccu = <span class="keyword">new</span> CodeCompileUnit();</span><br><span class="line">            ccu.Namespaces.Add(cn);</span><br><span class="line">            sdi.Import(cn, ccu);</span><br><span class="line">            CSharpCodeProvider csc = <span class="keyword">new</span> CSharpCodeProvider();</span><br><span class="line">            ICodeCompiler icc = csc.CreateCompiler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设定编译参数</span></span><br><span class="line">            CompilerParameters cplist = <span class="keyword">new</span> CompilerParameters();</span><br><span class="line">            cplist.GenerateExecutable = <span class="literal">false</span>;</span><br><span class="line">            cplist.GenerateInMemory = <span class="literal">true</span>;</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.XML.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.Web.Services.dll&quot;</span>);</span><br><span class="line">            cplist.ReferencedAssemblies.Add(<span class="string">&quot;System.Data.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//编译代理类</span></span><br><span class="line">            CompilerResults cr = icc.CompileAssemblyFromDom(cplist, ccu);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">true</span> == cr.Errors.HasErrors)</span><br><span class="line">            &#123;</span><br><span class="line">                System.Text.StringBuilder sb = <span class="keyword">new</span> System.Text.StringBuilder();</span><br><span class="line">                <span class="keyword">foreach</span> (System.CodeDom.Compiler.CompilerError ce <span class="keyword">in</span> cr.Errors)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.Append(ce.ToString());</span><br><span class="line">                    sb.Append(System.Environment.NewLine);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(sb.ToString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成代理实例，并调用方法</span></span><br><span class="line">            System.Reflection.Assembly assembly = cr.CompiledAssembly;</span><br><span class="line">            Type t = assembly.GetType(ns + <span class="string">&quot;.&quot;</span> + classname, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">object</span> obj = Activator.CreateInstance(t);</span><br><span class="line">            System.Reflection.MethodInfo mi = t.GetMethod(methodname);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mi.Invoke(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用HTTP方式调用"><a href="#使用HTTP方式调用" class="headerlink" title="使用HTTP方式调用"></a>使用HTTP方式调用</h3><p>Web Service还可以使用HTTP方式，通过发送SOAP请求体进行调用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> webServiceUri = <span class="string">&quot;http://localhost:8083/WebServiceTest.asmx&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> soapRequest = <span class="string">@&quot;&lt;?xml version=&quot;&quot;1.0&quot;&quot; encoding=&quot;&quot;utf-8&quot;&quot;?&gt;</span></span><br><span class="line"><span class="string">                              &lt;soap:Envelope xmlns:xsi=&quot;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&quot; xmlns:xsd=&quot;&quot;http://www.w3.org/2001/XMLSchema&quot;&quot; xmlns:soap=&quot;&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">                                &lt;soap:Body&gt;</span></span><br><span class="line"><span class="string">                                  &lt;Sum xmlns=&quot;&quot;http://tempuri.org/&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">                                    &lt;a&gt;1&lt;/a&gt;</span></span><br><span class="line"><span class="string">                                    &lt;b&gt;2&lt;/b&gt;</span></span><br><span class="line"><span class="string">                                  &lt;/Sum&gt;</span></span><br><span class="line"><span class="string">                                &lt;/soap:Body&gt;</span></span><br><span class="line"><span class="string">                              &lt;/soap:Envelope&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// var request = new HttpRequestMessage(HttpMethod.Post, &quot;http://localhost:8083/WebServiceTest.asmx&quot;);</span></span><br><span class="line">        <span class="comment">// request.Headers.Add(&quot;SOAPAction&quot;, &quot;\&quot;http://tempuri.org/Sum\&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// request.Content = new StringContent(soapRequest, Encoding.UTF8, &quot;text/xml&quot;);</span></span><br><span class="line">        <span class="comment">// HttpResponseMessage response = client.SendAsync(request).Result;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> content = <span class="keyword">new</span> StringContent(soapRequest, Encoding.UTF8, <span class="string">&quot;text/xml&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> response =  client.PostAsync(webServiceUri, content).Result;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> responseContent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">        &#123;</span><br><span class="line">            responseContent = response.Content.ReadAsStringAsync().Result;</span><br><span class="line">            <span class="comment">// 解析XML响应</span></span><br><span class="line">            XDocument xmlResponse = XDocument.Parse(responseContent);</span><br><span class="line">            <span class="comment">// 处理XML</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;xmlResponse&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Error: <span class="subst">&#123;response.StatusCode&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求返回的soap消息如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:soap</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SumResponse</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tempuri.org/&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">SumResult</span>&gt;</span>3<span class="tag">&lt;/<span class="name">SumResult</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">SumResponse</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="soap消息解析"><a href="#soap消息解析" class="headerlink" title="soap消息解析"></a>soap消息解析</h4><p>假设返回的soap消息包含xml数据如下，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:soap</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">getMqResponse</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tempuri.org/&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">getMqResult</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maindata</span> <span class="attr">table</span>=<span class="string">&quot;person&quot;</span> <span class="attr">disid</span>=<span class="string">&quot;1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">item</span> <span class="attr">opeType</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">idno</span>&gt;</span>1001<span class="tag">&lt;/<span class="name">idno</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">maindata</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">getMqResult</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">getMqResponse</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想要解析带命名空间的xml并获取其中某些节点的属性值和内容，则需要使用命名空间管理器。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载SOAP响应的XML数据</span></span><br><span class="line">XmlDocument xmlDoc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">xmlDoc.LoadXml(soapResponse);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建命名空间管理器，并添加SOAP命名空间</span></span><br><span class="line">XmlNamespaceManager namespaceManager = <span class="keyword">new</span> XmlNamespaceManager(xmlDoc.NameTable);</span><br><span class="line">namespaceManager.AddNamespace(<span class="string">&quot;soap&quot;</span>, <span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>);</span><br><span class="line">namespaceManager.AddNamespace(<span class="string">&quot;ns&quot;</span>, <span class="string">&quot;http://tempuri.org/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用XPath表达式提取所需的数据</span></span><br><span class="line">XmlNode mainDataNode = xmlDoc.SelectSingleNode(<span class="string">&quot;/soap:Envelope/soap:Body/ns:getMqResponse/ns:getMqResult/maindata&quot;</span>, namespaceManager);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取maindata中disid的属性值</span></span><br><span class="line">XmlElement mainDataElement = (XmlElement)mainDataNode;</span><br><span class="line"><span class="keyword">var</span> disid = mainDataElement.GetAttribute(<span class="string">&quot;disid&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> childNodes = mainDataNode.SelectNodes(<span class="string">&quot;item&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> itemNode <span class="keyword">in</span> childNodes)</span><br><span class="line">&#123;</span><br><span class="line">    XmlElement itemElement = (XmlElement)itemNode;</span><br><span class="line">    <span class="comment">// 获取item中opeType的属性值</span></span><br><span class="line">    <span class="keyword">var</span> opeType = itemElement.GetAttribute(<span class="string">&quot;opeType&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取idno的文本值</span></span><br><span class="line">    <span class="keyword">var</span> idno = itemElement.SelectSingleNode(<span class="string">&quot;idno&quot;</span>).InnerText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="xml字符串转义问题"><a href="#xml字符串转义问题" class="headerlink" title="xml字符串转义问题"></a>xml字符串转义问题</h4><p>在WebService方法返回XML数据的时候，将XML处理成字符串返回，在客户端得到的XML字符串会出现被转义的情况。</p>
<p>将已经为HTTP传输进行过HTML编码的字符串转换为已解码的字符串，可在不改动服务端代码的情况下解决转义问题。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">result = System.Net.WebUtility.HtmlDecode(xmlResponse.ToString());</span><br></pre></td></tr></table></figure>

<p>string类型和XmlDocument类型在WebService序列化过程中的处理方法不同。如果返回可序列化的标准XML对象，可从根本上解决转义问题。</p>
<p>对应的服务端代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">WebMethod(Description = <span class="string">&quot;测试方法&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> System.Xml.<span class="function">XmlDocument <span class="title">GetMainData</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// your xml response</span></span><br><span class="line">    <span class="keyword">var</span> res = <span class="string">@&quot;&lt;maindata&gt;</span></span><br><span class="line"><span class="string">                 &lt;item&gt;&lt;/item&gt;</span></span><br><span class="line"><span class="string">                &lt;/maindata&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.Xml.XmlDocument xmldoc = <span class="keyword">new</span> System.Xml.XmlDocument();</span><br><span class="line">    xmldoc.LoadXml(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xmldoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/?view=netframework-4.8.1" >.NET Framework API参考文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/framework/wcf/" >使用WCF开发面向服务的应用程序<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/dotnet/api/system.net.webutility.htmldecode" >WebUtility.HtmlDecode方法<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Remote-Procedure-Call</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>ASP.NET Core</tag>
        <tag>Web Service</tag>
        <tag>.NET Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket在C#与.NET中的简单实现</title>
    <url>/Hexo-Blog/2024/08/18/websocket-usage/</url>
    <content><![CDATA[<p>WebSocket的基本概念、应用场景，以及服务端和客户端在C#与.NET中的简单实现(包含心跳检测与自动重连)。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，它可以让客户端和服务器之间进行实时的双向通信。WebSocket使用一个长连接，在客户端和服务器之间保持持久的连接，从而可以实时地发送和接收数据。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p>OSI(Open System Interconnect)七层网络模型是一种将计算机网络体系结构按照功能划分为七层的标准模型。</p>
<ul>
<li>应用层(Application Layer)，负责提供应用程序之间的通信服务，使得不同的应用程序可以在网络上进行数据交换和通信。常见协议有HTTP、HTTPS、FTP、POP3、SSH、DNS等。</li>
<li>表示层(Presentation Layer)，负责处理数据在网络上传输时的格式和编码，以确保不同系统之间的数据交换能够有效地进行。常见协议有JPEG、PNG、MP3等。</li>
<li>会话层(Session Layer)，负责建立、管理和终止应用程序之间的会话。常见协议有NetBIOS(网络基本输入&#x2F;输出系统)、RPC等。</li>
<li>传输层(Transport Layer)，负责在不可靠的网络上提供可靠的数据传输服务。常见协议有TCP、UDP、SSL(安全套接层协议)、TLS(传输层安全性协议)等。TCP协议面向连接、可靠，UDP协议无连接、不可靠。</li>
<li>网络层(Network Layer)，负责将数据包从源主机传输到目标主机。常见协议有IP等。</li>
<li>数据链路层(Data Link Layer)，负责将网络层传输过来的数据包进行分帧，并在物理介质上进行传输。常见协议有IEEE802.2(逻辑链路控制标准)、PPP(点对点通信)等。</li>
<li>物理层(Physical Layer)，负责将数字数据转换成物理信号并在网络中传输。常见协议有RS232(串行通信接口标准)、IEEE802.3(以太网标准)等。</li>
</ul>
<h3 id="串口通信与网口通信"><a href="#串口通信与网口通信" class="headerlink" title="串口通信与网口通信"></a>串口通信与网口通信</h3><p>WebSocket有串口、网口两种通信方式。</p>
<ul>
<li><p>串口方式‌主要基于串行接口进行数据传输，采用串口通信协议(如RS232、RS485等)。这种方式适用于点对点的数据传输，使用有限连接，只能连接两台设备，不支持网络中的多台设备之间的通信。串口通信传输速度较慢，传输距离较长，比较稳定，可以确保数据传输的可靠性。</p>
</li>
<li><p>网口方式‌则基于网络通信协议(如TCP&#x2F;IP、UDP等)进行数据传输。这种方式使用无限连接，适用于网络中的多台设备之间的通信。网口通信传输速度较快，传输距离有限。</p>
</li>
</ul>
<h3 id="与TCP和HTTP的关系"><a href="#与TCP和HTTP的关系" class="headerlink" title="与TCP和HTTP的关系"></a>与TCP和HTTP的关系</h3><p>WebSocket协议是独立的基于TCP的协议。它和HTTP的唯一关系是建立连接的握手操作的升级请求是基于HTTP服务器的。</p>
<p>WebSocket默认使用80端口进行连接，而基于TLS(RFC2818)的WebSocket连接是基于443端口的。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>创建一个客户端和服务端的双向数据Web应用(例如IM应用和游戏应用)需要向服务端频繁发送不同于一般HTTP请求的HTTP轮询请求来从服务端上游更新数据，这个方法存在许多问题：</p>
<ul>
<li>服务端被迫使用大量的的潜在的TCP连接与客户端进行交互：一部分是用来发送数据，而另一部分是用来接收数据</li>
<li>应用层无线传输协议(HTTP)开销较大，每一个客户端到服务端的消息都有一个HTTP头</li>
<li>客户端脚本必须包含一个发送和接收对应的映射表来进行对应数据处理</li>
</ul>
<p>一个简单的解决方案是使用一个简单的TCP链接来进行双向数据传输，这就是WebSocket提供的能力。结合WebSocket的API，它能够提供一个可以替代HTTP轮询的方法来满足Web页面和远端服务器的双向数据通信。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h3><p>C#中可以通过System.Net.WebSockets命名空间提供的类来实现WebSocket通信。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>首先创建一个WebSocket服务端类，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketServer</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serverUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpListener _httpListener;</span><br><span class="line">    <span class="keyword">private</span> WebSocket _webSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketServer</span>(<span class="params"><span class="built_in">string</span> serverUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serverUri = serverUri;</span><br><span class="line">        _httpListener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpListener.Prefixes.Add(_serverUri);</span><br><span class="line">        _httpListener.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;WebSocket服务已启动，服务地址：<span class="subst">&#123;_serverUri&#125;</span>，等待客户端连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HttpListenerContext httpContext = <span class="keyword">await</span> _httpListener.GetContextAsync();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (httpContext.Request.IsWebSocketRequest)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> HandleWebSocketConnectionAsync(httpContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                httpContext.Response.StatusCode = <span class="number">400</span>;</span><br><span class="line">                httpContext.Response.Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HandleWebSocketConnectionAsync</span>(<span class="params">HttpListenerContext httpContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WebSocketContext webSocketContext = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            webSocketContext = <span class="keyword">await</span> httpContext.AcceptWebSocketAsync(subProtocol: <span class="literal">null</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;接收到客户端连接，WebSocket连接已建立，等待客户端消息...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            httpContext.Response.StatusCode = <span class="number">500</span>;</span><br><span class="line">            httpContext.Response.Close();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;WebSocket连接失败: &quot;</span> + e.Message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _webSocket = webSocketContext.WebSocket;</span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (_webSocket.State == WebSocketState.Open)</span><br><span class="line">        &#123;</span><br><span class="line">            WebSocketReceiveResult result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="keyword">await</span> _webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket消息接收错误 :&quot;</span> + e.Message);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Close)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, CancellationToken.None);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket连接已关闭!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Text)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理文本消息</span></span><br><span class="line">                <span class="built_in">string</span> message = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;接收到客户端的消息: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">byte</span>[] response = Encoding.UTF8.GetBytes(<span class="string">&quot;服务端已成功收到消息&quot;</span> + message);</span><br><span class="line">                <span class="keyword">await</span> _webSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(response), WebSocketMessageType.Text, <span class="literal">true</span>, CancellationToken.None);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Binary)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理二进制消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _webSocket.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketServer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动WebSocket服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;http://localhost:8181/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketServer = <span class="keyword">new</span> WebSocketServer(serverUri);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketServer.StartAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>首先创建一个WebSocket客户端类，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketClient</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ClientWebSocket _clientWebSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketClient</span>(<span class="params"><span class="built_in">string</span> uri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _uri = uri;</span><br><span class="line">        _clientWebSocket = <span class="keyword">new</span> ClientWebSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _clientWebSocket.ConnectAsync(<span class="keyword">new</span> Uri(_uri), CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WebSocket客户端已连接至：&quot;</span> + _uri);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] messageBytes = Encoding.UTF8.GetBytes(input);</span><br><span class="line">            <span class="keyword">await</span> _clientWebSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(messageBytes), WebSocketMessageType.Text, <span class="literal">true</span>, CancellationToken.None);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;客户端发送消息: &quot;</span> + input);</span><br><span class="line"></span><br><span class="line">            WebSocketReceiveResult result = <span class="keyword">await</span> _clientWebSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">            <span class="built_in">string</span> response = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;客户端接收到消息: &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _clientWebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WebSocket客户端已关闭!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _clientWebSocket.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketServer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动WebSocket客户端。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;http://localhost:8181/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketClient = <span class="keyword">new</span> WebSocketClient(serverUri.Replace(<span class="string">&quot;http&quot;</span>, <span class="string">&quot;ws&quot;</span>)); <span class="comment">// http升级请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketClient.StartAsync(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持WSS"><a href="#支持WSS" class="headerlink" title="支持WSS"></a>支持WSS</h4><p>若要使用WebSocket Secure(WSS)，即在WebSocket上使用TLS&#x2F;SSL加密通信，则需要对服务端和客户端进行一些调整。</p>
<p>首先服务端的uri前缀需要改为https，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;https://localhost:8182/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketServer = <span class="keyword">new</span> WebSocketServer(serverUri);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketServer.StartAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后客户端的http升级请求需要改为https，即从http-ws调整为https-wss，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> serverUri = <span class="string">&quot;https://localhost:8182/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> webSocketClient = <span class="keyword">new</span> WebSocketClient(serverUri.Replace(<span class="string">&quot;https&quot;</span>, <span class="string">&quot;wss&quot;</span>)); <span class="comment">// https升级请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> webSocketClient.StartAsync(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果服务器使用自签名证书(未经过CA认证)，客户端默认会抛出SSL错误，测试环境中可通过在代码中忽略证书验证的方式解决。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketClient</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 忽略自签名证书验证</span></span><br><span class="line">        ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =&gt; <span class="literal">true</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自签名证书可以使用OpenSSL生成，</p>
<p><code>openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes</code></p>
<p>这将生成cert.pem(证书)和key.pem(私钥)，然后使用以下命令将PEM文件转换为PFX文件。(此PFX文件导入后颁发者默认为Internet Widgits Pty Ltd)</p>
<p><code>openssl pkcs12 -export -out certificate.pfx -inkey key.pem -in cert.pem</code></p>
<p>若服务端使用HttpListener，需确保证书已绑定到服务器的端口。例如，在Windows上可以使用netsh命令，(注：IP一般使用通配地址0.0.0.0)</p>
<p><code>netsh http add sslcert ipport=&lt;IP&gt;:&lt;PORT&gt; certhash=&lt;Certificate Thumbprint&gt; appid=&#123;&lt;Application GUID&gt;&#125;</code></p>
<p>证书指纹可通过<code>win+r</code>输入<code>mmc</code>并添加证书单元格后在受信任的根证书颁发机构中查看，也可通过openssl命令获取。(注：通过命令获取到的指纹中的<code>:</code>需要删除，否则绑定时会报参数错误)</p>
<p><code>openssl x509 -in cert.pem -noout -fingerprint</code></p>
<p>可使用netsh命令检查证书是否绑定成功。</p>
<p><code>netsh http show sslcert</code></p>
<h4 id="支持心跳检测与自动重连"><a href="#支持心跳检测与自动重连" class="headerlink" title="支持心跳检测与自动重连"></a>支持心跳检测与自动重连</h4><p>WebSocket心跳检测(Heartbeat)是一种机制，用于确保客户端和服务器之间的连接仍然活跃，并且能够及时检测到任何连接问题。在WebSocket连接中，由于网络不稳定或服务器重启等原因，可能会导致连接意外断开，而双方并不知情。心跳检测通过定期发送小的数据包(如Ping&#x2F;Pong帧)来验证连接是否仍然存在。</p>
<p>在ClientWebSocket中，SendAsync和ReceiveAsync是异步操作，但它们有一个重要的限制：每个操作(SendAsync和ReceiveAsync)在同一时间只能有一个未完成的任务。如果尝试同时发起多个SendAsync或ReceiveAsync调用，就会抛出异常</p>
<blockquote>
<p>There is already one outstanding ‘SendAsync’ call for this WebSocket instance. ReceiveAsync and SendAsync can be called simultaneously, but at most one outstanding operation for each of them is allowed at the same time.</p>
</blockquote>
<p>ClientWebSocket的设计是线程安全的，但它不允许同时发起多个SendAsync或ReceiveAsync操作。如果你在一个线程中调用SendAsync，而在同一个操作完成之前又在另一个线程中调用SendAsync，就会触发上述异常。(ReceiveAsync同理)</p>
<p>在ServerWebSocket的心跳检测中，如果使用异步方式调用SendAsync，可能会导致服务在”Aborted”状态下仍然被用于通信(理论上只有”Open”状态下才应当执行)，从而引发异常</p>
<blockquote>
<p>The ‘System.Net.WebSockets.ServerWebSocket’ instance cannot be used for communication because it has been transitioned into the ‘Aborted’ state</p>
</blockquote>
<p>可以通过加锁的方式确保线程安全。在异步方法中可以使用SemaphoreSlim来实现异步锁，避免阻塞线程。</p>
<p>下面我们来实现WebSocket服务端与客户端各自的心跳检测机制，以及客户端自动重连机制。首先服务端需要启动心跳检测任务，并对客户端发送过来的Ping消息作出Pong回应。服务端完整代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketServer</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _serverUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpListener _httpListener;</span><br><span class="line">    <span class="keyword">private</span> WebSocket _webSocket;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cancellationTokenSource;</span><br><span class="line">    <span class="keyword">private</span> CancellationToken _cancellationToken &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _cancellationTokenSource == <span class="literal">null</span> ? CancellationToken.None : _cancellationTokenSource.Token; &#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> HeartbeatInterval = <span class="number">5000</span>;  <span class="comment">// 心跳间隔时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PingMessage = <span class="string">&quot;Ping&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PongMessage = <span class="string">&quot;Pong&quot;</span>;</span><br><span class="line">    <span class="comment">//private readonly object _sendLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _sendSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="comment">//private readonly object _receiveLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _receiveSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketServer</span>(<span class="params"><span class="built_in">string</span> serverUri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _serverUri = serverUri;</span><br><span class="line">        _httpListener = <span class="keyword">new</span> HttpListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _httpListener.Prefixes.Add(_serverUri);</span><br><span class="line">        _httpListener.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;WebSocket服务已启动，服务地址：<span class="subst">&#123;_serverUri&#125;</span>，等待客户端连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HttpListenerContext httpContext = <span class="keyword">await</span> _httpListener.GetContextAsync();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (httpContext.Request.IsWebSocketRequest)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> HandleWebSocketConnectionAsync(httpContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                httpContext.Response.StatusCode = <span class="number">400</span>;</span><br><span class="line">                httpContext.Response.Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HandleWebSocketConnectionAsync</span>(<span class="params">HttpListenerContext httpContext</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WebSocketContext webSocketContext = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            webSocketContext = <span class="keyword">await</span> httpContext.AcceptWebSocketAsync(subProtocol: <span class="literal">null</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;接收到客户端连接，WebSocket连接已建立，等待客户端消息...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            httpContext.Response.StatusCode = <span class="number">500</span>;</span><br><span class="line">            httpContext.Response.Close();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;WebSocket连接失败: &quot;</span> + e.Message);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _webSocket = webSocketContext.WebSocket;</span><br><span class="line">        _cancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始心跳检测</span></span><br><span class="line">        <span class="keyword">var</span> heartbeatTask = HeartbeatAsync();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (_webSocket.State == WebSocketState.Open)</span><br><span class="line">        &#123;</span><br><span class="line">            WebSocketReceiveResult result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _receiveSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line">                result = <span class="keyword">await</span> _webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), _cancellationToken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket消息接收错误 :&quot;</span> + e.Message);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                _receiveSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Close)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, _cancellationToken);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;WebSocket连接已关闭!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Text)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理文本消息</span></span><br><span class="line">                <span class="built_in">string</span> message = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;接收到来自客户端的消息: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> SendMessageAsync(<span class="string">&quot;服务端已成功收到消息&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (message == PingMessage)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> SendMessageAsync(PongMessage);</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PongMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Binary)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理二进制消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _cancellationTokenSource.Cancel();</span><br><span class="line">        <span class="keyword">await</span> heartbeatTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">SendMessageAsync</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> _sendSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line">            <span class="keyword">var</span> msg = Encoding.UTF8.GetBytes(message);</span><br><span class="line">            <span class="keyword">await</span> _webSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(msg), WebSocketMessageType.Text, <span class="literal">true</span>, _cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _sendSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HeartbeatAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(HeartbeatInterval, _cancellationToken); </span><br><span class="line">                <span class="keyword">if</span> (_webSocket.State == WebSocketState.Open)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> SendMessageAsync(PingMessage);</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PingMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;WebSocket已关闭，心跳已停止.&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 任务被取消，跳出循环</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;心跳检测任务被取消，跳出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;心跳检测错误: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _webSocket.Dispose();</span><br><span class="line">            _cancellationTokenSource.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketServer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后客户端同样需要启动心跳检测任务，并对服务端发送过来的Ping消息作出Pong回应。此外，客户端还需要确保在连接断开后能自动重连。客户端完整代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WebSocketClient</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _uri;</span><br><span class="line">    <span class="keyword">private</span> ClientWebSocket _clientWebSocket;</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cancellationTokenSource;</span><br><span class="line">    <span class="keyword">private</span> CancellationToken _cancellationToken &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _cancellationTokenSource.Token; &#125; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> HeartbeatInterval = <span class="number">5000</span>;  <span class="comment">// 心跳间隔时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> ReconnectDelay = <span class="number">10000</span>; <span class="comment">// 重连延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PingMessage = <span class="string">&quot;Ping&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PongMessage = <span class="string">&quot;Pong&quot;</span>;</span><br><span class="line">    <span class="comment">//private readonly object _sendLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _sendSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="comment">//private readonly object _receiveLock = new object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _receiveSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 使用SemaphoreSlim实现异步锁，初始化时设置最大并发数为 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposedValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketClient</span>(<span class="params"><span class="built_in">string</span> uri</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _uri = uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 忽略自签名证书验证</span></span><br><span class="line">        ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                _clientWebSocket = <span class="keyword">new</span> ClientWebSocket(); <span class="comment">// 对于每一次连接尝试，都要重新创建一个ClientWebSocket实例，否则会一直提示&quot;The WebSocket has already been started&quot;</span></span><br><span class="line">                _cancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource(); <span class="comment">// 对于每一次连接尝试，都要重新创建一个CancellationTokenSource实例，否则会一直提示&quot;A task was canceled&quot;</span></span><br><span class="line">                <span class="keyword">await</span> _clientWebSocket.ConnectAsync(<span class="keyword">new</span> Uri(_uri), _cancellationToken); <span class="comment">// 无法对一个已经启动或已经关闭的ClientWebSocket实例再次调用ConnectAsync </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开始心跳检测</span></span><br><span class="line">                <span class="keyword">var</span> heartbeatTask = HeartbeatAsync();</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;客户端已连接上WebSocket服务器，握手请求后的服务地址为<span class="subst">&#123;_uri&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收消息</span></span><br><span class="line">                <span class="keyword">await</span> ReceiveMessagesAsync();</span><br><span class="line"></span><br><span class="line">                _cancellationTokenSource.Cancel();</span><br><span class="line">                <span class="keyword">await</span> heartbeatTask;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;WebSocket错误：<span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;在<span class="subst">&#123;ReconnectDelay / <span class="number">1000</span>&#125;</span>秒后尝试重连...&quot;</span>);</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(ReconnectDelay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">ReceiveMessagesAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (_clientWebSocket.State == WebSocketState.Open)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">await</span> _receiveSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> result = <span class="keyword">await</span> _clientWebSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), _cancellationToken);</span><br><span class="line">                    <span class="keyword">if</span> (result.MessageType == WebSocketMessageType.Close)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">await</span> _clientWebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, <span class="string">&quot;Closing&quot;</span>, _cancellationToken);</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;WebSocket客户端已关闭!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> message = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">                        Console.WriteLine(<span class="string">$&quot;接收到来自服务端的消息: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (message == PingMessage)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">await</span> SendMessageAsync(PongMessage);</span><br><span class="line">                            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PongMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 任务被取消，跳出循环</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;消息接收任务被取消，跳出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;客户端接收消息发生错误: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                _receiveSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">SendMessageAsync</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> _sendSemaphore.WaitAsync(_cancellationToken); <span class="comment">// 等待锁</span></span><br><span class="line">            <span class="keyword">var</span> msg = Encoding.UTF8.GetBytes(message);</span><br><span class="line">            <span class="keyword">await</span> _clientWebSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(msg), WebSocketMessageType.Text, <span class="literal">true</span>, _cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            _sendSemaphore.Release(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">HeartbeatAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_cancellationToken.IsCancellationRequested)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay(HeartbeatInterval, _cancellationToken);</span><br><span class="line">                <span class="keyword">if</span> (_clientWebSocket.State == WebSocketState.Open)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> SendMessageAsync(PingMessage);</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;PingMessage&#125;</span>已发送.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;WebSocket已关闭，心跳已停止.&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 任务被取消，跳出循环</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;心跳检测任务被取消，跳出循环&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;心跳检测错误: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disposedValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 释放托管状态(托管对象)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 释放未托管的资源(未托管的对象)并重写终结器</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 将大型字段设置为 null</span></span><br><span class="line">            disposedValue = <span class="literal">true</span>;</span><br><span class="line">            _clientWebSocket.Dispose();</span><br><span class="line">            _cancellationTokenSource.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 仅当“Dispose(bool disposing)”拥有用于释放未托管资源的代码时才替代终结器</span></span><br><span class="line">    ~WebSocketClient()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不要更改此代码。请将清理代码放入“Dispose(bool disposing)”方法中</span></span><br><span class="line">        Dispose(disposing: <span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示了客户端反复掉线重连时，服务端控制台的输出情况。</p>
<img   src="/Hexo-Blog/2024/08/18/websocket-usage/websocket_server_console.png"  class="" title="服务端控制台的输出情况">

<p>下图展示了服务端反复重启时，客户端控制台的输出情况。</p>
<img   src="/Hexo-Blog/2024/08/18/websocket-usage/websocket_client_console.png"  class="" title="客户端控制台的输出情况">

<h3 id="第三方库实现"><a href="#第三方库实现" class="headerlink" title="第三方库实现"></a>第三方库实现</h3><p>.NET中也可以引入Nuget包来实现WebSocket通信。</p>
<h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p>Fleck是C#中的一个WebSocket服务器实现，Fleck不依赖于HttpListener。下面借助Fleck来模拟一个WebSocket服务端。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Fleck;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FleckLog.Level = LogLevel.Debug;</span><br><span class="line">        <span class="keyword">var</span> allSockets = <span class="keyword">new</span> List&lt;IWebSocketConnection&gt;();</span><br><span class="line">        <span class="keyword">var</span> server = <span class="keyword">new</span> WebSocketServer(<span class="string">&quot;ws://127.0.0.1:8181&quot;</span>);</span><br><span class="line">        server.Start(socket =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            socket.OnOpen = () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                allSockets.Add(socket);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;当前客户端数量：&quot;</span> + allSockets.ToList().Count);</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.OnClose = () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;客户端已经关闭!&quot;</span>);</span><br><span class="line">                allSockets.Remove(socket);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;当前客户端数量：&quot;</span> + allSockets.ToList().Count);</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.OnMessage = message =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(message);</span><br><span class="line">                allSockets.ToList().ForEach(s =&gt; s.Send(message));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> socket <span class="keyword">in</span> allSockets.ToList())</span><br><span class="line">            &#123;</span><br><span class="line">                socket.Send(input);</span><br><span class="line">            &#125;</span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>WebSocket4Net是基于.NET的一个WebSocket客户端实现。下面借助WebSocket4Net来模拟一个WebSocket客户端。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> WebSocket4Net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> WebSocket webSocket4Net = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WebSocket4Net_Opened</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net.Send(<span class="string">$&quot;客户端连接成功，准备发送数据！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WebSocket4Net_MessageReceived</span>(<span class="params"><span class="built_in">object</span> sender, MessageReceivedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;服务端回复数据:<span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClientSendMsgToServer</span>(<span class="params"><span class="built_in">object</span> input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net.Send((<span class="built_in">string</span>)input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket4Net = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://127.0.0.1:8181&quot;</span>);</span><br><span class="line">        webSocket4Net.Opened += WebSocket4Net_Opened;</span><br><span class="line">        webSocket4Net.MessageReceived += WebSocket4Net_MessageReceived;</span><br><span class="line">        webSocket4Net.Open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">        <span class="keyword">while</span> (input != <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(ClientSendMsgToServer));</span><br><span class="line">            thread.Start(input);</span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        webSocket4Net.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持WSS-1"><a href="#支持WSS-1" class="headerlink" title="支持WSS"></a>支持WSS</h4><p>首先在基于Fleck实现的服务端中加载域名证书和密码，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> WebSocketServer(<span class="string">&quot;wss://127.0.0.1:8182&quot;</span>);</span><br><span class="line">server.Certificate = <span class="keyword">new</span> X509Certificate2(<span class="string">&quot;certificate.pfx&quot;</span>, <span class="string">&quot;&quot;</span>, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet); <span class="comment">// 自签名证书密码默认为&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在基于WebSocket4Net实现的客户端中修改握手后的升级请求(ws前缀改为wss)。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">webSocket4Net = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://127.0.0.1:8182&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://www.rfc-editor.org/rfc/rfc6455" >RFC 6455官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://websocket.xiniushu.com/" >WebSocket协议(RFC 6455中文版)<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://github.com/statianzo/Fleck" >Fleck开源项目地址<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://github.com/kerryjiang/WebSocket4Net" >WebSocket4Net开源项目地址<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Network-Protocol</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Wix和AutoUpdater的客户端打包与自动更新</title>
    <url>/Hexo-Blog/2024/08/19/wix-toolset-and-autoupdater/</url>
    <content><![CDATA[<p>使用Wix Toolset和AutoUpdater.NET实现Windows桌面应用程序的打包与自动更新功能。</p>
<span id="more"></span>

<h2 id="Wix-Toolset"><a href="#Wix-Toolset" class="headerlink" title="Wix Toolset"></a>Wix Toolset</h2><p>Wix Toolset是用来打包Windows Installer的工具集，通过编译源代码，然后链接以创建可执行文件。WiX命令行构建工具适用于任何自动化构建系统，MSBuild还支持常见的CI&#x2F;CD构建系统，如GitHub Actions。</p>
<p>使用WiX Bundle可以创建安装包来安装先决条件，例如.NET Framework和其他运行时环境以及自己的msi文件。WiX Bundle将他们组合成一个可下载的exe文件。</p>
<p>注: 以下使用的Wix Toolset版本为5.0，与低版本的语法有所区别。在Wix语法中，[]内容为库中预定义的全局变量(安装期间可使用)，$()为用户自己定义的全局变量，!(bind.)为绑定的属性，!(wix.)为Wix编译时的变量(安装期间不可使用)，!(loc.)为本地化之后的内容。</p>
<h3 id="Wix-Package"><a href="#Wix-Package" class="headerlink" title="Wix Package"></a>Wix Package</h3><p>Wix Package的基本功能是将应用程序打包成msi文件。此外，还支持桌面快捷方式、菜单快捷方式、卸载快捷方式添加，开机自启动，引导程序本地化等。</p>
<p>注: 需预先使用NuGet引入依赖包WixToolset.UI、WixToolset.Util</p>
<h4 id="快捷方式添加"><a href="#快捷方式添加" class="headerlink" title="快捷方式添加"></a>快捷方式添加</h4><p>Folders.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Wix</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://wixtoolset.org/schemas/v4/wxs&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 定义桌面快捷方式目录 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">StandardDirectory</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopFolder&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 定义菜单栏快捷方式目录 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">StandardDirectory</span> <span class="attr">Id</span>=<span class="string">&quot;ProgramMenuFolder&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Wix</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--桌面快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopShortcut&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">Directory</span>=<span class="string">&quot;DesktopFolder&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Installed&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--菜单栏快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;StartMenuShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;StartMenuShortcut&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">Directory</span>=<span class="string">&quot;ProgramMenuFolder&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Installed&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--卸载程序快捷方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallShortcutComponent&quot;</span> <span class="attr">Guid</span>=<span class="string">&quot;&#123;your-guid&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Shortcut</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallProduct&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;Uninstall&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;[SystemFolder]msiexec.exe&quot;</span> <span class="attr">Arguments</span>=<span class="string">&quot;/x [ProductCode]&quot;</span> <span class="attr">Icon</span>=<span class="string">&quot;UninstallIcon&quot;</span> <span class="attr">Description</span>=<span class="string">&quot;Uninstall &#123;your-product-name&#125;.&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Id</span>=<span class="string">&quot;RegUninstallShortcut&quot;</span> <span class="attr">Root</span>=<span class="string">&quot;HKCU&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\&#123;your-company-name&#125;\&#123;your-product-name&#125;&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;UninstallShortcut&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="快捷方式图标设置"><a href="#快捷方式图标设置" class="headerlink" title="快捷方式图标设置"></a>快捷方式图标设置</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 引用应用程序图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">Id</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> <span class="attr">SourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\icon.ico&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引用卸载图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Icon</span> <span class="attr">Id</span>=<span class="string">&quot;UninstallIcon&quot;</span> <span class="attr">SourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\uninstall.ico&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制面板引用应用程序图标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">Id</span>=<span class="string">&quot;ARPPRODUCTICON&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;&#123;your-icon-name&#125;&quot;</span> /&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">Id</span>=<span class="string">&quot;Register&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RegistryKey</span> <span class="attr">ForceCreateOnInstall</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Id</span>=<span class="string">&quot;AutoStartKey&quot;</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RegistryValue</span> <span class="attr">Id</span>=<span class="string">&quot;AutoStartKeyValue&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">KeyPath</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;[INSTALLFOLDER]&#123;your-product-name&#125;.exe&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RegistryValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RegistryKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="卸载或更改前自动关闭程序进程"><a href="#卸载或更改前自动关闭程序进程" class="headerlink" title="卸载或更改前自动关闭程序进程"></a>卸载或更改前自动关闭程序进程</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--卸载或更改前关闭程序进程--&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">Id</span>=<span class="string">&quot;TASKKILL&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">DirectorySearch</span> <span class="attr">Id</span>=<span class="string">&quot;SysDir&quot;</span> <span class="attr">Path</span>=<span class="string">&quot;[SystemFolder]&quot;</span> <span class="attr">Depth</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">FileSearch</span> <span class="attr">Id</span>=<span class="string">&quot;taskkillExe&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;taskkill.exe&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">DirectorySearch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">util:CloseApplication</span> <span class="attr">Id</span>=<span class="string">&quot;CloseApp&quot;</span> <span class="attr">CloseMessage</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Target</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">RebootPrompt</span>=<span class="string">&quot;no&quot;</span>  <span class="attr">PromptToContinue</span>=<span class="string">&quot;yes&quot;</span>  <span class="attr">Description</span>=<span class="string">&quot;!(loc.CloseBeforeUninstall)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">CustomAction</span> <span class="attr">Id</span>=<span class="string">&quot;WixCloseApplications&quot;</span> <span class="attr">Property</span>=<span class="string">&quot;TASKKILL&quot;</span> <span class="attr">Execute</span>=<span class="string">&quot;immediate&quot;</span> <span class="attr">Impersonate</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">Return</span>=<span class="string">&quot;ignore&quot;</span> <span class="attr">ExeCommand</span>=<span class="string">&quot;/F /FI <span class="symbol">&amp;quot;</span>IMAGENAME eq &#123;your-product-name&#125;.exe<span class="symbol">&amp;quot;</span>&quot;</span>/&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Package.zh-cn.wxl</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WixLocalization</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://wixtoolset.org/schemas/v4/wxl&quot;</span> <span class="attr">Culture</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="name">String</span> <span class="attr">Id</span>=<span class="string">&quot;CloseBeforeUninstall&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;请关闭应用程序后再进行卸载!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">String</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">WixLocalization</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="x86和x64平台区分可执行文件源"><a href="#x86和x64平台区分可执行文件源" class="headerlink" title="x86和x64平台区分可执行文件源"></a>x86和x64平台区分可执行文件源</h4><p>Package.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Package</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Manufacturer</span>=<span class="string">&quot;$(var.Manufacturer)&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;!(bind.FileVersion.ExeFile_m2)&quot;</span> <span class="attr">UpgradeCode</span>=<span class="string">&quot;$(var.UpgradeCode)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MajorUpgrade</span> <span class="attr">DowngradeErrorMessage</span>=<span class="string">&quot;!(loc.DowngradeError)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">MediaTemplate</span> <span class="attr">EmbedCab</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Files</span> <span class="attr">Include</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\**&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Exclude</span> <span class="attr">Files</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\&#123;your-product-name&#125;.exe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Exclude</span> <span class="attr">Files</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\&#123;your-product-name&#125;_x86.exe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">Id</span>=<span class="string">&quot;ExeFile_m2&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Source</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)&#123;your-product-name&#125;_x86.exe&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">Id</span>=<span class="string">&quot;ExeFile_m1&quot;</span> <span class="attr">Name</span>=<span class="string">&quot;&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Source</span>=<span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)&#123;your-product-name&#125;.exe&quot;</span> <span class="attr">Condition</span>=<span class="string">&quot;VersionNT64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Package</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="Wix-Bundle"><a href="#Wix-Bundle" class="headerlink" title="Wix Bundle"></a>Wix Bundle</h3><p>Wix Bundle主要用于设置系统必备组件，如各种依赖环境，可以根据目标平台区分依赖的安装包版本。此外还可引入主题文件，定制个性化安装界面。</p>
<p>注: 需预先使用NuGet引入依赖包WixToolset.BootstrapperApplications、WixToolset.Netfx、WixToolset.Util</p>
<h4 id="设置系统必备组件"><a href="#设置系统必备组件" class="headerlink" title="设置系统必备组件"></a>设置系统必备组件</h4><p>以下以.NET Core 6.0运行时和WebEdge WebView2运行时为例</p>
<p>Bundle.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Chain</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Define the .NET Core Runtime 6.0 dependency --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroupRef</span> <span class="attr">Id</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_t&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Define the Edge WebView2 Runtime dependency --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroupRef</span> <span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Other packages can be added here --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">MsiPackage</span> <span class="attr">Id</span>=<span class="string">&quot;MainPackage&quot;</span> <span class="attr">Compressed</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">SourceFile</span>= <span class="string">&quot;$(&#123;your-product-name&#125;.TargetDir)\zh-CN\&#123;your-product-name&#125;.msi&quot;</span> <span class="attr">Visible</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">MsiProperty</span> <span class="attr">Name</span>=<span class="string">&quot;INSTALLFOLDER&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;[InstallFolder]&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">MsiPackage</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Chain</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Define the package group for .NET Core Runtime 6.0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">netfx:DotNetCoreSearch</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">RuntimeType</span>=<span class="string">&quot;desktop&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Platform</span>=<span class="string">&quot;x86&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">MajorVersion</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Variable</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;<span class="name">netfx:DotNetCoreSearch</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">RuntimeType</span>=<span class="string">&quot;desktop&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Platform</span>=<span class="string">&quot;x64&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">MajorVersion</span>=<span class="string">&quot;6&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">Variable</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopNetCoreRuntime_6029_Redist_DetectCondition_x86&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;DesktopNetCoreRuntime_6029_Redist_DetectCondition_x64&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroup</span> <span class="attr">Id</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_t&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span> <span class="attr">Id</span>=<span class="string">&quot;NetCoreRuntime6_x86&quot;</span> <span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">		 	<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.DesktopNetCoreRuntime_6029_Redist_DetectCondition_x86)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallArguments</span>=<span class="string">&quot;/install /quiet&quot;</span>&gt;</span> <span class="comment">&lt;!-- 设置静默安装 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x86&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span> <span class="attr">Id</span>=<span class="string">&quot;NetCoreRuntime6_x64&quot;</span> <span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">		 	<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.DesktopNetCoreRuntime_6029_Redist_DetectCondition_x64)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallArguments</span>=<span class="string">&quot;/install /quiet&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;DESKTOPNETCORERUNTIME6_x64&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">PackageGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- Define the package group for Edge WebView2 Runtime --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">util:RegistrySearch</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\Microsoft\EdgeUpdate\Clients\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;pv&quot;</span> <span class="attr">Variable</span>=<span class="string">&quot;WVRTInstalled_x86&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">util:RegistrySearch</span> <span class="attr">Root</span>=<span class="string">&quot;HKLM&quot;</span> <span class="attr">Key</span>=<span class="string">&quot;Software\WOW6432Node\Microsoft\EdgeUpdate\Clients\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;pv&quot;</span> <span class="attr">Variable</span>=<span class="string">&quot;WVRTInstalled_x64&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;WV_DetectCondition_x86&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;WVRTInstalled_x86&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">WixVariable</span> <span class="attr">Id</span>=<span class="string">&quot;WV_DetectCondition_x64&quot;</span> <span class="attr">Value</span>=<span class="string">&quot;WVRTInstalled_x64&quot;</span> <span class="attr">Overridable</span>=<span class="string">&quot;yes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">PackageGroup</span> <span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper_x86&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.WV_DetectCondition_x86)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;NOT VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Vital</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">CacheId</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;WV_bootstrapper_x86&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span>  /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">ExePackage</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Id</span>=<span class="string">&quot;WV_bootstrapper_x64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">PerMachine</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">DetectCondition</span>=<span class="string">&quot;!(wix.WV_DetectCondition_x64)&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">InstallCondition</span>=<span class="string">&quot;VersionNT64&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Vital</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Permanent</span>=<span class="string">&quot;yes&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">Cache</span>=<span class="string">&quot;remove&quot;</span> <span class="attr">CacheId</span>=<span class="string">&quot;2&quot;</span>&gt;</span> </span><br><span class="line">			<span class="tag">&lt;<span class="name">ExePackagePayload</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Name</span>=<span class="string">&quot;WV_bootstrapper_x64&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">DownloadUrl</span>=<span class="string">&quot;&#123;dowload-url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Hash</span>=<span class="string">&quot;&#123;file-hash&#125;&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">Size</span>=<span class="string">&quot;&#123;file-size&#125;&quot;</span>  /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ExePackage</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">PackageGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="定制个性化安装界面"><a href="#定制个性化安装界面" class="headerlink" title="定制个性化安装界面"></a>定制个性化安装界面</h4><p>注意: CustomTheme.xml定义了安装窗口、页面、按钮等各种UI元素以及样式、响应事件，CustomLocalize.wxl定义了个性化文本内容，具体可参照<a class="link"   href="https://github.com/wixtoolset/wix" >Wix Toolset源码<i class="fas fa-external-link-alt"></i></a></p>
<p>Bundle.wxs</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">Bundle</span> <span class="attr">Name</span>=<span class="string">&quot;$(var.ProductName)&quot;</span> <span class="attr">Manufacturer</span>=<span class="string">&quot;$(var.Manufacturer)&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Version</span>=<span class="string">&quot;!(bind.packageVersion.MainPackage)&quot;</span> <span class="attr">UpgradeCode</span>=<span class="string">&quot;$(var.UpgradeCode)&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">IconSourceFile</span>=<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\&#123;your-company-name&#125;.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BootstrapperApplication</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bal:WixStandardBootstrapperApplication</span> <span class="attr">LicenseUrl</span>=<span class="string">&quot;&quot;</span> <span class="attr">Theme</span>=<span class="string">&quot;rtfLargeLicense&quot;</span> <span class="attr">ShowVersion</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">LogoFile</span> =<span class="string">&quot;$(var.&#123;your-product-name&#125;.ProjectDir)Resources\&#123;your-company-name&#125;.ico&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ThemeFile</span>=<span class="string">&quot;CustomTheme.xml&quot;</span> <span class="attr">LocalizationFile</span>=<span class="string">&quot;CustomLocalize.wxl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BootstrapperApplication</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Bundle</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AutoUpdater-NET"><a href="#AutoUpdater-NET" class="headerlink" title="AutoUpdater.NET"></a>AutoUpdater.NET</h2><p>AutoUpdater.NET是一个类库，可让.NET开发人员轻松地将自动更新功能添加到桌面应用程序项目中。AutoUpdater.NET会从服务器下载包含更新信息的XML文件。它使用该XML文件获取软件最新版本的信息。如果软件的最新版本大于用户PC上安装的软件的当前版本，AutoUpdater.NET就会向用户显示更新对话框。如果用户按下更新按钮更新软件，它就会从XML文件中提供的URL下载更新文件（安装程序），并执行刚刚下载的安装程序文件。此后，安装程序的工作就是执行更新。如果您提供的是zip文件URL而不是安装程序，AutoUpdater.NET将把zip文件的内容解压缩到应用程序目录。</p>
<h3 id="配置XML"><a href="#配置XML" class="headerlink" title="配置XML"></a>配置XML</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>&#123;your-download-url&#125;<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">changelog</span>&gt;</span>&#123;your-changelog-url&#125;<span class="tag">&lt;/<span class="name">changelog</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mandatory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">mandatory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="启动更新检查"><a href="#启动更新检查" class="headerlink" title="启动更新检查"></a>启动更新检查</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AutoUpdater.Start(<span class="string">&quot;&#123;your-xml-url&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="手动处理更新"><a href="#手动处理更新" class="headerlink" title="手动处理更新"></a>手动处理更新</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AutoUpdater.CheckForUpdateEvent += AutoUpdaterOnCheckForUpdateEvent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AutoUpdaterOnCheckForUpdateEvent</span>(<span class="params">UpdateInfoEventArgs args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.IsUpdateAvailable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> log = <span class="keyword">await</span> httpClient.GetStringAsync(args.ChangelogURL);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> textContent = <span class="string">$&quot;当前版本<span class="subst">&#123;args.InstalledVersion&#125;</span>, 最新版本<span class="subst">&#123;args.CurrentVersion&#125;</span>\n&quot;</span> +</span><br><span class="line">                              <span class="string">&quot;有新版本可用，是否立即更新？\n&quot;</span> + <span class="string">$&quot;<span class="subst">&#123;log&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">            MessageBoxResult result = MessageBox.Show(textContent, <span class="string">&quot;更新提示&quot;</span>, MessageBoxButton.YesNo, MessageBoxImage.Information);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == MessageBoxResult.Yes)</span><br><span class="line">            &#123;</span><br><span class="line">                Close();</span><br><span class="line">                AutoUpdater.DownloadUpdate(args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (HttpRequestException e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p><a class="link"   href="https://wixtoolset.org/docs/intro/" >Wix Toolset官方文档<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://github.com/wixtoolset/wix" >Wix Toolset开源项目地址<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://github.com/ravibpatel/AutoUpdater.NET" >AutoUpdater.NET开源项目地址<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://learn.microsoft.com/zh-cn/windows/win32/msi/properties" >Windows Installer在安装期间使用的全局变量<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Package-Tool</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Wix Toolset</tag>
      </tags>
  </entry>
</search>
